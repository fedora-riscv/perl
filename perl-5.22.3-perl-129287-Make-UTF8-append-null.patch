From be269dd17b2c617ae66d9bf8e185fa2cc8ac9407 Mon Sep 17 00:00:00 2001
From: Father Chrysostomos <sprout@cpan.org>
Date: Sun, 18 Sep 2016 20:17:08 -0700
Subject: [PATCH] Make UTF8 & append null
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Petr Písař: Ported to 5.22.3:

commit b43665fffa48dd179eba1b5616d4ca35b4def876
Author: Father Chrysostomos <sprout@cpan.org>
Date:   Sun Sep 18 20:17:08 2016 -0700

    [perl #129287] Make UTF8 & append null

    The & and &. operators were not appending a null byte to the string
    in utf8 mode.

    (The internal function that they use is the same.  I used &. in the
    test just because its intent is clearer.)

Signed-off-by: Petr Písař <ppisar@redhat.com>
---
 doop.c     |  1 +
 t/op/bop.t | 14 +++++++++++++-
 2 files changed, 14 insertions(+), 1 deletion(-)

diff --git a/doop.c b/doop.c
index c6ee847..ca122b4 100644
--- a/doop.c
+++ b/doop.c
@@ -1086,6 +1086,7 @@ Perl_do_vop(pTHX_ I32 optype, SV *sv, SV *left, SV *right)
 	    if (sv == left || sv == right)
 		(void)sv_usepvn(sv, dcorig, needlen);
 	    SvCUR_set(sv, dc - dcorig);
+	    *SvEND(sv) = 0;
 	    break;
 	case OP_BIT_XOR:
 	    while (lulen && rulen) {
diff --git a/t/op/bop.t b/t/op/bop.t
index 09f2be9..0de7f0b 100644
--- a/t/op/bop.t
+++ b/t/op/bop.t
@@ -15,7 +15,7 @@ BEGIN {
 # If you find tests are failing, please try adding names to tests to track
 # down where the failure is, and supply your new names as a patch.
 # (Just-in-time test naming)
-plan tests => 194 + (10*13*2) + 5;
+plan tests => 194 + (10*13*2) + 6;
 
 # numerics
 ok ((0xdead & 0xbeef) == 0x9ead);
@@ -620,3 +620,15 @@ $^A .= new version ~$_ for eval sprintf('"\\x%02x"', 0xff - ord("1")),
                            $::IS_EBCDIC ? v13 : v205, # 255 - ord('2')
                            eval sprintf('"\\x%02x"', 0xff - ord("3"));
 is $^A, "123", '~v0 clears vstring magic on retval';
+
+# [perl #129287] UTF8 & was not providing a trailing null byte.
+# This test is a bit convoluted, as we want to make sure that the string
+# allocated for &’s target contains memory initialised to something other
+# than a null byte.  Uninitialised memory does not make for a reliable
+# test.  So we do &. on a longer non-utf8 string first.
+for (["aaa","aaa"],[substr ("a\x{100}",0,1), "a"]) {
+    use feature "bitwise";
+    no warnings "experimental::bitwise", "pack";
+    $byte = substr unpack("P2", pack "P", $$_[0] &. $$_[1]), -1;
+}
+is $byte, "\0", "utf8 &. appends null byte";
-- 
2.7.4

