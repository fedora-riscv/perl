diff -up perl-5.10.0/ext/IO_Compress_Base/Changes.xxx perl-5.10.0/ext/IO_Compress_Base/Changes
--- perl-5.10.0/ext/IO_Compress_Base/Changes.xxx	2007-12-18 11:47:07.000000000 +0100
+++ perl-5.10.0/ext/IO_Compress_Base/Changes	2008-09-03 15:12:46.000000000 +0200
@@ -1,6 +1,74 @@
 CHANGES
 -------
 
+  2.015 3 September 2008
+
+      * Makefile.PL
+        Backout changes made in 2.014
+
+  2.014 2 September 2008
+
+      * Makefile.PL
+        Updated to check for indirect dependencies.
+
+  2.013 18 July 2008
+
+      * IO::Compress::Base 
+        - Allow IO::Compress::Base::Parameters::parse to accept an IO::Compress::Base::Parameters object.
+
+  2.012 15 July 2008
+
+      * IO::Compress::Base 
+        - Silenced an uninitialised value warning when reading a line
+          at a time from a zip file where the content uses ZIP_CM_STORE. 
+          [Problem spotted & fixed by Jeff Holt]
+
+      * IO::Compress::Base & IO::Uncompress::Base
+        - local-ise $!, $? et al in the DESTROY methods.
+          
+  2.011 17 May 2008
+
+      * IO::Compress::Base
+        - Fixed problem that prevented the creation of a zip file that
+          contained more than one compression method.
+
+      * IO::Compress::Base::Common
+        - The private Validator class in this module clashes with another
+          CPAN module. Moved Validator into the IO::Compress::Base::Common
+          namespace.
+          [RT #35954]
+
+  2.010 5 May 2008
+
+      * Fixed problem that meant Perl 5.10 could not upgrade this module.
+        [RT #35342]
+
+  2.009 20 April 2008
+
+      * Removed the alpha status from File::GlobMapper
+      
+      * IO::Compress::Base 
+        When writing output never output a zero length buffer.
+        Done to improve interoperability with other tied filenandle
+        modules.
+
+      * Changed IO::Uncompress::Base to not use the offset parameter of
+        the read method when reading from a filehandle. 
+
+        The object returned from Net::FTP::retr implements a non-standard
+        read method. The third parameter is used for a timeout value
+        rather than an offset.  
+        [rt.cpan#33231]
+        
+      * Changed IO::Uncompress::Base to not use the eof method when
+        reading from a filehandle. 
+
+        The object returned from Net::FTP::retr implements both the read
+        method and the eof method. Unfortunately the implementation of
+        the read method uses non-buffered IO (by using sysread) while
+        the eof method uses buffered IO. Mixing buffered and non-buffered
+        IO results in data corruption.
+
   2.008 2 November 2007
 
       * Minor documentation changes in README
diff -up perl-5.10.0/ext/IO_Compress_Base/lib/File/GlobMapper.pm.xxx perl-5.10.0/ext/IO_Compress_Base/lib/File/GlobMapper.pm
--- perl-5.10.0/ext/IO_Compress_Base/lib/File/GlobMapper.pm.xxx	2007-12-18 11:47:07.000000000 +0100
+++ perl-5.10.0/ext/IO_Compress_Base/lib/File/GlobMapper.pm	2008-02-18 23:23:15.000000000 +0100
@@ -26,7 +26,7 @@ BEGIN
 our ($Error);
 
 our ($VERSION, @EXPORT_OK);
-$VERSION = '0.000_02';
+$VERSION = '1.000';
 @EXPORT_OK = qw( globmap );
 
 
@@ -389,24 +389,6 @@ File::GlobMapper - Extend File Glob to A
 
 =head1 DESCRIPTION
 
-B<WARNING Alpha Release Alert!> 
-
-=over 5
-
-=item * This code is a work in progress. 
-
-=item * There are known bugs. 
-
-=item * The interface defined here is tentative. 
-
-=item * There are portability issues. 
-
-=item * Do not use in production code.
-
-=item * Consider yourself warned!
-
-=back
-
 This module needs Perl5.005 or better.
 
 This module takes the existing C<File::Glob> module as a starting point and
diff -up perl-5.10.0/ext/IO_Compress_Base/lib/IO/Compress/Base/Common.pm.xxx perl-5.10.0/ext/IO_Compress_Base/lib/IO/Compress/Base/Common.pm
--- perl-5.10.0/ext/IO_Compress_Base/lib/IO/Compress/Base/Common.pm.xxx	2007-12-18 11:47:07.000000000 +0100
+++ perl-5.10.0/ext/IO_Compress_Base/lib/IO/Compress/Base/Common.pm	2008-09-03 15:17:32.000000000 +0200
@@ -11,7 +11,7 @@ use File::GlobMapper;
 require Exporter;
 our ($VERSION, @ISA, @EXPORT, %EXPORT_TAGS, $HAS_ENCODE);
 @ISA = qw(Exporter);
-$VERSION = '2.008';
+$VERSION = '2.015';
 
 @EXPORT = qw( isaFilehandle isaFilename whatIsInput whatIsOutput 
               isaFileGlobString cleanFileGlobString oneTarget
@@ -192,7 +192,7 @@ sub oneTarget
     return $_[0] =~ /^(code|handle|buffer|filename)$/;
 }
 
-sub Validator::new
+sub IO::Compress::Base::Validator::new
 {
     my $class = shift ;
 
@@ -320,7 +320,7 @@ sub Validator::new
     return $obj ;
 }
 
-sub Validator::saveErrorString
+sub IO::Compress::Base::Validator::saveErrorString
 {
     my $self   = shift ;
     ${ $self->{Error} } = shift ;
@@ -328,7 +328,7 @@ sub Validator::saveErrorString
     
 }
 
-sub Validator::croakError
+sub IO::Compress::Base::Validator::croakError
 {
     my $self   = shift ;
     $self->saveErrorString($_[0]);
@@ -337,7 +337,7 @@ sub Validator::croakError
 
 
 
-sub Validator::validateInputFilenames
+sub IO::Compress::Base::Validator::validateInputFilenames
 {
     my $self = shift ;
 
@@ -367,7 +367,7 @@ sub Validator::validateInputFilenames
     return 1 ;
 }
 
-sub Validator::validateInputArray
+sub IO::Compress::Base::Validator::validateInputArray
 {
     my $self = shift ;
 
@@ -398,7 +398,7 @@ sub Validator::validateInputArray
     return 1 ;
 }
 
-#sub Validator::validateHash
+#sub IO::Compress::Base::Validator::validateHash
 #{
 #    my $self = shift ;
 #    my $href = shift ;
@@ -485,7 +485,11 @@ sub ParseParameters
 
     my $sub = (caller($level + 1))[3] ;
     local $Carp::CarpLevel = 1 ;
-    my $p = new IO::Compress::Base::Parameters() ;
+    
+    return $_[1]
+        if @_ == 2 && defined $_[1] && UNIVERSAL::isa($_[1], "IO::Compress::Base::Parameters");
+    
+    my $p = new IO::Compress::Base::Parameters() ;            
     $p->parse(@_)
         or croak "$sub: $p->{Error}" ;
 
@@ -534,6 +538,7 @@ sub IO::Compress::Base::Parameters::pars
 
     my $got = $self->{Got} ;
     my $firstTime = keys %{ $got } == 0 ;
+    my $other;
 
     my (@Bad) ;
     my @entered = () ;
@@ -544,7 +549,8 @@ sub IO::Compress::Base::Parameters::pars
         @entered = () ;
     }
     elsif (@_ == 1) {
-        my $href = $_[0] ;    
+        my $href = $_[0] ;
+    
         return $self->setError("Expected even number of parameters, got 1")
             if ! defined $href or ! ref $href or ref $href ne "HASH" ;
  
@@ -559,8 +565,13 @@ sub IO::Compress::Base::Parameters::pars
             if $count % 2 != 0 ;
         
         for my $i (0.. $count / 2 - 1) {
-            push @entered, $_[2* $i] ;
-            push @entered, \$_[2* $i+1] ;
+            if ($_[2 * $i] eq '__xxx__') {
+                $other = $_[2 * $i + 1] ;
+            }
+            else {
+                push @entered, $_[2 * $i] ;
+                push @entered, \$_[2 * $i + 1] ;
+            }
         }
     }
 
@@ -588,6 +599,24 @@ sub IO::Compress::Base::Parameters::pars
     }
 
     my %parsed = ();
+    
+    if ($other) 
+    {
+        for my $key (keys %$default)  
+        {
+            my $canonkey = lc $key;
+            if ($other->parsed($canonkey))
+            {
+                my $value = $other->value($canonkey);
+#print "SET '$canonkey' to $value [$$value]\n";
+                ++ $parsed{$canonkey};
+                $got->{$canonkey}[OFF_PARSED]  = 1;
+                $got->{$canonkey}[OFF_DEFAULT] = $value;
+                $got->{$canonkey}[OFF_FIXED]   = $value;
+            }
+        }
+    }
+    
     for my $i (0.. @entered / 2 - 1) {
         my $key = $entered[2* $i] ;
         my $value = $entered[2* $i+1] ;
diff -up perl-5.10.0/ext/IO_Compress_Base/lib/IO/Compress/Base.pm.xxx perl-5.10.0/ext/IO_Compress_Base/lib/IO/Compress/Base.pm
--- perl-5.10.0/ext/IO_Compress_Base/lib/IO/Compress/Base.pm.xxx	2007-12-18 11:47:07.000000000 +0100
+++ perl-5.10.0/ext/IO_Compress_Base/lib/IO/Compress/Base.pm	2008-09-03 15:17:23.000000000 +0200
@@ -6,7 +6,7 @@ require 5.004 ;
 use strict ;
 use warnings;
 
-use IO::Compress::Base::Common 2.008 ;
+use IO::Compress::Base::Common 2.015 ;
 
 use IO::File ;
 use Scalar::Util qw(blessed readonly);
@@ -20,7 +20,7 @@ use bytes;
 our (@ISA, $VERSION);
 @ISA    = qw(Exporter IO::File);
 
-$VERSION = '2.008';
+$VERSION = '2.015';
 
 #Can't locate object method "SWASHNEW" via package "utf8" (perhaps you forgot to load "utf8"?) at .../ext/Compress-Zlib/Gzip/blib/lib/Compress/Zlib/Common.pm line 16.
 
@@ -120,12 +120,14 @@ sub output
         &{ *$self->{FilterEnvelope} }();
     }
 
-    if ( defined *$self->{FH} ) {
-        defined *$self->{FH}->write( $data, length $data )
-          or return $self->saveErrorString(0, $!, $!); 
-    }
-    else {
-        ${ *$self->{Buffer} } .= $data ;
+    if (length $data) {
+        if ( defined *$self->{FH} ) {
+                defined *$self->{FH}->write( $data, length $data )
+                or return $self->saveErrorString(0, $!, $!); 
+        }
+        else {
+                ${ *$self->{Buffer} } .= $data ;
+        }
     }
 
     return 1;
@@ -234,7 +236,7 @@ sub _create
     my $status ;
     if (! $merge)
     {
-        *$obj->{Compress} = $obj->mkComp($class, $got)
+        *$obj->{Compress} = $obj->mkComp($got)
             or return undef;
         
         *$obj->{UnCompSize} = new U64 ;
@@ -321,7 +323,7 @@ sub _def
     my $haveOut = @_ ;
     my $output = shift ;
 
-    my $x = new Validator($class, *$obj->{Error}, $name, $input, $output)
+    my $x = new IO::Compress::Base::Validator($class, *$obj->{Error}, $name, $input, $output)
         or return undef ;
 
     push @_, $output if $haveOut && $x->{Hash};
@@ -545,6 +547,8 @@ sub UNTIE
 sub DESTROY
 {
     my $self = shift ;
+    local ($., $@, $!, $^E, $?);
+    
     $self->close() ;
 
     # TODO - memory leak with 5.8.0 - this isn't called until 
@@ -697,15 +701,13 @@ sub newStream
     $self->ckParams($got)
         or $self->croakError("newStream: $self->{Error}");
 
+    *$self->{Compress} = $self->mkComp($got)
+        or return 0;
+
     *$self->{Header} = $self->mkHeader($got) ;
     $self->output(*$self->{Header} )
         or return 0;
     
-    my $status = $self->reset() ;
-    return $self->saveErrorString(0, *$self->{Compress}{Error}, 
-                                  *$self->{Compress}{ErrorNo})
-        if $status == STATUS_ERROR;
-
     *$self->{UnCompSize}->reset();
     *$self->{CompSize}->reset();
 
@@ -939,23 +941,17 @@ __END__
 
 =head1 NAME
 
-
 IO::Compress::Base - Base Class for IO::Compress modules 
 
-
 =head1 SYNOPSIS
 
     use IO::Compress::Base ;
 
 =head1 DESCRIPTION
 
-
 This module is not intended for direct use in application code. Its sole
 purpose if to to be sub-classed by IO::Compress modules.
 
-
-
-
 =head1 SEE ALSO
 
 L<Compress::Zlib>, L<IO::Compress::Gzip>, L<IO::Uncompress::Gunzip>, L<IO::Compress::Deflate>, L<IO::Uncompress::Inflate>, L<IO::Compress::RawDeflate>, L<IO::Uncompress::RawInflate>, L<IO::Compress::Bzip2>, L<IO::Uncompress::Bunzip2>, L<IO::Compress::Lzop>, L<IO::Uncompress::UnLzop>, L<IO::Compress::Lzf>, L<IO::Uncompress::UnLzf>, L<IO::Uncompress::AnyInflate>, L<IO::Uncompress::AnyUncompress>
@@ -966,25 +962,18 @@ L<File::GlobMapper|File::GlobMapper>, L<
 L<Archive::Tar|Archive::Tar>,
 L<IO::Zlib|IO::Zlib>
 
-
-
-
-
 =head1 AUTHOR
 
 This module was written by Paul Marquess, F<pmqs@cpan.org>. 
 
-
-
 =head1 MODIFICATION HISTORY
 
 See the Changes file.
 
 =head1 COPYRIGHT AND LICENSE
 
-Copyright (c) 2005-2007 Paul Marquess. All rights reserved.
+Copyright (c) 2005-2008 Paul Marquess. All rights reserved.
 
 This program is free software; you can redistribute it and/or
 modify it under the same terms as Perl itself.
 
-
diff -up perl-5.10.0/ext/IO_Compress_Base/lib/IO/Uncompress/AnyUncompress.pm.xxx perl-5.10.0/ext/IO_Compress_Base/lib/IO/Uncompress/AnyUncompress.pm
--- perl-5.10.0/ext/IO_Compress_Base/lib/IO/Uncompress/AnyUncompress.pm.xxx	2007-12-18 11:47:07.000000000 +0100
+++ perl-5.10.0/ext/IO_Compress_Base/lib/IO/Uncompress/AnyUncompress.pm	2008-09-03 15:17:29.000000000 +0200
@@ -4,16 +4,16 @@ use strict;
 use warnings;
 use bytes;
 
-use IO::Compress::Base::Common 2.008 qw(createSelfTiedObject);
+use IO::Compress::Base::Common 2.015 qw(createSelfTiedObject);
 
-use IO::Uncompress::Base 2.008 ;
+use IO::Uncompress::Base 2.015 ;
 
 
 require Exporter ;
 
 our ($VERSION, @ISA, @EXPORT_OK, %EXPORT_TAGS, $AnyUncompressError);
 
-$VERSION = '2.008';
+$VERSION = '2.015';
 $AnyUncompressError = '';
 
 @ISA = qw( Exporter IO::Uncompress::Base );
@@ -27,18 +27,18 @@ Exporter::export_ok_tags('all');
 
 BEGIN
 {
-   eval ' use IO::Uncompress::Adapter::Inflate 2.008 ;';
-   eval ' use IO::Uncompress::Adapter::Bunzip2 2.008 ;';
-   eval ' use IO::Uncompress::Adapter::LZO 2.008 ;';
-   eval ' use IO::Uncompress::Adapter::Lzf 2.008 ;';
-
-   eval ' use IO::Uncompress::Bunzip2 2.008 ;';
-   eval ' use IO::Uncompress::UnLzop 2.008 ;';
-   eval ' use IO::Uncompress::Gunzip 2.008 ;';
-   eval ' use IO::Uncompress::Inflate 2.008 ;';
-   eval ' use IO::Uncompress::RawInflate 2.008 ;';
-   eval ' use IO::Uncompress::Unzip 2.008 ;';
-   eval ' use IO::Uncompress::UnLzf 2.008 ;';
+   eval ' use IO::Uncompress::Adapter::Inflate 2.015 ;';
+   eval ' use IO::Uncompress::Adapter::Bunzip2 2.015 ;';
+   eval ' use IO::Uncompress::Adapter::LZO 2.015 ;';
+   eval ' use IO::Uncompress::Adapter::Lzf 2.015 ;';
+
+   eval ' use IO::Uncompress::Bunzip2 2.015 ;';
+   eval ' use IO::Uncompress::UnLzop 2.015 ;';
+   eval ' use IO::Uncompress::Gunzip 2.015 ;';
+   eval ' use IO::Uncompress::Inflate 2.015 ;';
+   eval ' use IO::Uncompress::RawInflate 2.015 ;';
+   eval ' use IO::Uncompress::Unzip 2.015 ;';
+   eval ' use IO::Uncompress::UnLzf 2.015 ;';
 }
 
 sub new
@@ -56,7 +56,7 @@ sub anyuncompress
 
 sub getExtraParams
 {
-    use IO::Compress::Base::Common 2.008 qw(:Parse);
+    use IO::Compress::Base::Common 2.015 qw(:Parse);
     return ( 'RawInflate' => [1, 1, Parse_boolean,  0] ) ;
 }
 
@@ -75,7 +75,6 @@ sub ckParams
 sub mkUncomp
 {
     my $self = shift ;
-    my $class = shift ;
     my $got = shift ;
 
     my $magic ;
@@ -188,10 +187,8 @@ __END__
 
 =head1 NAME
 
-
 IO::Uncompress::AnyUncompress - Uncompress gzip, zip, bzip2 or lzop file/buffer
 
-
 =head1 SYNOPSIS
 
     use IO::Uncompress::AnyUncompress qw(anyuncompress $AnyUncompressError) ;
@@ -235,10 +232,8 @@ IO::Uncompress::AnyUncompress - Uncompre
     eof($z)
     close($z)
 
-
 =head1 DESCRIPTION
 
-
 This module provides a Perl interface that allows the reading of
 files/buffers that have been compressed with a variety of compression
 libraries.
@@ -266,9 +261,6 @@ The formats supported are:
 The module will auto-detect which, if any, of the supported
 compression formats is being used.
 
-
-
-
 =head1 Functional Interface
 
 A top-level function, C<anyuncompress>, is provided to carry out
@@ -281,14 +273,10 @@ section.
     anyuncompress $input => $output [,OPTS] 
         or die "anyuncompress failed: $AnyUncompressError\n";
 
-
-
 The functional interface needs Perl5.005 or better.
 
-
 =head2 anyuncompress $input => $output [, OPTS]
 
-
 C<anyuncompress> expects at least two parameters, C<$input> and C<$output>.
 
 =head3 The C<$input> parameter
@@ -327,8 +315,6 @@ The input data will be read from each fi
 The complete array will be walked to ensure that it only
 contains valid filenames before any data is uncompressed.
 
-
-
 =item An Input FileGlob string
 
 If C<$input> is a string that is delimited by the characters "<" and ">"
@@ -339,13 +325,10 @@ If the fileglob does not match any files
 
 See L<File::GlobMapper|File::GlobMapper> for more details.
 
-
 =back
 
 If the C<$input> parameter is any other type, C<undef> will be returned.
 
-
-
 =head3 The C<$output> parameter
 
 The parameter C<$output> is used to control the destination of the
@@ -365,14 +348,11 @@ If the C<$output> parameter is a filehan
 will be written to it.
 The string '-' can be used as an alias for standard output.
 
-
 =item A scalar reference 
 
 If C<$output> is a scalar reference, the uncompressed data will be
 stored in C<$$output>.
 
-
-
 =item An Array Reference
 
 If C<$output> is an array reference, the uncompressed data will be
@@ -391,20 +371,13 @@ string. Anything else is an error.
 
 If the C<$output> parameter is any other type, C<undef> will be returned.
 
-
-
 =head2 Notes
 
-
 When C<$input> maps to multiple compressed files/buffers and C<$output> is
 a single file/buffer, after uncompression C<$output> will contain a
 concatenation of all the uncompressed data from each of the input
 files/buffers.
 
-
-
-
-
 =head2 Optional Parameters
 
 Unless specified below, the optional parameters for C<anyuncompress>,
@@ -424,7 +397,6 @@ completed.
 
 This parameter defaults to 0.
 
-
 =item C<< BinModeOut => 0|1 >>
 
 When writing to a file or filehandle, set C<binmode> before writing to the
@@ -432,26 +404,17 @@ file.
 
 Defaults to 0.
 
-
-
-
-
 =item C<< Append => 0|1 >>
 
 TODO
 
 =item C<< MultiStream => 0|1 >>
 
-
 If the input file/buffer contains multiple compressed data streams, this
 option will uncompress the whole lot as a single data stream.
 
 Defaults to 0.
 
-
-
-
-
 =item C<< TrailingData => $scalar >>
 
 Returns the data, if any, that is present immediately after the compressed
@@ -471,19 +434,12 @@ of the input file. 
 
 Don't bother using C<trailingData> if the input is a filename.
 
-
-
 If you know the length of the compressed data stream before you start
 uncompressing, you can avoid having to use C<trailingData> by setting the
 C<InputLength> option.
 
-
-
 =back
 
-
-
-
 =head2 Examples
 
 To read the contents of the file C<file1.txt.Compressed> and write the
@@ -498,7 +454,6 @@ compressed data to the file C<file1.txt>
     anyuncompress $input => $output
         or die "anyuncompress failed: $AnyUncompressError\n";
 
-
 To read from an existing Perl filehandle, C<$input>, and write the
 uncompressed data to a buffer, C<$buffer>.
 
@@ -542,7 +497,6 @@ and if you want to compress each file on
 
 The format of the constructor for IO::Uncompress::AnyUncompress is shown below
 
-
     my $z = new IO::Uncompress::AnyUncompress $input [OPTS]
         or die "IO::Uncompress::AnyUncompress failed: $AnyUncompressError\n";
 
@@ -574,7 +528,6 @@ If the C<$input> parameter is a filehand
 read from it.
 The string '-' can be used as an alias for standard input.
 
-
 =item A scalar reference 
 
 If C<$input> is a scalar reference, the compressed data will be read from
@@ -584,7 +537,6 @@ C<$$output>.
 
 =head2 Constructor Options
 
-
 The option names defined below are case insensitive and can be optionally
 prefixed by a '-'.  So all of the following are valid
 
@@ -608,8 +560,6 @@ This parameter defaults to 0.
 
 =item C<< MultiStream => 0|1 >>
 
-
-
 Allows multiple concatenated compressed streams to be treated as a single
 compressed stream. Decompression will stop once either the end of the
 file/buffer is reached, an error is encountered (premature eof, corrupt
@@ -618,7 +568,6 @@ start of another stream.
 
 This parameter defaults to 0.
 
-
 =item C<< Prime => $string >>
 
 This option will uncompress the contents of C<$string> before processing the
@@ -660,8 +609,6 @@ This option is mostly used when reading 
 the file pointer will be left pointing to the first byte directly after the
 compressed data stream.
 
-
-
 This option defaults to off.
 
 =item C<< Append => 0|1 >>
@@ -678,24 +625,12 @@ Defaults to 0.
 
 =item C<< Strict => 0|1 >>
 
-
-
 This option controls whether the extra checks defined below are used when
 carrying out the decompression. When Strict is on, the extra tests are
 carried out, when Strict is off they are not.
 
 The default for this option is off.
 
-
-
-
-
-
-
-
-
-
-
 =item C<< RawInflate => 0|1 >>
 
 When auto-detecting the compressed format, try to test for raw-deflate (RFC
@@ -707,11 +642,6 @@ prone and can result is false positives.
 
 Defaults to 0.
 
-
-
-
-
-
 =back
 
 =head2 Examples
@@ -755,7 +685,6 @@ or an IO error is encountered.
 Returns the number of uncompressed bytes written to C<$buffer>, zero if eof
 or a negative number on error.
 
-
 =head2 getline
 
 Usage is
@@ -770,7 +699,6 @@ C<$INPUT_RECORD_SEPARATOR> or C<$RS> whe
 determine what constitutes an end of line. Paragraph mode, record mode and
 file slurp mode are all supported. 
 
-
 =head2 getc
 
 Usage is 
@@ -785,9 +713,6 @@ Usage is
 
     $char = $z->ungetc($string)
 
-
-
-
 =head2 getHeaderInfo
 
 Usage is
@@ -799,9 +724,6 @@ This method returns either a hash refere
 or hash references (in array context) that contains information about each
 of the header fields in the compressed data stream(s).
 
-
-
-
 =head2 tell
 
 Usage is
@@ -818,26 +740,17 @@ Usage is
     $z->eof();
     eof($z);
 
-
-
 Returns true if the end of the compressed input stream has been reached.
 
-
-
 =head2 seek
 
     $z->seek($position, $whence);
     seek($z, $position, $whence);
 
-
-
-
 Provides a sub-set of the C<seek> functionality, with the restriction
 that it is only legal to seek forward in the input file/buffer.
 It is a fatal error to attempt to seek backward.
 
-
-
 The C<$whence> parameter takes one the usual values, namely SEEK_SET,
 SEEK_CUR or SEEK_END.
 
@@ -879,8 +792,6 @@ retrieve the autoflush setting.
     $z->input_line_number()
     $z->input_line_number(EXPR)
 
-
-
 Returns the current uncompressed line number. If C<EXPR> is present it has
 the effect of setting the line number. Note that setting the line number
 does not change the current position within the file/buffer being read.
@@ -888,30 +799,25 @@ does not change the current position wit
 The contents of C<$/> are used to to determine what constitutes a line
 terminator.
 
-
-
 =head2 fileno
 
     $z->fileno()
     fileno($z)
 
-If the C<$z> object is associated with a file or a filehandle, this method
-will return the underlying file descriptor.
+If the C<$z> object is associated with a file or a filehandle, C<fileno>
+will return the underlying file descriptor. Once the C<close> method is
+called C<fileno> will return C<undef>.
 
-If the C<$z> object is is associated with a buffer, this method will
-return undef.
+If the C<$z> object is is associated with a buffer, this method will return
+C<undef>.
 
 =head2 close
 
     $z->close() ;
     close $z ;
 
-
-
 Closes the output file/buffer. 
 
-
-
 For most versions of Perl this method will be automatically invoked if
 the IO::Uncompress::AnyUncompress object is destroyed (either explicitly or by the
 variable with the reference to the object going out of scope). The
@@ -930,9 +836,6 @@ If the C<AutoClose> option has been enab
 object was created, and the object is associated with a file, the
 underlying file will also be closed.
 
-
-
-
 =head2 nextStream
 
 Usage is
@@ -971,8 +874,6 @@ of the input file. 
 
 Don't bother using C<trailingData> if the input is a filename.
 
-
-
 If you know the length of the compressed data stream before you start
 uncompressing, you can avoid having to use C<trailingData> by setting the
 C<InputLength> option in the constructor.
@@ -994,9 +895,6 @@ Same as doing this
 
 =head1 EXAMPLES
 
-
-
-
 =head1 SEE ALSO
 
 L<Compress::Zlib>, L<IO::Compress::Gzip>, L<IO::Uncompress::Gunzip>, L<IO::Compress::Deflate>, L<IO::Uncompress::Inflate>, L<IO::Compress::RawDeflate>, L<IO::Uncompress::RawInflate>, L<IO::Compress::Bzip2>, L<IO::Uncompress::Bunzip2>, L<IO::Compress::Lzop>, L<IO::Uncompress::UnLzop>, L<IO::Compress::Lzf>, L<IO::Uncompress::UnLzf>, L<IO::Uncompress::AnyInflate>
@@ -1007,23 +905,17 @@ L<File::GlobMapper|File::GlobMapper>, L<
 L<Archive::Tar|Archive::Tar>,
 L<IO::Zlib|IO::Zlib>
 
-
-
-
-
 =head1 AUTHOR
 
 This module was written by Paul Marquess, F<pmqs@cpan.org>. 
 
-
-
 =head1 MODIFICATION HISTORY
 
 See the Changes file.
 
 =head1 COPYRIGHT AND LICENSE
 
-Copyright (c) 2005-2007 Paul Marquess. All rights reserved.
+Copyright (c) 2005-2008 Paul Marquess. All rights reserved.
 
 This program is free software; you can redistribute it and/or
 modify it under the same terms as Perl itself.
diff -up perl-5.10.0/ext/IO_Compress_Base/lib/IO/Uncompress/Base.pm.xxx perl-5.10.0/ext/IO_Compress_Base/lib/IO/Uncompress/Base.pm
--- perl-5.10.0/ext/IO_Compress_Base/lib/IO/Uncompress/Base.pm.xxx	2007-12-18 11:47:07.000000000 +0100
+++ perl-5.10.0/ext/IO_Compress_Base/lib/IO/Uncompress/Base.pm	2008-09-03 18:36:10.000000000 +0200
@@ -9,12 +9,12 @@ our (@ISA, $VERSION, @EXPORT_OK, %EXPORT
 @ISA    = qw(Exporter IO::File);
 
 
-$VERSION = '2.008';
+$VERSION = '2.015';
 
 use constant G_EOF => 0 ;
 use constant G_ERR => -1 ;
 
-use IO::Compress::Base::Common 2.008 ;
+use IO::Compress::Base::Common 2.015 ;
 #use Parse::Parameters ;
 
 use IO::File ;
@@ -28,6 +28,7 @@ push @{ $EXPORT_TAGS{all} }, @EXPORT_OK 
 #Exporter::export_ok_tags('all') ;
 
 
+
 sub smartRead
 {
     my $self = $_[0];
@@ -59,12 +60,21 @@ sub smartRead
 
     my $get_size = $size - $offset ;
 
-    #if ( defined *$self->{InputLength} ) {
-    #    $get_size = min($get_size, *$self->{InputLengthRemaining});
-    #}
-
-    if (defined *$self->{FH})
-      { *$self->{FH}->read($$out, $get_size, $offset) }
+    if (defined *$self->{FH}) {
+        if ($offset) {
+            # Not using this 
+            #
+            #  *$self->{FH}->read($$out, $get_size, $offset);
+            #
+            # because the filehandle may not support the offset parameter
+            # An example is Net::FTP
+            my $tmp = '';
+            *$self->{FH}->read($tmp, $get_size) > 0 &&
+                (substr($$out, $offset) = $tmp);
+        }
+        else
+          { *$self->{FH}->read($$out, $get_size) }
+    }
     elsif (defined *$self->{InputEvent}) {
         my $got = 1 ;
         while (length $$out < $size) {
@@ -174,7 +184,24 @@ sub smartEof
     return 0 if length *$self->{Prime} || *$self->{PushMode};
 
     if (defined *$self->{FH})
-     { *$self->{FH}->eof() }
+    {
+        # Could use
+        #
+        #  *$self->{FH}->eof() 
+        #
+        # here, but this can cause trouble if
+        # the filehandle is itself a tied handle, but it uses sysread.
+        # Then we get into mixing buffered & non-buffered IO, which will cause trouble
+
+        my $info = $self->getErrInfo();
+        
+        my $buffer = '';
+        my $status = $self->smartRead(\$buffer, 1);
+        $self->pushBack($buffer) if length $buffer;
+        $self->setErrInfo($info);
+        
+        return $status == 0 ;
+    }
     elsif (defined *$self->{InputEvent})
      { *$self->{EventEof} }
     else 
@@ -189,6 +216,22 @@ sub clearError
     ${ *$self->{Error} } = '' ;
 }
 
+sub getErrInfo
+{
+    my $self   = shift ;
+
+    return [ *$self->{ErrorNo}, ${ *$self->{Error} } ] ;
+}
+
+sub setErrInfo
+{
+    my $self   = shift ;
+    my $ref    = shift;
+
+    *$self->{ErrorNo}  =  $ref->[0] ;
+    ${ *$self->{Error} } = $ref->[1] ;
+}
+
 sub saveStatus
 {
     my $self   = shift ;
@@ -425,7 +468,7 @@ sub _create
         return $obj
     }
 
-    my $status = $obj->mkUncomp($class, $got);
+    my $status = $obj->mkUncomp($got);
 
     return undef
         unless defined $status;
@@ -490,7 +533,7 @@ sub _inf
     my $output = shift ;
 
 
-    my $x = new Validator($class, *$obj->{Error}, $name, $input, $output)
+    my $x = new IO::Compress::Base::Validator($class, *$obj->{Error}, $name, $input, $output)
         or return undef ;
     
     push @_, $output if $haveOut && $x->{Hash};
@@ -813,7 +856,7 @@ sub _raw_read
         $self->postBlockChk($buffer, $before_len) == STATUS_OK
             or return G_ERR;
 
-        $buf_len = length($$buffer) - $before_len;
+        $buf_len = defined $$buffer ? length($$buffer) - $before_len : 0;
     
         *$self->{CompSize}->add($beforeC_len - length $temp_buf) ;
 
@@ -929,7 +972,7 @@ sub gotoNextStream
     my $magic = $self->ckMagic();
     #*$self->{EndStream} = 0 ;
 
-    if ( ! $magic) {
+    if ( ! defined $magic) {
         if (! *$self->{Transparent} )
         {
             *$self->{EndStream} = 1 ;
@@ -1247,6 +1290,8 @@ sub close
 sub DESTROY
 {
     my $self = shift ;
+    local ($., $@, $!, $^E, $?);
+
     $self->close() ;
 }
 
@@ -1372,23 +1417,17 @@ __END__
 
 =head1 NAME
 
-
 IO::Uncompress::Base - Base Class for IO::Uncompress modules 
 
-
 =head1 SYNOPSIS
 
     use IO::Uncompress::Base ;
 
 =head1 DESCRIPTION
 
-
 This module is not intended for direct use in application code. Its sole
 purpose if to to be sub-classed by IO::Unompress modules.
 
-
-
-
 =head1 SEE ALSO
 
 L<Compress::Zlib>, L<IO::Compress::Gzip>, L<IO::Uncompress::Gunzip>, L<IO::Compress::Deflate>, L<IO::Uncompress::Inflate>, L<IO::Compress::RawDeflate>, L<IO::Uncompress::RawInflate>, L<IO::Compress::Bzip2>, L<IO::Uncompress::Bunzip2>, L<IO::Compress::Lzop>, L<IO::Uncompress::UnLzop>, L<IO::Compress::Lzf>, L<IO::Uncompress::UnLzf>, L<IO::Uncompress::AnyInflate>, L<IO::Uncompress::AnyUncompress>
@@ -1399,23 +1438,17 @@ L<File::GlobMapper|File::GlobMapper>, L<
 L<Archive::Tar|Archive::Tar>,
 L<IO::Zlib|IO::Zlib>
 
-
-
-
-
 =head1 AUTHOR
 
 This module was written by Paul Marquess, F<pmqs@cpan.org>. 
 
-
-
 =head1 MODIFICATION HISTORY
 
 See the Changes file.
 
 =head1 COPYRIGHT AND LICENSE
 
-Copyright (c) 2005-2007 Paul Marquess. All rights reserved.
+Copyright (c) 2005-2008 Paul Marquess. All rights reserved.
 
 This program is free software; you can redistribute it and/or
 modify it under the same terms as Perl itself.
diff -up perl-5.10.0/ext/IO_Compress_Base/Makefile.PL.xxx perl-5.10.0/ext/IO_Compress_Base/Makefile.PL
--- perl-5.10.0/ext/IO_Compress_Base/Makefile.PL.xxx	2007-12-18 11:47:07.000000000 +0100
+++ perl-5.10.0/ext/IO_Compress_Base/Makefile.PL	2008-09-03 15:13:04.000000000 +0200
@@ -37,6 +37,12 @@ WriteMakefile( 
 
     INSTALLDIRS => ($] >= 5.009 ? 'perl' : 'site'),
 
+    (
+    $] >= 5.009 && ! $ENV{PERL_CORE}
+        ? (INST_LIB    => 'blib/arch')
+        : ()
+    ),
+
     ((ExtUtils::MakeMaker->VERSION() gt '6.30') ?
         ('LICENSE'  => 'perl')         : ()),
     
diff -up perl-5.10.0/ext/IO_Compress_Base/private/MakeUtil.pm.xxx perl-5.10.0/ext/IO_Compress_Base/private/MakeUtil.pm
--- perl-5.10.0/ext/IO_Compress_Base/private/MakeUtil.pm.xxx	2007-12-18 11:47:07.000000000 +0100
+++ perl-5.10.0/ext/IO_Compress_Base/private/MakeUtil.pm	2008-09-02 15:14:33.000000000 +0200
@@ -6,6 +6,8 @@ use strict ;
 use Config qw(%Config);
 use File::Copy;
 
+my $VERSION = '1.0';
+
 
 BEGIN
 {
@@ -47,6 +49,11 @@ sub MY::postamble 
 
     my @files = getPerlFiles('MANIFEST');
 
+    # Note: Once you remove all the layers of shell/makefile escaping 
+    # the regular expression below reads
+    #
+    #    /^\s*local\s*\(\s*\$^W\s*\)/
+    #
     my $postamble = '
 
 MyTrebleCheck:
@@ -290,6 +297,83 @@ sub doUpDownViaCopy
     }
 }
 
+
+sub FindBrokenDependencies
+{
+    my $version = shift ;
+    my %thisModule = map { $_ => 1} @_;
+
+    my @modules = qw(
+                    IO::Compress::Base
+                    IO::Compress::Base::Common
+                    IO::Uncompress::Base
+
+                    Compress::Raw::Zlib
+                    Compress::Raw::Bzip2
+
+                    IO::Compress::RawDeflate
+                    IO::Uncompress::RawInflate
+                    IO::Compress::Deflate
+                    IO::Uncompress::Inflate
+                    IO::Compress::Gzip
+                    IO::Compress::Gzip::Constants
+                    IO::Uncompress::Gunzip
+                    IO::Compress::Zip
+                    IO::Uncompress::Unzip
+
+                    IO::Compress::Bzip2
+                    IO::Uncompress::Bunzip2
+
+                    IO::Compress::Lzf
+                    IO::Uncompress::UnLzf
+
+                    IO::Compress::Lzop
+                    IO::Uncompress::UnLzop
+
+                    Compress::Zlib
+                    );
+    
+    my @broken = ();
+
+    foreach my $module ( grep { ! $thisModule{$_} } @modules)
+    {
+        my $hasVersion = getInstalledVersion($module);
+
+        # No need to upgrade if the module isn't installed at all
+        next 
+            if ! defined $hasVersion;
+
+        # If already have C::Z version 1, then an upgrade to any of the
+        # IO::Compress modules will not break it.
+        next 
+            if $module eq 'Compress::Zlib' && $hasVersion < 2;
+
+        if ($hasVersion < $version)
+        {
+            push @broken, $module
+        }
+    }
+
+    return @broken;
+}
+
+sub getInstalledVersion
+{
+    my $module = shift;
+    my $version;
+
+    eval " require $module; ";
+
+    if ($@ eq '')
+    {
+        no strict 'refs';
+        $version = ${ $module . "::VERSION" };
+        $version = 0 
+    }
+    
+    return $version;
+}
+
 package MakeUtil ;
 
 1;
diff -up perl-5.10.0/ext/IO_Compress_Base/t/000prereq.t.xxx perl-5.10.0/ext/IO_Compress_Base/t/000prereq.t
--- perl-5.10.0/ext/IO_Compress_Base/t/000prereq.t.xxx	2009-11-30 14:13:14.454095259 +0100
+++ perl-5.10.0/ext/IO_Compress_Base/t/000prereq.t	2008-02-18 23:23:15.000000000 +0100
@@ -0,0 +1,54 @@
+BEGIN {
+    if ($ENV{PERL_CORE}) {
+        chdir 't' if -d 't';
+        @INC = ("../lib", "lib/compress");
+    }
+}
+
+use lib qw(t t/compress);
+use strict ;
+use warnings ;
+
+use Test::More ;
+
+BEGIN
+{
+    # use Test::NoWarnings, if available
+    my $extra = 0 ;
+    $extra = 1
+        if eval { require Test::NoWarnings ;  import Test::NoWarnings; 1 };
+
+
+    my $VERSION = '2.003';
+    my @NAMES = qw(
+			
+			);
+
+    my @OPT = qw(
+			);
+
+    plan tests => 1 + @NAMES + @OPT + $extra ;
+
+    ok 1 ;
+
+    foreach my $name (@NAMES)
+    {
+        use_ok($name, $VERSION);
+    }
+
+    foreach my $name (@OPT)
+    {
+        eval " require $name " ;
+        if ($@)
+        {
+            ok 1, "$name not available" 
+        }
+        else  
+        {
+            my $ver = eval("\$${name}::VERSION");
+            is $ver, $VERSION, "$name version should be $VERSION" 
+                or diag "$name version is $ver, need $VERSION" ;
+        }         
+    }
+}
+
diff -up perl-5.10.0/ext/IO_Compress_Base/t/01misc.t.xxx perl-5.10.0/ext/IO_Compress_Base/t/01misc.t
--- perl-5.10.0/ext/IO_Compress_Base/t/01misc.t.xxx	2007-12-18 11:47:07.000000000 +0100
+++ perl-5.10.0/ext/IO_Compress_Base/t/01misc.t	2008-07-18 18:53:12.000000000 +0200
@@ -19,7 +19,7 @@ BEGIN {
     $extra = 1
         if eval { require Test::NoWarnings ;  import Test::NoWarnings; 1 };
 
-    plan tests => 78 + $extra ;
+    plan tests => 88 + $extra ;
 
     use_ok('Scalar::Util');
     use_ok('IO::Compress::Base::Common');
@@ -95,13 +95,11 @@ sub My::testParseParameters()
     my $got = ParseParameters(1, {'Fred' => [1, 1, 0x1000000, 0]}, Fred => 'abc') ;
     is $got->value('Fred'), "abc", "other" ;
 
-    $got = ParseParameters(1, {'Fred' => [0, 1, Parse_any, undef]}, Fred =>
-undef) ;
+    $got = ParseParameters(1, {'Fred' => [0, 1, Parse_any, undef]}, Fred => undef) ;
     ok $got->parsed('Fred'), "undef" ;
     ok ! defined $got->value('Fred'), "undef" ;
 
-    $got = ParseParameters(1, {'Fred' => [0, 1, Parse_string, undef]}, Fred =>
-undef) ;
+    $got = ParseParameters(1, {'Fred' => [0, 1, Parse_string, undef]}, Fred => undef) ;
     ok $got->parsed('Fred'), "undef" ;
     is $got->value('Fred'), "", "empty string" ;
 
@@ -117,11 +115,41 @@ undef) ;
 
     ok $got->parsed('Fred'), "parsed" ;
     $xx_ref = $got->value('Fred');
+
     $$xx_ref = 666 ;
     is $xx, 666;
 
+    {
+        my $got1 = ParseParameters(1, {'Fred' => [1, 1, Parse_writable_scalar, undef]}, $got) ;
+        is $got1, $got, "Same object";
+    
+        ok $got1->parsed('Fred'), "parsed" ;
+        $xx_ref = $got1->value('Fred');
+        
+        $$xx_ref = 777 ;
+        is $xx, 777;
+    }
+    
+    my $got2 = ParseParameters(1, {'Fred' => [1, 1, Parse_writable_scalar, undef]}, '__xxx__' => $got) ;
+    isnt $got2, $got, "not the Same object";
+
+    ok $got2->parsed('Fred'), "parsed" ;
+    $xx_ref = $got2->value('Fred');
+    $$xx_ref = 888 ;
+    is $xx, 888;  
+      
+    my $other;
+    my $got3 = ParseParameters(1, {'Fred' => [1, 1, Parse_writable_scalar, undef]}, '__xxx__' => $got, Fred => \$other) ;
+    isnt $got3, $got, "not the Same object";
+
+    ok $got3->parsed('Fred'), "parsed" ;
+    $xx_ref = $got3->value('Fred');
+    $$xx_ref = 999 ;
+    is $other, 999;  
+    is $xx, 888;  
 }
 
+
 My::testParseParameters();
 
 
diff -up perl-5.10.0/ext/IO_Compress_Base/t/99pod.t.xxx perl-5.10.0/ext/IO_Compress_Base/t/99pod.t
--- perl-5.10.0/ext/IO_Compress_Base/t/99pod.t.xxx	2009-11-30 14:13:22.910348530 +0100
+++ perl-5.10.0/ext/IO_Compress_Base/t/99pod.t	2008-02-18 23:23:15.000000000 +0100
@@ -0,0 +1,16 @@
+BEGIN {
+    if ($ENV{PERL_CORE}) {
+	chdir 't' if -d 't';
+	@INC = ("../lib", "lib/compress");
+    }
+}
+
+use lib qw(t t/compress);
+use Test::More;
+
+eval "use Test::Pod 1.00";
+
+plan skip_all => "Test::Pod 1.00 required for testing POD" if $@;
+
+all_pod_files_ok();
+
diff -up perl-5.10.0/ext/IO_Compress_Base/t/globmapper.t.xxx perl-5.10.0/ext/IO_Compress_Base/t/globmapper.t
diff -urN perl-5.10.0/ext/IO_Compress_Base/t.xxx/01misc.t perl-5.10.0/ext/IO_Compress_Base/t/01misc.t
--- perl-5.10.0/ext/IO_Compress_Base/t.xxx/01misc.t	1970-01-01 01:00:00.000000000 +0100
+++ perl-5.10.0/ext/IO_Compress_Base/t/01misc.t	2007-12-18 11:47:07.000000000 +0100
@@ -0,0 +1,253 @@
+BEGIN {
+    if ($ENV{PERL_CORE}) {
+	chdir 't' if -d 't';
+	@INC = ("../lib", "lib/compress");
+    }
+}
+
+use lib qw(t t/compress);
+use strict;
+use warnings;
+use bytes;
+
+use Test::More ; 
+use CompTestUtils;
+
+BEGIN {
+    # use Test::NoWarnings, if available
+    my $extra = 0 ;
+    $extra = 1
+        if eval { require Test::NoWarnings ;  import Test::NoWarnings; 1 };
+
+    plan tests => 78 + $extra ;
+
+    use_ok('Scalar::Util');
+    use_ok('IO::Compress::Base::Common');
+}
+
+
+ok gotScalarUtilXS(), "Got XS Version of Scalar::Util"
+    or diag <<EOM;
+You don't have the XS version of Scalar::Util
+EOM
+
+# Compress::Zlib::Common;
+
+sub My::testParseParameters()
+{
+    eval { ParseParameters(1, {}, 1) ; };
+    like $@, mkErr(': Expected even number of parameters, got 1'), 
+            "Trap odd number of params";
+
+    eval { ParseParameters(1, {}, undef) ; };
+    like $@, mkErr(': Expected even number of parameters, got 1'), 
+            "Trap odd number of params";
+
+    eval { ParseParameters(1, {}, []) ; };
+    like $@, mkErr(': Expected even number of parameters, got 1'), 
+            "Trap odd number of params";
+
+    eval { ParseParameters(1, {'Fred' => [1, 1, Parse_boolean, 0]}, Fred => 'joe') ; };
+    like $@, mkErr("Parameter 'Fred' must be an int, got 'joe'"), 
+            "wanted unsigned, got undef";
+
+    eval { ParseParameters(1, {'Fred' => [1, 1, Parse_unsigned, 0]}, Fred => undef) ; };
+    like $@, mkErr("Parameter 'Fred' must be an unsigned int, got 'undef'"), 
+            "wanted unsigned, got undef";
+
+    eval { ParseParameters(1, {'Fred' => [1, 1, Parse_signed, 0]}, Fred => undef) ; };
+    like $@, mkErr("Parameter 'Fred' must be a signed int, got 'undef'"), 
+            "wanted signed, got undef";
+
+    eval { ParseParameters(1, {'Fred' => [1, 1, Parse_signed, 0]}, Fred => 'abc') ; };
+    like $@, mkErr("Parameter 'Fred' must be a signed int, got 'abc'"), 
+            "wanted signed, got 'abc'";
+
+
+    SKIP:
+    {
+        use Config;
+
+        skip 'readonly + threads', 1
+            if $Config{useithreads};
+
+        eval { ParseParameters(1, {'Fred' => [1, 1, Parse_writable_scalar, 0]}, Fred => 'abc') ; };
+        like $@, mkErr("Parameter 'Fred' not writable"), 
+                "wanted writable, got readonly";
+    }
+
+    my @xx;
+    eval { ParseParameters(1, {'Fred' => [1, 1, Parse_writable_scalar, 0]}, Fred => \@xx) ; };
+    like $@, mkErr("Parameter 'Fred' not a scalar reference"), 
+            "wanted scalar reference";
+
+    local *ABC;
+    eval { ParseParameters(1, {'Fred' => [1, 1, Parse_writable_scalar, 0]}, Fred => *ABC) ; };
+    like $@, mkErr("Parameter 'Fred' not a scalar"), 
+            "wanted scalar";
+
+    #eval { ParseParameters(1, {'Fred' => [1, 1, Parse_any|Parse_multiple, 0]}, Fred => 1, Fred => 2) ; };
+    #like $@, mkErr("Muliple instances of 'Fred' found"),
+        #"wanted scalar";
+
+    ok 1;
+
+    my $got = ParseParameters(1, {'Fred' => [1, 1, 0x1000000, 0]}, Fred => 'abc') ;
+    is $got->value('Fred'), "abc", "other" ;
+
+    $got = ParseParameters(1, {'Fred' => [0, 1, Parse_any, undef]}, Fred =>
+undef) ;
+    ok $got->parsed('Fred'), "undef" ;
+    ok ! defined $got->value('Fred'), "undef" ;
+
+    $got = ParseParameters(1, {'Fred' => [0, 1, Parse_string, undef]}, Fred =>
+undef) ;
+    ok $got->parsed('Fred'), "undef" ;
+    is $got->value('Fred'), "", "empty string" ;
+
+    my $xx;
+    $got = ParseParameters(1, {'Fred' => [1, 1, Parse_writable_scalar, undef]}, Fred => $xx) ;
+
+    ok $got->parsed('Fred'), "parsed" ;
+    my $xx_ref = $got->value('Fred');
+    $$xx_ref = 77 ;
+    is $xx, 77;
+
+    $got = ParseParameters(1, {'Fred' => [1, 1, Parse_writable_scalar, undef]}, Fred => \$xx) ;
+
+    ok $got->parsed('Fred'), "parsed" ;
+    $xx_ref = $got->value('Fred');
+    $$xx_ref = 666 ;
+    is $xx, 666;
+
+}
+
+My::testParseParameters();
+
+
+{
+    title "isaFilename" ;
+    ok   isaFilename("abc"), "'abc' isaFilename";
+
+    ok ! isaFilename(undef), "undef ! isaFilename";
+    ok ! isaFilename([]),    "[] ! isaFilename";
+    $main::X = 1; $main::X = $main::X ;
+    ok ! isaFilename(*X),    "glob ! isaFilename";
+}
+
+{
+    title "whatIsInput" ;
+
+    my $lex = new LexFile my $out_file ;
+    open FH, ">$out_file" ;
+    is whatIsInput(*FH), 'handle', "Match filehandle" ;
+    close FH ;
+
+    my $stdin = '-';
+    is whatIsInput($stdin),       'handle',   "Match '-' as stdin";
+    #is $stdin,                    \*STDIN,    "'-' changed to *STDIN";
+    #isa_ok $stdin,                'IO::File',    "'-' changed to IO::File";
+    is whatIsInput("abc"),        'filename', "Match filename";
+    is whatIsInput(\"abc"),       'buffer',   "Match buffer";
+    is whatIsInput(sub { 1 }, 1), 'code',     "Match code";
+    is whatIsInput(sub { 1 }),    ''   ,      "Don't match code";
+
+}
+
+{
+    title "whatIsOutput" ;
+
+    my $lex = new LexFile my $out_file ;
+    open FH, ">$out_file" ;
+    is whatIsOutput(*FH), 'handle', "Match filehandle" ;
+    close FH ;
+
+    my $stdout = '-';
+    is whatIsOutput($stdout),     'handle',   "Match '-' as stdout";
+    #is $stdout,                   \*STDOUT,   "'-' changed to *STDOUT";
+    #isa_ok $stdout,               'IO::File',    "'-' changed to IO::File";
+    is whatIsOutput("abc"),        'filename', "Match filename";
+    is whatIsOutput(\"abc"),       'buffer',   "Match buffer";
+    is whatIsOutput(sub { 1 }, 1), 'code',     "Match code";
+    is whatIsOutput(sub { 1 }),    ''   ,      "Don't match code";
+
+}
+
+# U64
+
+{
+    title "U64" ;
+
+    my $x = new U64();
+    is $x->getHigh, 0, "  getHigh is 0";
+    is $x->getLow, 0, "  getLow is 0";
+
+    $x = new U64(1,2);
+    $x = new U64(1,2);
+    is $x->getHigh, 1, "  getHigh is 1";
+    is $x->getLow, 2, "  getLow is 2";
+
+    $x = new U64(0xFFFFFFFF,2);
+    is $x->getHigh, 0xFFFFFFFF, "  getHigh is 0xFFFFFFFF";
+    is $x->getLow, 2, "  getLow is 2";
+
+    $x = new U64(7, 0xFFFFFFFF);
+    is $x->getHigh, 7, "  getHigh is 7";
+    is $x->getLow, 0xFFFFFFFF, "  getLow is 0xFFFFFFFF";
+
+    $x = new U64(666);
+    is $x->getHigh, 0, "  getHigh is 0";
+    is $x->getLow, 666, "  getLow is 666";
+
+    title "U64 - add" ;
+
+    $x = new U64(0, 1);
+    is $x->getHigh, 0, "  getHigh is 0";
+    is $x->getLow, 1, "  getLow is 1";
+
+    $x->add(1);
+    is $x->getHigh, 0, "  getHigh is 0";
+    is $x->getLow, 2, "  getLow is 2";
+
+    $x = new U64(0, 0xFFFFFFFE);
+    is $x->getHigh, 0, "  getHigh is 0";
+    is $x->getLow, 0xFFFFFFFE, "  getLow is 0xFFFFFFFE";
+
+    $x->add(1);
+    is $x->getHigh, 0, "  getHigh is 0";
+    is $x->getLow, 0xFFFFFFFF, "  getLow is 0xFFFFFFFF";
+
+    $x->add(1);
+    is $x->getHigh, 1, "  getHigh is 1";
+    is $x->getLow, 0, "  getLow is 0";
+
+    $x->add(1);
+    is $x->getHigh, 1, "  getHigh is 1";
+    is $x->getLow, 1, "  getLow is 1";
+
+    $x = new U64(1, 0xFFFFFFFE);
+    my $y = new U64(2, 3);
+
+    $x->add($y);
+    is $x->getHigh, 4, "  getHigh is 4";
+    is $x->getLow, 1, "  getLow is 1";
+
+    title "U64 - equal" ;
+
+    $x = new U64(0, 1);
+    is $x->getHigh, 0, "  getHigh is 0";
+    is $x->getLow, 1, "  getLow is 1";
+
+    $y = new U64(0, 1);
+    is $x->getHigh, 0, "  getHigh is 0";
+    is $x->getLow, 1, "  getLow is 1";
+
+    my $z = new U64(0, 2);
+    is $x->getHigh, 0, "  getHigh is 0";
+    is $x->getLow, 1, "  getLow is 1";
+
+    ok $x->equal($y), "  equal";
+    ok !$x->equal($z), "  ! equal";
+
+    title "U64 - pack_V" ;
+}
diff -urN perl-5.10.0/ext/IO_Compress_Base/t.xxx/compress/any.pl perl-5.10.0/ext/IO_Compress_Base/t/compress/any.pl
--- perl-5.10.0/ext/IO_Compress_Base/t.xxx/compress/any.pl	1970-01-01 01:00:00.000000000 +0100
+++ perl-5.10.0/ext/IO_Compress_Base/t/compress/any.pl	2008-09-03 15:57:30.000000000 +0200
@@ -0,0 +1,98 @@
+
+use lib 't';
+ 
+use strict;
+use warnings;
+use bytes;
+
+use Test::More ;
+use CompTestUtils;
+
+BEGIN {
+    # use Test::NoWarnings, if available
+    my $extra = 0 ;
+    $extra = 1
+        if eval { require Test::NoWarnings ;  import Test::NoWarnings; 1 };
+
+    plan tests => 48 + $extra ;
+
+}
+
+sub run
+{
+    my $CompressClass   = identify();
+    my $AnyClass        = getClass();
+    my $UncompressClass = getInverse($CompressClass);
+    my $Error           = getErrorRef($CompressClass);
+    my $UnError         = getErrorRef($UncompressClass);
+
+    my $AnyConstruct = "IO::Uncompress::${AnyClass}" ;
+    no strict 'refs';
+    my $AnyError = \${ "IO::Uncompress::${AnyClass}::${AnyClass}Error" };
+
+    for my $trans ( 0, 1 )
+    {
+        for my $file ( 0, 1 )
+        {
+            title "$AnyClass(Transparent => $trans, File=>$file) with $CompressClass" ;
+            my $string = "some text" x 100 ;
+
+            my $buffer ;
+            my $x = new $CompressClass(\$buffer) ;
+            ok $x, "  create $CompressClass object" ;
+            ok $x->write($string), "  write to object" ;
+            ok $x->close, "  close ok" ;
+
+            my $lex = new LexFile my $output;
+            my $input ;
+
+            if ($file) {
+                writeFile($output, $buffer);
+                $input = $output;
+            }
+            else {
+                $input = \$buffer;
+            }
+
+            {
+                my $unc = new $AnyConstruct $input, Transparent => $trans,
+                                           RawInflate => 1,
+                                           Append => 1  ;
+
+                ok $unc, "  Created $AnyClass object" 
+                    or print "# $$AnyError\n";
+                my $uncomp ;
+                1 while  $unc->read($uncomp) > 0 ;
+                #ok $unc->read($uncomp) > 0 
+                #    or print "# $$AnyError\n";
+                my $y;
+                is $unc->read($y, 1), 0, "  at eof" ;
+                ok $unc->eof(), "  at eof" ;
+                #ok $unc->type eq $Type;
+
+                is $uncomp, $string, "  expected output" ;
+            }
+
+            {
+                my $unc = new $AnyConstruct $input, Transparent => $trans,
+                                           RawInflate => 1,
+                                           Append => 1  ;
+
+                ok $unc, "  Created $AnyClass object" 
+                    or print "# $$AnyError\n";
+                my $uncomp ;
+                1 while  $unc->read($uncomp, 100) > 0 ;
+                #ok $unc->read($uncomp) > 0 
+                #    or print "# $$AnyError\n";
+                my $y;
+                is $unc->read($y, 1), 0, "  at eof" ;
+                ok $unc->eof(), "  at eof" ;
+                #ok $unc->type eq $Type;
+
+                is $uncomp, $string, "  expected output" ;
+            }
+        }
+    }
+}
+
+1;
diff -urN perl-5.10.0/ext/IO_Compress_Base/t.xxx/compress/anyunc.pl perl-5.10.0/ext/IO_Compress_Base/t/compress/anyunc.pl
--- perl-5.10.0/ext/IO_Compress_Base/t.xxx/compress/anyunc.pl	1970-01-01 01:00:00.000000000 +0100
+++ perl-5.10.0/ext/IO_Compress_Base/t/compress/anyunc.pl	2008-09-03 15:57:30.000000000 +0200
@@ -0,0 +1,93 @@
+
+use lib 't';
+ 
+use strict;
+use warnings;
+use bytes;
+
+use Test::More ;
+use CompTestUtils;
+
+BEGIN {
+    # use Test::NoWarnings, if available
+    my $extra = 0 ;
+    $extra = 1
+        if eval { require Test::NoWarnings ;  import Test::NoWarnings; 1 };
+
+    plan tests => 36 + $extra ;
+}
+
+sub run
+{
+    my $CompressClass   = identify();
+    my $AnyClass        = getClass();
+    my $UncompressClass = getInverse($CompressClass);
+    my $Error           = getErrorRef($CompressClass);
+    my $UnError         = getErrorRef($UncompressClass);
+
+    my $AnyConstruct = "IO::Uncompress::${AnyClass}" ;
+    no strict refs;
+    my $AnyError = \${ "IO::Uncompress::${AnyClass}::${AnyClass}Error" };
+
+    for my $trans ( 0, 1 )
+    {
+        for my $file ( 0, 1 )
+        {
+            title "$AnyClass(Transparent => $trans, File=>$file) with $CompressClass" ;
+            my $string = "some text" x 100 ;
+
+            my $buffer ;
+            my $x = new $CompressClass(\$buffer) ;
+            ok $x, "  create $CompressClass object" ;
+            ok $x->write($string), "  write to object" ;
+            ok $x->close, "  close ok" ;
+
+            my $lex = new LexFile my $output;
+            my $input ;
+
+            if ($file) {
+                writeFile($output, $buffer);
+                $input = $output;
+            }
+            else {
+                $input = \$buffer;
+            }
+
+            {
+                my $unc = new $AnyConstruct $input, Transparent => $trans
+                                                    Append => 1  ;
+
+                ok $unc, "  Created $AnyClass object" 
+                    or print "# $$AnyError\n";
+                my $uncomp ;
+                1 while $unc->read($uncomp) > 0 ;
+                #ok $unc->read($uncomp) > 0 
+                #    or print "# $$AnyError\n";
+                my $y;
+                is $unc->read($y, 1), 0, "  at eof" ;
+                ok $unc->eof(), "  at eof" ;
+                #ok $unc->type eq $Type;
+
+                is $uncomp, $string, "  expected output" ;
+            }
+
+            {
+                my $unc = new $AnyConstruct $input, Transparent => $trans,
+                                                     Append =>1  ;
+
+                ok $unc, "  Created $AnyClass object" 
+                    or print "# $$AnyError\n";
+                my $uncomp ;
+                1 while $unc->read($uncomp, 10) > 0 ;
+                my $y;
+                is $unc->read($y, 1), 0, "  at eof" ;
+                ok $unc->eof(), "  at eof" ;
+                #ok $unc->type eq $Type;
+
+                is $uncomp, $string, "  expected output" ;
+            }
+        }
+    }
+}
+
+1;
diff -urN perl-5.10.0/ext/IO_Compress_Base/t.xxx/compress/CompTestUtils.pm perl-5.10.0/ext/IO_Compress_Base/t/compress/CompTestUtils.pm
--- perl-5.10.0/ext/IO_Compress_Base/t.xxx/compress/CompTestUtils.pm	1970-01-01 01:00:00.000000000 +0100
+++ perl-5.10.0/ext/IO_Compress_Base/t/compress/CompTestUtils.pm	2008-05-05 14:09:31.000000000 +0200
@@ -0,0 +1,669 @@
+package CompTestUtils;
+
+package main ;
+
+use strict ;
+use warnings;
+use bytes;
+
+#use lib qw(t t/compress);
+
+use Carp ;
+#use Test::More ; 
+
+
+
+sub title
+{
+    #diag "" ; 
+    ok 1, $_[0] ;
+    #diag "" ;
+}
+
+sub like_eval
+{
+    like $@, @_ ;
+}
+
+{
+    package LexFile ;
+
+    our ($index);
+    $index = '00000';
+    
+    sub new
+    {
+        my $self = shift ;
+        foreach (@_)
+        {
+            # autogenerate the name unless if none supplied
+            $_ = "tst" . $index ++ . ".tmp"
+                unless defined $_;
+        }
+        chmod 0777, @_;
+        for (@_) { 1 while unlink $_ } ;
+        bless [ @_ ], $self ;
+    }
+
+    sub DESTROY
+    {
+        my $self = shift ;
+        chmod 0777, @{ $self } ;
+        for (@$self) { 1 while unlink $_ } ;
+    }
+
+}
+
+{
+    package LexDir ;
+
+    use File::Path;
+    sub new
+    {
+        my $self = shift ;
+        foreach (@_) { rmtree $_ }
+        bless [ @_ ], $self ;
+    }
+
+    sub DESTROY
+    {
+        my $self = shift ;
+        foreach (@$self) { rmtree $_ }
+    }
+}
+sub readFile
+{
+    my $f = shift ;
+
+    my @strings ;
+
+    if (IO::Compress::Base::Common::isaFilehandle($f))
+    {
+        my $pos = tell($f);
+        seek($f, 0,0);
+        @strings = <$f> ;	
+        seek($f, 0, $pos);
+    }
+    else
+    {
+        open (F, "<$f") 
+            or croak "Cannot open $f: $!\n" ;
+        binmode F;
+        @strings = <F> ;	
+        close F ;
+    }
+
+    return @strings if wantarray ;
+    return join "", @strings ;
+}
+
+sub touch
+{
+    foreach (@_) { writeFile($_, '') }
+}
+
+sub writeFile
+{
+    my($filename, @strings) = @_ ;
+    1 while unlink $filename ;
+    open (F, ">$filename") 
+        or croak "Cannot open $filename: $!\n" ;
+    binmode F;
+    foreach (@strings) {
+        no warnings ;
+        print F $_ ;
+    }
+    close F ;
+}
+
+sub GZreadFile
+{
+    my ($filename) = shift ;
+
+    my ($uncomp) = "" ;
+    my $line = "" ;
+    my $fil = gzopen($filename, "rb") 
+        or croak "Cannopt open '$filename': $Compress::Zlib::gzerrno" ;
+
+    $uncomp .= $line 
+        while $fil->gzread($line) > 0;
+
+    $fil->gzclose ;
+    return $uncomp ;
+}
+
+sub hexDump
+{
+    my $d = shift ;
+
+    if (IO::Compress::Base::Common::isaFilehandle($d))
+    {
+        $d = readFile($d);
+    }
+    elsif (IO::Compress::Base::Common::isaFilename($d))
+    {
+        $d = readFile($d);
+    }
+    else
+    {
+        $d = $$d ;
+    }
+
+    my $offset = 0 ;
+
+    $d = '' unless defined $d ;
+    #while (read(STDIN, $data, 16)) {
+    while (my $data = substr($d, 0, 16)) {
+        substr($d, 0, 16) = '' ;
+        printf "# %8.8lx    ", $offset;
+        $offset += 16;
+
+        my @array = unpack('C*', $data);
+        foreach (@array) {
+            printf('%2.2x ', $_);
+        }
+        print "   " x (16 - @array)
+            if @array < 16 ;
+        $data =~ tr/\0-\37\177-\377/./;
+        print "  $data\n";
+    }
+
+}
+
+sub readHeaderInfo
+{
+    my $name = shift ;
+    my %opts = @_ ;
+
+    my $string = <<EOM;
+some text
+EOM
+
+    ok my $x = new IO::Compress::Gzip $name, %opts 
+        or diag "GzipError is $IO::Compress::Gzip::GzipError" ;
+    ok $x->write($string) ;
+    ok $x->close ;
+
+    #is GZreadFile($name), $string ;
+
+    ok my $gunz = new IO::Uncompress::Gunzip $name, Strict => 0
+        or diag "GunzipError is $IO::Uncompress::Gunzip::GunzipError" ;
+    ok my $hdr = $gunz->getHeaderInfo();
+    my $uncomp ;
+    ok $gunz->read($uncomp) ;
+    ok $uncomp eq $string;
+    ok $gunz->close ;
+
+    return $hdr ;
+}
+
+sub cmpFile
+{
+    my ($filename, $uue) = @_ ;
+    return readFile($filename) eq unpack("u", $uue) ;
+}
+
+sub isRawFormat
+{
+    my $class = shift;
+    my %raw = map { $_ => 1 } qw( RawDeflate );
+
+    return defined $raw{$class};
+}
+
+sub uncompressBuffer
+{
+    my $compWith = shift ;
+    my $buffer = shift ;
+
+    my %mapping = ( 'IO::Compress::Gzip'                     => 'IO::Uncompress::Gunzip',
+                    'IO::Compress::Gzip::gzip'               => 'IO::Uncompress::Gunzip',
+                    'IO::Compress::Deflate'                  => 'IO::Uncompress::Inflate',
+                    'IO::Compress::Deflate::deflate'         => 'IO::Uncompress::Inflate',
+                    'IO::Compress::RawDeflate'               => 'IO::Uncompress::RawInflate',
+                    'IO::Compress::RawDeflate::rawdeflate'   => 'IO::Uncompress::RawInflate',
+                    'IO::Compress::Bzip2'                    => 'IO::Uncompress::Bunzip2',
+                    'IO::Compress::Bzip2::bzip2'             => 'IO::Uncompress::Bunzip2',
+                    'IO::Compress::Zip'                      => 'IO::Uncompress::Unzip',
+                    'IO::Compress::Zip::zip'                 => 'IO::Uncompress::Unzip',
+                    'IO::Compress::Lzop'                     => 'IO::Uncompress::UnLzop',
+                    'IO::Compress::Lzop::lzop'               => 'IO::Uncompress::UnLzop',
+                    'IO::Compress::Lzf'                      => 'IO::Uncompress::UnLzf' ,
+                    'IO::Compress::Lzf::lzf'                 => 'IO::Uncompress::UnLzf',
+                    'IO::Compress::PPMd'                     => 'IO::Uncompress::UnPPMd' ,
+                    'IO::Compress::PPMd::ppmd'               => 'IO::Uncompress::UnPPMd',
+                    'IO::Compress::DummyComp'                => 'IO::Uncompress::DummyUncomp',
+                    'IO::Compress::DummyComp::dummycomp'     => 'IO::Uncompress::DummyUncomp',
+                );
+
+    my $out ;
+    my $obj = $mapping{$compWith}->new( \$buffer, -Append => 1);
+    1 while $obj->read($out) > 0 ;
+    return $out ;
+
+}
+
+my %ErrorMap = (    'IO::Compress::Gzip'                => \$IO::Compress::Gzip::GzipError,
+                    'IO::Compress::Gzip::gzip'          => \$IO::Compress::Gzip::GzipError,
+                    'IO::Uncompress::Gunzip'            => \$IO::Uncompress::Gunzip::GunzipError,
+                    'IO::Uncompress::Gunzip::gunzip'    => \$IO::Uncompress::Gunzip::GunzipError,
+                    'IO::Uncompress::Inflate'           => \$IO::Uncompress::Inflate::InflateError,
+                    'IO::Uncompress::Inflate::inflate'  => \$IO::Uncompress::Inflate::InflateError,
+                    'IO::Compress::Deflate'             => \$IO::Compress::Deflate::DeflateError,
+                    'IO::Compress::Deflate::deflate'    => \$IO::Compress::Deflate::DeflateError,
+                    'IO::Uncompress::RawInflate'        => \$IO::Uncompress::RawInflate::RawInflateError,
+                    'IO::Uncompress::RawInflate::rawinflate'  => \$IO::Uncompress::RawInflate::RawInflateError,
+                    'IO::Uncompress::AnyInflate'        => \$IO::Uncompress::AnyInflate::AnyInflateError,
+                    'IO::Uncompress::AnyInflate::anyinflate'  => \$IO::Uncompress::AnyInflate::AnyInflateError,
+                    'IO::Uncompress::AnyUncompress'        => \$IO::Uncompress::AnyUncompress::AnyUncompressError,
+                    'IO::Uncompress::AnyUncompress::anyUncompress'  => \$IO::Uncompress::AnyUncompress::AnyUncompressError,
+                    'IO::Compress::RawDeflate'          => \$IO::Compress::RawDeflate::RawDeflateError,
+                    'IO::Compress::RawDeflate::rawdeflate'  => \$IO::Compress::RawDeflate::RawDeflateError,
+                    'IO::Compress::Bzip2'               => \$IO::Compress::Bzip2::Bzip2Error,
+                    'IO::Compress::Bzip2::bzip2'        => \$IO::Compress::Bzip2::Bzip2Error,
+                    'IO::Uncompress::Bunzip2'           => \$IO::Uncompress::Bunzip2::Bunzip2Error,
+                    'IO::Uncompress::Bunzip2::bunzip2'  => \$IO::Uncompress::Bunzip2::Bunzip2Error,
+                    'IO::Compress::Zip'                 => \$IO::Compress::Zip::ZipError,
+                    'IO::Compress::Zip::zip'            => \$IO::Compress::Zip::ZipError,
+                    'IO::Uncompress::Unzip'             => \$IO::Uncompress::Unzip::UnzipError,
+                    'IO::Uncompress::Unzip::unzip'      => \$IO::Uncompress::Unzip::UnzipError,
+                    'IO::Compress::Lzop'                => \$IO::Compress::Lzop::LzopError,
+                    'IO::Compress::Lzop::lzop'          => \$IO::Compress::Lzop::LzopError,
+                    'IO::Uncompress::UnLzop'            => \$IO::Uncompress::UnLzop::UnLzopError,
+                    'IO::Uncompress::UnLzop::unlzop'    => \$IO::Uncompress::UnLzop::UnLzopError,
+                    'IO::Compress::Lzf'                 => \$IO::Compress::Lzf::LzfError,
+                    'IO::Compress::Lzf::lzf'            => \$IO::Compress::Lzf::LzfError,
+                    'IO::Uncompress::UnLzf'             => \$IO::Uncompress::UnLzf::UnLzfError,
+                    'IO::Uncompress::UnLzf::unlzf'      => \$IO::Uncompress::UnLzf::UnLzfError,
+                    'IO::Compress::PPMd'                 => \$IO::Compress::PPMd::PPMdError,
+                    'IO::Compress::PPMd::ppmd'            => \$IO::Compress::PPMd::PPMdError,
+                    'IO::Uncompress::UnPPMd'             => \$IO::Uncompress::UnPPMd::UnPPMdError,
+                    'IO::Uncompress::UnPPMd::unppmd'      => \$IO::Uncompress::UnPPMd::UnPPMdError,
+
+                    'IO::Compress::DummyComp'           => \$IO::Compress::DummyComp::DummyCompError,
+                    'IO::Compress::DummyComp::dummycomp'=> \$IO::Compress::DummyComp::DummyCompError,
+                    'IO::Uncompress::DummyUncomp'       => \$IO::Uncompress::DummyUncomp::DummyUncompError,
+                    'IO::Uncompress::DummyUncomp::dummyuncomp' => \$IO::Uncompress::DummyUncomp::DummyUncompError,
+               );
+
+my %TopFuncMap = (  'IO::Compress::Gzip'          => 'IO::Compress::Gzip::gzip',
+                    'IO::Uncompress::Gunzip'      => 'IO::Uncompress::Gunzip::gunzip',
+
+                    'IO::Compress::Deflate'       => 'IO::Compress::Deflate::deflate',
+                    'IO::Uncompress::Inflate'     => 'IO::Uncompress::Inflate::inflate',
+
+                    'IO::Compress::RawDeflate'    => 'IO::Compress::RawDeflate::rawdeflate',
+                    'IO::Uncompress::RawInflate'  => 'IO::Uncompress::RawInflate::rawinflate',
+
+                    'IO::Uncompress::AnyInflate'  => 'IO::Uncompress::AnyInflate::anyinflate',
+                    'IO::Uncompress::AnyUncompress'  => 'IO::Uncompress::AnyUncompress::anyuncompress',
+
+                    'IO::Compress::Bzip2'         => 'IO::Compress::Bzip2::bzip2',
+                    'IO::Uncompress::Bunzip2'     => 'IO::Uncompress::Bunzip2::bunzip2',
+
+                    'IO::Compress::Zip'           => 'IO::Compress::Zip::zip',
+                    'IO::Uncompress::Unzip'       => 'IO::Uncompress::Unzip::unzip',
+                    'IO::Compress::Lzop'          => 'IO::Compress::Lzop::lzop',
+                    'IO::Uncompress::UnLzop'      => 'IO::Uncompress::UnLzop::unlzop',
+                    'IO::Compress::Lzf'           => 'IO::Compress::Lzf::lzf',
+                    'IO::Uncompress::UnLzf'       => 'IO::Uncompress::UnLzf::unlzf',
+                    'IO::Compress::PPMd'           => 'IO::Compress::PPMd::ppmd',
+                    'IO::Uncompress::UnPPMd'       => 'IO::Uncompress::UnPPMd::unppmd',
+                    'IO::Compress::DummyComp'     => 'IO::Compress::DummyComp::dummyuncomp',
+                    'IO::Uncompress::DummyUncomp' => 'IO::Uncompress::DummyUncomp::dummyuncomp',
+                 );
+
+   %TopFuncMap = map { ($_              => $TopFuncMap{$_}, 
+                        $TopFuncMap{$_} => $TopFuncMap{$_}) } 
+                 keys %TopFuncMap ;
+
+ #%TopFuncMap = map { ($_              => \&{ $TopFuncMap{$_} ) } 
+                 #keys %TopFuncMap ;
+
+
+my %inverse  = ( 'IO::Compress::Gzip'                    => 'IO::Uncompress::Gunzip',
+                 'IO::Compress::Gzip::gzip'              => 'IO::Uncompress::Gunzip::gunzip',
+                 'IO::Compress::Deflate'                 => 'IO::Uncompress::Inflate',
+                 'IO::Compress::Deflate::deflate'        => 'IO::Uncompress::Inflate::inflate',
+                 'IO::Compress::RawDeflate'              => 'IO::Uncompress::RawInflate',
+                 'IO::Compress::RawDeflate::rawdeflate'  => 'IO::Uncompress::RawInflate::rawinflate',
+                 'IO::Compress::Bzip2::bzip2'            => 'IO::Uncompress::Bunzip2::bunzip2',
+                 'IO::Compress::Bzip2'                   => 'IO::Uncompress::Bunzip2',
+                 'IO::Compress::Zip::zip'                => 'IO::Uncompress::Unzip::unzip',
+                 'IO::Compress::Zip'                     => 'IO::Uncompress::Unzip',
+                 'IO::Compress::Lzop::lzop'              => 'IO::Uncompress::UnLzop::unlzop',
+                 'IO::Compress::Lzop'                    => 'IO::Uncompress::UnLzop',
+                 'IO::Compress::Lzf::lzf'                => 'IO::Uncompress::UnLzf::unlzf',
+                 'IO::Compress::Lzf'                     => 'IO::Uncompress::UnLzf',
+                 'IO::Compress::PPMd::ppmd'              => 'IO::Uncompress::UnPPMd::unppmd',
+                 'IO::Compress::PPMd'                    => 'IO::Uncompress::UnPPMd',
+                 'IO::Compress::DummyComp::dummycomp'    => 'IO::Uncompress::DummyUncomp::dummyuncomp',
+                 'IO::Compress::DummyComp'               => 'IO::Uncompress::DummyUncomp',
+             );
+
+%inverse  = map { ($_ => $inverse{$_}, $inverse{$_} => $_) } keys %inverse;
+
+sub getInverse
+{
+    my $class = shift ;
+
+    return $inverse{$class} ;
+}
+
+sub getErrorRef
+{
+    my $class = shift ;
+
+    return $ErrorMap{$class} ;
+}
+
+sub getTopFuncRef
+{
+    my $class = shift ;
+
+    return \&{ $TopFuncMap{$class} } ;
+}
+
+sub getTopFuncName
+{
+    my $class = shift ;
+
+    return $TopFuncMap{$class}  ;
+}
+
+sub compressBuffer
+{
+    my $compWith = shift ;
+    my $buffer = shift ;
+
+    my %mapping = ( 'IO::Uncompress::Gunzip'                  => 'IO::Compress::Gzip',
+                    'IO::Uncompress::Gunzip::gunzip'          => 'IO::Compress::Gzip',
+                    'IO::Uncompress::Inflate'                 => 'IO::Compress::Deflate',
+                    'IO::Uncompress::Inflate::inflate'        => 'IO::Compress::Deflate',
+                    'IO::Uncompress::RawInflate'              => 'IO::Compress::RawDeflate',
+                    'IO::Uncompress::RawInflate::rawinflate'  => 'IO::Compress::RawDeflate',
+                    'IO::Uncompress::Bunzip2'                 => 'IO::Compress::Bzip2',
+                    'IO::Uncompress::Bunzip2::bunzip2'        => 'IO::Compress::Bzip2',
+                    'IO::Uncompress::Unzip'                   => 'IO::Compress::Zip',
+                    'IO::Uncompress::Unzip::unzip'            => 'IO::Compress::Zip',
+                    'IO::Uncompress::UnLzop'                  => 'IO::Compress::Lzop',
+                    'IO::Uncompress::UnLzop::unlzop'          => 'IO::Compress::Lzop',
+                    'IO::Uncompress::UnLzp'                   => 'IO::Compress::Lzf',
+                    'IO::Uncompress::UnLzf::unlzf'            => 'IO::Compress::Lzf',
+                    'IO::Uncompress::UnPPMd'                  => 'IO::Compress::PPMd',
+                    'IO::Uncompress::UnPPMd::unppmd'          => 'IO::Compress::PPMd',
+                    'IO::Uncompress::AnyInflate'              => 'IO::Compress::Gzip',
+                    'IO::Uncompress::AnyInflate::anyinflate'  => 'IO::Compress::Gzip',
+                    'IO::Uncompress::AnyUncompress'           => 'IO::Compress::Gzip',
+                    'IO::Uncompress::AnyUncompress::anyuncompress'  => 'IO::Compress::Gzip',
+                    'IO::Uncompress::DummyUncomp'             => 'IO::Compress::DummyComp',
+                    'IO::Uncompress::DummyUncomp::dummyuncomp'=> 'IO::Compress::DummyComp',
+                );
+
+    my $out ;
+    my $obj = $mapping{$compWith}->new( \$out);
+    $obj->write($buffer) ;
+    $obj->close();
+    return $out ;
+}
+
+our ($AnyUncompressError);
+BEGIN
+{
+    eval ' use IO::Uncompress::AnyUncompress qw($AnyUncompressError); ';
+}
+
+sub anyUncompress
+{
+    my $buffer = shift ;
+    my $already = shift;
+
+    my @opts = ();
+    if (ref $buffer && ref $buffer eq 'ARRAY')
+    {
+        @opts = @$buffer;
+        $buffer = shift @opts;
+    }
+
+    if (ref $buffer)
+    {
+        croak "buffer is undef" unless defined $$buffer;
+        croak "buffer is empty" unless length $$buffer;
+
+    }
+
+
+    my $data ;
+    if (IO::Compress::Base::Common::isaFilehandle($buffer))
+    {
+        $data = readFile($buffer);
+    }
+    elsif (IO::Compress::Base::Common::isaFilename($buffer))
+    {
+        $data = readFile($buffer);
+    }
+    else
+    {
+        $data = $$buffer ;
+    }
+
+    if (defined $already && length $already)
+    {
+
+        my $got = substr($data, 0, length($already));
+        substr($data, 0, length($already)) = '';
+
+        is $got, $already, '  Already OK' ;
+    }
+
+    my $out = '';
+    my $o = new IO::Uncompress::AnyUncompress \$data, 
+                    Append => 1, 
+                    Transparent => 0, 
+                    RawInflate => 1,
+                    @opts
+        or croak "Cannot open buffer/file: $AnyUncompressError" ;
+
+    1 while $o->read($out) > 0 ;
+
+    croak "Error uncompressing -- " . $o->error()
+        if $o->error() ;
+
+    return $out ;
+
+}
+
+sub getHeaders
+{
+    my $buffer = shift ;
+    my $already = shift;
+
+    my @opts = ();
+    if (ref $buffer && ref $buffer eq 'ARRAY')
+    {
+        @opts = @$buffer;
+        $buffer = shift @opts;
+    }
+
+    if (ref $buffer)
+    {
+        croak "buffer is undef" unless defined $$buffer;
+        croak "buffer is empty" unless length $$buffer;
+
+    }
+
+
+    my $data ;
+    if (IO::Compress::Base::Common::isaFilehandle($buffer))
+    {
+        $data = readFile($buffer);
+    }
+    elsif (IO::Compress::Base::Common::isaFilename($buffer))
+    {
+        $data = readFile($buffer);
+    }
+    else
+    {
+        $data = $$buffer ;
+    }
+
+    if (defined $already && length $already)
+    {
+
+        my $got = substr($data, 0, length($already));
+        substr($data, 0, length($already)) = '';
+
+        is $got, $already, '  Already OK' ;
+    }
+
+    my $out = '';
+    my $o = new IO::Uncompress::AnyUncompress \$data, 
+                MultiStream => 1, 
+                Append => 1, 
+                Transparent => 0, 
+                RawInflate => 1,
+                @opts
+        or croak "Cannot open buffer/file: $AnyUncompressError" ;
+
+    1 while $o->read($out) > 0 ;
+
+    croak "Error uncompressing -- " . $o->error()
+        if $o->error() ;
+
+    return ($o->getHeaderInfo()) ;
+
+}
+
+sub mkComplete
+{
+    my $class = shift ;
+    my $data = shift;
+    my $Error = getErrorRef($class);
+
+    my $buffer ;
+    my %params = ();
+
+    if ($class eq 'IO::Compress::Gzip') {
+        %params = (
+            Name       => "My name",
+            Comment    => "a comment",
+            ExtraField => ['ab' => "extra"],
+            HeaderCRC  => 1);
+    }
+    elsif ($class eq 'IO::Compress::Zip'){
+        %params = (
+            Name              => "My name",
+            Comment           => "a comment",
+            ZipComment        => "last comment",
+            exTime            => [100, 200, 300],
+            ExtraFieldLocal   => ["ab" => "extra1"],
+            ExtraFieldCentral => ["cd" => "extra2"],
+        );
+    }
+
+    my $z = new $class( \$buffer, %params)
+        or croak "Cannot create $class object: $$Error";
+    $z->write($data);
+    $z->close();
+
+    my $unc = getInverse($class);
+    anyUncompress(\$buffer) eq $data
+        or die "bad bad bad";
+    my $u = new $unc( \$buffer);
+    my $info = $u->getHeaderInfo() ;
+
+
+    return wantarray ? ($info, $buffer) : $buffer ;
+}
+
+sub mkErr
+{
+    my $string = shift ;
+    my ($dummy, $file, $line) = caller ;
+    -- $line ;
+
+    $file = quotemeta($file);
+
+    return "/$string\\s+at $file line $line/" if $] >= 5.006 ;
+    return "/$string\\s+at /" ;
+}
+
+sub mkEvalErr
+{
+    my $string = shift ;
+
+    return "/$string\\s+at \\(eval /" if $] > 5.006 ;
+    return "/$string\\s+at /" ;
+}
+
+sub dumpObj
+{
+    my $obj = shift ;
+
+    my ($dummy, $file, $line) = caller ;
+
+    if (@_)
+    {
+        print "#\n# dumpOBJ from $file line $line @_\n" ;
+    }
+    else
+    {
+        print "#\n# dumpOBJ from $file line $line \n" ;
+    }
+
+    my $max = 0 ;;
+    foreach my $k (keys %{ *$obj })
+    {
+        $max = length $k if length $k > $max ;
+    }
+
+    foreach my $k (sort keys %{ *$obj })
+    {
+        my $v = $obj->{$k} ;
+        $v = '-undef-' unless defined $v;
+        my $pad = ' ' x ($max - length($k) + 2) ;
+        print "# $k$pad: [$v]\n";
+    }
+    print "#\n" ;
+}
+
+
+sub getMultiValues
+{
+    my $class = shift ;
+
+    return (0,0) if $class =~ /lzf/i;
+    return (1,0);
+}
+
+
+sub gotScalarUtilXS
+{
+    eval ' use Scalar::Util "dualvar" ';
+    return $@ ? 0 : 1 ;
+}
+
+package CompTestUtils;
+
+1;
+__END__
+	t/Test/Builder.pm
+	t/Test/More.pm
+	t/Test/Simple.pm
+	t/compress/CompTestUtils.pm
+	t/compress/any.pl
+	t/compress/anyunc.pl
+	t/compress/destroy.pl
+	t/compress/generic.pl
+	t/compress/merge.pl
+	t/compress/multi.pl
+	t/compress/newtied.pl
+	t/compress/oneshot.pl
+	t/compress/prime.pl
+	t/compress/tied.pl
+	t/compress/truncate.pl
+	t/compress/zlib-generic.plParsing config.in...
+Building Zlib enabled
+Auto Detect Gzip OS Code..
+Setting Gzip OS Code to 3 [Unix/Default]
+Looks Good.
diff -urN perl-5.10.0/ext/IO_Compress_Base/t.xxx/compress/destroy.pl perl-5.10.0/ext/IO_Compress_Base/t/compress/destroy.pl
--- perl-5.10.0/ext/IO_Compress_Base/t.xxx/compress/destroy.pl	1970-01-01 01:00:00.000000000 +0100
+++ perl-5.10.0/ext/IO_Compress_Base/t/compress/destroy.pl	2008-09-03 15:57:30.000000000 +0200
@@ -0,0 +1,115 @@
+
+use lib 't';
+use strict;
+use warnings;
+use bytes;
+
+use Test::More ;
+use CompTestUtils;
+
+BEGIN
+{
+    plan(skip_all => "Destroy not supported in Perl $]")
+        if $] == 5.008 || ( $] >= 5.005 && $] < 5.006) ;
+
+    # use Test::NoWarnings, if available
+    my $extra = 0 ;
+    $extra = 1
+        if eval { require Test::NoWarnings ;  import Test::NoWarnings; 1 };
+
+    plan tests => 15 + $extra ;
+
+    use_ok('IO::File') ;
+}
+
+sub run
+{
+
+    my $CompressClass   = identify();
+    my $UncompressClass = getInverse($CompressClass);
+    my $Error           = getErrorRef($CompressClass);
+    my $UnError         = getErrorRef($UncompressClass);
+
+    title "Testing $CompressClass";
+
+    {
+        # Check that the class destructor will call close
+
+        my $lex = new LexFile my $name ;
+
+        my $hello = <<EOM ;
+hello world
+this is a test
+EOM
+
+
+        {
+          ok my $x = new $CompressClass $name, -AutoClose => 1  ;
+
+          ok $x->write($hello) ;
+        }
+
+        is anyUncompress($name), $hello ;
+    }
+
+    {
+        # Tied filehandle destructor
+
+
+        my $lex = new LexFile my $name ;
+
+        my $hello = <<EOM ;
+hello world
+this is a test
+EOM
+
+        my $fh = new IO::File "> $name" ;
+
+        {
+          ok my $x = new $CompressClass $fh, -AutoClose => 1  ;
+
+          $x->write($hello) ;
+        }
+
+        ok anyUncompress($name) eq $hello ;
+    }
+    
+    {
+        title "Testing DESTROY doesn't clobber \$! etc ";
+
+        my $lex = new LexFile my $name ;
+
+        my $out;
+        my $result;
+        
+        {
+            ok my $z = new $CompressClass($name); 
+            $z->write("abc") ;
+            $! = 22 ;
+
+            cmp_ok $!, '==', 22, '  $! is 22';
+        }
+        
+        cmp_ok $!, '==', 22, "  \$! has not been changed by $CompressClass destructor";
+
+                
+        {
+                my $uncomp;
+                ok my $x = new $UncompressClass($name, -Append => 1)  ;
+                
+                my $len ;
+                1 while ($len = $x->read($result)) > 0 ;
+                
+                $! = 22 ;
+
+                cmp_ok $!, '==', 22, '  $! is 22';
+        }    
+           
+        cmp_ok $!, '==', 22, "  \$! has not been changed by $UncompressClass destructor";
+                
+        is $result, "abc", "  Got uncompressed content ok";
+ 
+    }
+}
+
+1;
diff -urN perl-5.10.0/ext/IO_Compress_Base/t.xxx/compress/generic.pl perl-5.10.0/ext/IO_Compress_Base/t/compress/generic.pl
--- perl-5.10.0/ext/IO_Compress_Base/t.xxx/compress/generic.pl	1970-01-01 01:00:00.000000000 +0100
+++ perl-5.10.0/ext/IO_Compress_Base/t/compress/generic.pl	2008-09-03 15:57:30.000000000 +0200
@@ -0,0 +1,1603 @@
+
+use strict;
+use warnings;
+use bytes;
+
+use Test::More ;
+use CompTestUtils;
+
+use IO::Handle qw(SEEK_SET SEEK_CUR SEEK_END);
+
+our ($UncompressClass);
+BEGIN 
+{ 
+    # use Test::NoWarnings, if available
+    my $extra = 0 ;
+
+    my $st = eval { require Test::NoWarnings ;  import Test::NoWarnings; 1; };
+    $extra = 1
+        if $st ;
+
+    plan(tests => 670 + $extra) ;
+}
+
+sub myGZreadFile
+{
+    my $filename = shift ;
+    my $init = shift ;
+
+
+    my $fil = new $UncompressClass $filename,
+                                    -Strict   => 0,
+                                    -Append   => 1
+                                    ;
+
+    my $data = '';
+    $data = $init if defined $init ;
+    1 while $fil->read($data) > 0;
+
+    $fil->close ;
+    return $data ;
+}
+
+sub run
+{
+    my $CompressClass   = identify();
+    $UncompressClass = getInverse($CompressClass);
+    my $Error           = getErrorRef($CompressClass);
+    my $UnError         = getErrorRef($UncompressClass);
+
+    if(1)
+    {
+
+        title "Testing $CompressClass Errors";
+
+        # Buffer not writable
+        eval qq[\$a = new $CompressClass(\\1) ;] ;
+        like $@, mkEvalErr("^$CompressClass: output buffer is read-only") ;
+            
+        my($out, $gz);
+        $out = "" ;
+        eval qq[\$a = new $CompressClass ] . '$out ;' ;
+        like $@, mkEvalErr("^$CompressClass: output filename is undef or null string");
+            
+        $out = undef ;
+        eval qq[\$a = new $CompressClass \$out ;] ;
+        like $@, mkEvalErr("^$CompressClass: output filename is undef or null string");
+            
+        my $x ;
+        $gz = new $CompressClass(\$x); 
+
+        foreach my $name (qw(read readline getc))
+        {
+            eval " \$gz->$name() " ;
+            like $@, mkEvalErr("^$name Not Available: File opened only for output");
+        }
+
+        eval ' $gz->write({})' ;
+        like $@, mkEvalErr("^${CompressClass}::write: not a scalar reference");
+        #like $@, mkEvalErr("^${CompressClass}::write: input parameter not a filename, filehandle, array ref or scalar ref");
+
+        eval ' $gz->syswrite("abc", 1, 5)' ;
+        like $@, mkEvalErr("^${CompressClass}::write: offset outside string");
+
+        eval ' $gz->syswrite("abc", 1, -4)' ;
+        like $@, mkEvalErr("^${CompressClass}::write: offset outside string"), "write outside string";
+    }
+
+
+    {
+        title "Testing $UncompressClass Errors";
+
+        my $out = "" ;
+        eval qq[\$a = new $UncompressClass \$out ;] ;
+        like $@, mkEvalErr("^$UncompressClass: input filename is undef or null string");
+        $out = undef ;
+        eval qq[\$a = new $UncompressClass \$out ;] ;
+        like $@, mkEvalErr("^$UncompressClass: input filename is undef or null string");
+
+        my $lex = new LexFile my $name ;
+
+        ok ! -e $name, "  $name does not exist";
+        
+        eval qq[\$a = new $UncompressClass "$name" ;] ;
+        is $$UnError, "input file '$name' does not exist";
+
+        my $gc ;
+        my $guz = new $CompressClass(\$gc); 
+        $guz->write("abc") ;
+        $guz->close();
+
+        my $x ;
+        my $gz = new $UncompressClass(\$gc); 
+
+        foreach my $name (qw(print printf write))
+        {
+            eval " \$gz->$name() " ;
+            like $@, mkEvalErr("^$name Not Available: File opened only for intput");
+        }
+
+    }
+
+
+    {
+        title "Testing $CompressClass and $UncompressClass";
+
+        {
+            my ($a, $x, @x) = ("","","") ;
+
+            # Buffer not a scalar reference
+            eval qq[\$a = new $CompressClass \\\@x ;] ;
+            like $@, mkEvalErr("^$CompressClass: output parameter not a filename, filehandle or scalar ref");
+                
+            # Buffer not a scalar reference
+            eval qq[\$a = new $UncompressClass \\\@x ;] ;
+            like $@, mkEvalErr("^$UncompressClass: input parameter not a filename, filehandle, array ref or scalar ref");
+        }
+            
+        foreach my $Type ( $CompressClass, $UncompressClass)
+        {
+            # Check error handling with IO::Compress::Deflate and IO::Uncompress::Inflate
+
+            my ($a, $x, @x) = ("","","") ;
+
+            # Odd number of parameters
+            eval qq[\$a = new $Type "abc", -Output ] ;
+            like $@, mkEvalErr("^$Type: Expected even number of parameters, got 1");
+
+            # Unknown parameter
+            eval qq[\$a = new $Type  "anc", -Fred => 123 ;] ;
+            like $@, mkEvalErr("^$Type: unknown key value\\(s\\) Fred");
+
+            # no in or out param
+            eval qq[\$a = new $Type ;] ;
+            like $@, mkEvalErr("^$Type: Missing (Input|Output) parameter");
+
+        }    
+
+
+        {
+            # write a very simple compressed file 
+            # and read back 
+            #========================================
+
+
+            my $lex = new LexFile my $name ;
+
+            my $hello = <<EOM ;
+hello world
+this is a test
+EOM
+
+            {
+              my $x ;
+              ok $x = new $CompressClass $name  ;
+              is $x->autoflush(1), 0, "autoflush";
+              is $x->autoflush(1), 1, "autoflush";
+              ok $x->opened(), "opened";
+
+              ok $x->write($hello), "write" ;
+              ok $x->flush(), "flush";
+              ok $x->close, "close" ;
+              ok ! $x->opened(), "! opened";
+            }
+
+            {
+              my $uncomp;
+              ok my $x = new $UncompressClass $name, -Append => 1  ;
+              ok $x->opened(), "opened";
+
+              my $len ;
+              1 while ($len = $x->read($uncomp)) > 0 ;
+
+              is $len, 0, "read returned 0"
+                or diag $$UnError ;
+
+              ok $x->close ;
+              is $uncomp, $hello ;
+              ok !$x->opened(), "! opened";
+            }
+        }
+
+        {
+            # write a very simple compressed file 
+            # and read back 
+            #========================================
+
+
+            my $lex = new LexFile my $name ;
+
+            my $hello = <<EOM ;
+hello world
+this is a test
+EOM
+
+            {
+              my $x ;
+              ok $x = new $CompressClass $name  ;
+
+              is $x->write(''), 0, "Write empty string is ok";
+              is $x->write(undef), 0, "Write undef is ok";
+              ok $x->write($hello), "Write ok" ;
+              ok $x->close, "Close ok" ;
+            }
+
+            {
+              my $uncomp;
+              my $x = new $UncompressClass $name  ;
+              ok $x, "creates $UncompressClass $name"  ;
+
+              my $data = '';
+              $data .= $uncomp while $x->read($uncomp) > 0 ;
+
+              ok $x->close, "close ok" ;
+              is $data, $hello, "expected output" ;
+            }
+        }
+
+
+        {
+            # write a very simple file with using an IO filehandle
+            # and read back 
+            #========================================
+
+
+            my $lex = new LexFile my $name ;
+
+            my $hello = <<EOM ;
+hello world
+this is a test
+EOM
+
+            {
+              my $fh = new IO::File ">$name" ;
+              ok $fh, "opened file $name ok";
+              my $x = new $CompressClass $fh  ;
+              ok $x, " created $CompressClass $fh"  ;
+
+              is $x->fileno(), fileno($fh), "fileno match" ;
+              is $x->write(''), 0, "Write empty string is ok";
+              is $x->write(undef), 0, "Write undef is ok";
+              ok $x->write($hello), "write ok" ;
+              ok $x->flush(), "flush";
+              ok $x->close,"close" ;
+              $fh->close() ;
+            }
+
+            my $uncomp;
+            {
+              my $x ;
+              ok my $fh1 = new IO::File "<$name" ;
+              ok $x = new $UncompressClass $fh1, -Append => 1  ;
+              ok $x->fileno() == fileno $fh1 ;
+
+              1 while $x->read($uncomp) > 0 ;
+
+              ok $x->close ;
+            }
+
+            ok $hello eq $uncomp ;
+        }
+
+        {
+            # write a very simple file with using a glob filehandle
+            # and read back 
+            #========================================
+
+
+            my $lex = new LexFile my $name ;
+            #my $name  = "/tmp/fred";
+
+            my $hello = <<EOM ;
+hello world
+this is a test
+EOM
+
+            {
+              title "$CompressClass: Input from typeglob filehandle";  
+              ok open FH, ">$name" ;
+     
+              my $x = new $CompressClass *FH  ;
+              ok $x, "  create $CompressClass"  ;
+
+              is $x->fileno(), fileno(*FH), "  fileno" ;
+              is $x->write(''), 0, "  Write empty string is ok";
+              is $x->write(undef), 0, "  Write undef is ok";
+              ok $x->write($hello), "  Write ok" ;
+              ok $x->flush(), "  Flush";
+              ok $x->close, "  Close" ;
+              close FH;
+            }
+
+
+            my $uncomp;
+            {
+              title "$UncompressClass: Input from typeglob filehandle, append output";  
+              my $x ;
+              ok open FH, "<$name" ;
+              ok $x = new $UncompressClass *FH, -Append => 1, Transparent => 0
+                or diag $$UnError ;
+              is $x->fileno(), fileno FH, "  fileno ok" ;
+
+              1 while $x->read($uncomp) > 0 ;
+
+              ok $x->close, "  close" ;
+            }
+
+            is $uncomp, $hello, "  expected output" ;
+        }
+
+        {
+            my $lex = new LexFile my $name ;
+            #my $name = "/tmp/fred";
+
+            my $hello = <<EOM ;
+hello world
+this is a test
+EOM
+
+            {
+              title "Outout to stdout via '-'" ;
+
+              open(SAVEOUT, ">&STDOUT");
+              my $dummy = fileno SAVEOUT;
+              open STDOUT, ">$name" ;
+     
+              my $x = new $CompressClass '-'  ;
+              $x->write($hello);
+              $x->close;
+
+              open(STDOUT, ">&SAVEOUT");
+
+              ok 1, "  wrote to stdout" ;
+            }
+            is myGZreadFile($name), $hello, "  wrote OK";
+            #hexDump($name);
+
+            {
+              title "Input from stdin via filename '-'";  
+
+              my $x ;
+              my $uncomp ;
+              my $stdinFileno = fileno(STDIN);
+              # open below doesn't return 1 sometines on XP
+                 open(SAVEIN, "<&STDIN");
+              ok open(STDIN, "<$name"), "  redirect STDIN";
+              my $dummy = fileno SAVEIN;
+              $x = new $UncompressClass '-', Append => 1, Transparent => 0
+                    or diag $$UnError ;
+              ok $x, "  created object" ;
+              is $x->fileno(), $stdinFileno, "  fileno ok" ;
+
+              1 while $x->read($uncomp) > 0 ;
+
+              ok $x->close, "  close" ;
+                 open(STDIN, "<&SAVEIN");
+              is $uncomp, $hello, "  expected output" ;
+            }
+        }
+
+        {
+            # write a compressed file to memory 
+            # and read back 
+            #========================================
+
+            #my $name = "test.gz" ;
+            my $lex = new LexFile my $name ;
+
+            my $hello = <<EOM ;
+hello world
+this is a test
+EOM
+
+            my $buffer ;
+            {
+              my $x ;
+              ok $x = new $CompressClass(\$buffer) ;
+          
+              ok ! defined $x->autoflush(1) ;
+              ok ! defined $x->autoflush(1) ;
+              ok ! defined $x->fileno() ;
+              is $x->write(''), 0, "Write empty string is ok";
+              is $x->write(undef), 0, "Write undef is ok";
+              ok $x->write($hello) ;
+              ok $x->flush();
+              ok $x->close ;
+          
+              writeFile($name, $buffer) ;
+              #is anyUncompress(\$buffer), $hello, "  any ok";
+            }
+
+            my $keep = $buffer ;
+            my $uncomp;
+            {
+              my $x ;
+              ok $x = new $UncompressClass(\$buffer, Append => 1)  ;
+
+              ok ! defined $x->autoflush(1) ;
+              ok ! defined $x->autoflush(1) ;
+              ok ! defined $x->fileno() ;
+              1 while $x->read($uncomp) > 0  ;
+
+              ok $x->close, "closed" ;
+            }
+
+            is $uncomp, $hello, "got expected uncompressed data" ;
+            ok $buffer eq $keep, "compressed input not changed" ;
+        }
+
+        if ($CompressClass ne 'RawDeflate')
+        {
+            # write empty file
+            #========================================
+
+            my $buffer = '';
+            {
+              my $x ;
+              $x = new $CompressClass(\$buffer);
+              ok $x, "new $CompressClass" ;
+              ok $x->close, "close ok" ;
+          
+            }
+
+            my $keep = $buffer ;
+            my $uncomp= '';
+            {
+              my $x ;
+              ok $x = new $UncompressClass(\$buffer, Append => 1)  ;
+
+              1 while $x->read($uncomp) > 0  ;
+
+              ok $x->close ;
+            }
+
+            ok $uncomp eq '' ;
+            ok $buffer eq $keep ;
+
+        }
+
+        {
+            # write a larger file
+            #========================================
+
+
+            my $lex = new LexFile my $name ;
+
+            my $hello = <<EOM ;
+hello world
+this is a test
+EOM
+
+            my $input    = '' ;
+            my $contents = '' ;
+
+            {
+              my $x = new $CompressClass $name  ;
+              ok $x, "  created $CompressClass object";
+
+              ok $x->write($hello), "  write ok" ;
+              $input .= $hello ;
+              ok $x->write("another line"), "  write ok" ;
+              $input .= "another line" ;
+              # all characters
+              foreach (0 .. 255)
+                { $contents .= chr int $_ }
+              # generate a long random string
+              foreach (1 .. 5000)
+                { $contents .= chr int rand 256 }
+
+              ok $x->write($contents), "  write ok" ;
+              $input .= $contents ;
+              ok $x->close, "  close ok" ;
+            }
+
+            ok myGZreadFile($name) eq $input ;
+            my $x =  readFile($name) ;
+            #print "length " . length($x) . " \n";
+        }
+
+        {
+            # embed a compressed file in another file
+            #================================
+
+
+            my $lex = new LexFile my $name ;
+
+            my $hello = <<EOM ;
+hello world
+this is a test
+EOM
+
+            my $header = "header info\n" ;
+            my $trailer = "trailer data\n" ;
+
+            {
+              my $fh ;
+              ok $fh = new IO::File ">$name" ;
+              print $fh $header ;
+              my $x ;
+              ok $x = new $CompressClass $fh,
+                                         -AutoClose => 0   ;
+
+              ok $x->binmode();
+              ok $x->write($hello) ;
+              ok $x->close ;
+              print $fh $trailer ;
+              $fh->close() ;
+            }
+
+            my ($fil, $uncomp) ;
+            my $fh1 ;
+            ok $fh1 = new IO::File "<$name" ;
+            # skip leading junk
+            my $line = <$fh1> ;
+            ok $line eq $header ;
+
+            ok my $x = new $UncompressClass $fh1, Append => 1  ;
+            ok $x->binmode();
+            1 while $x->read($uncomp) > 0 ;
+
+            ok $uncomp eq $hello ;
+            my $rest ;
+            read($fh1, $rest, 5000);
+            is $x->trailingData() . $rest, $trailer ;
+            #print "# [".$x->trailingData() . "][$rest]\n" ;
+
+        }
+
+        {
+            # embed a compressed file in another buffer
+            #================================
+
+
+            my $hello = <<EOM ;
+hello world
+this is a test
+EOM
+
+            my $trailer = "trailer data" ;
+
+            my $compressed ;
+
+            {
+              ok my $x = new $CompressClass(\$compressed);
+
+              ok $x->write($hello) ;
+              ok $x->close ;
+              $compressed .= $trailer ;
+            }
+
+            my $uncomp;
+            ok my $x = new $UncompressClass(\$compressed, Append => 1)  ;
+            1 while $x->read($uncomp) > 0 ;
+
+            ok $uncomp eq $hello ;
+            is $x->trailingData(), $trailer ;
+
+        }
+
+        {
+            # Write
+            # these tests come almost 100% from IO::String
+
+            my $lex = new LexFile my $name ;
+
+            my $io = $CompressClass->new($name);
+
+            is $io->tell(), 0, " tell returns 0"; ;
+
+            my $heisan = "Heisan\n";
+            $io->print($heisan) ;
+
+            ok ! $io->eof(), "  ! eof";
+
+            is $io->tell(), length($heisan), "  tell is " . length($heisan) ;
+
+            $io->print("a", "b", "c");
+
+            {
+                local($\) = "\n";
+                $io->print("d", "e");
+                local($,) = ",";
+                $io->print("f", "g", "h");
+            }
+
+            {
+                local($\) ;
+                $io->print("D", "E");
+                local($,) = ".";
+                $io->print("F", "G", "H");
+            }
+
+            my $foo = "1234567890";
+            
+            is $io->syswrite($foo, length($foo)), length($foo), "  syswrite ok" ;
+            if ( $] < 5.6 )
+              { is $io->syswrite($foo, length $foo), length $foo, "  syswrite ok" }
+            else
+              { is $io->syswrite($foo), length $foo, "  syswrite ok" }
+            is $io->syswrite($foo, length($foo)), length $foo, "  syswrite ok";
+            is $io->write($foo, length($foo), 5), 5,   " write 5";
+            is $io->write("xxx\n", 100, -1), 1, "  write 1";
+
+            for (1..3) {
+                $io->printf("i(%d)", $_);
+                $io->printf("[%d]\n", $_);
+            }
+            $io->print("\n");
+
+            $io->close ;
+
+            ok $io->eof(), "  eof";
+
+            is myGZreadFile($name), "Heisan\nabcde\nf,g,h\nDEF.G.H" .
+                                    ("1234567890" x 3) . "67890\n" .
+                                        "i(1)[1]\ni(2)[2]\ni(3)[3]\n\n",
+                                        "myGZreadFile ok";
+
+
+        }
+
+        {
+            # Read
+            my $str = <<EOT;
+This is an example
+of a paragraph
+
+
+and a single line.
+
+EOT
+
+            my $lex = new LexFile my $name ;
+
+            my %opts = () ;
+            my $iow = new $CompressClass $name, %opts;
+            is $iow->input_line_number, undef; 
+            $iow->print($str) ;
+            is $iow->input_line_number, undef; 
+            $iow->close ;
+
+            my @tmp;
+            my $buf;
+            {
+                my $io = new $UncompressClass $name ;
+            
+                is $., 0; 
+                is $io->input_line_number, 0; 
+                ok ! $io->eof, "eof";
+                is $io->tell(), 0, "tell 0" ;
+                #my @lines = <$io>;
+                my @lines = $io->getlines();
+                is @lines, 6
+                    or print "# Got " . scalar(@lines) . " lines, expected 6\n" ;
+                is $lines[1], "of a paragraph\n" ;
+                is join('', @lines), $str ;
+                is $., 6; 
+                is $io->input_line_number, 6; 
+                is $io->tell(), length($str) ;
+            
+                ok $io->eof;
+
+                ok ! ( defined($io->getline)  ||
+                          (@tmp = $io->getlines) ||
+                          defined($io->getline)         ||
+                          defined($io->getc)     ||
+                          $io->read($buf, 100)   != 0) ;
+            }
+            
+            
+            {
+                local $/;  # slurp mode
+                my $io = $UncompressClass->new($name);
+                is $., 0; 
+                is $io->input_line_number, 0; 
+                ok ! $io->eof;
+                my @lines = $io->getlines;
+                is $., 1; 
+                is $io->input_line_number, 1; 
+                ok $io->eof;
+                ok @lines == 1 && $lines[0] eq $str;
+            
+                $io = $UncompressClass->new($name);
+                ok ! $io->eof;
+                my $line = $io->getline();
+                ok $line eq $str;
+                ok $io->eof;
+            }
+            
+            {
+                local $/ = "";  # paragraph mode
+                my $io = $UncompressClass->new($name);
+                is $., 0; 
+                is $io->input_line_number, 0; 
+                ok ! $io->eof;
+                my @lines = $io->getlines();
+                is $., 2; 
+                is $io->input_line_number, 2; 
+                ok $io->eof;
+                ok @lines == 2 
+                    or print "# Got " . scalar(@lines) . " lines, expected 2\n" ;
+                ok $lines[0] eq "This is an example\nof a paragraph\n\n\n"
+                    or print "# $lines[0]\n";
+                ok $lines[1] eq "and a single line.\n\n";
+            }
+            
+            {
+                # Record mode
+                my $reclen = 7 ;
+                my $expected_records = int(length($str) / $reclen)
+                                        + (length($str) % $reclen ? 1 : 0);
+                local $/ = \$reclen;
+
+                my $io = $UncompressClass->new($name);
+                is $., 0; 
+                is $io->input_line_number, 0; 
+
+                ok ! $io->eof;
+                my @lines = $io->getlines();
+                is $., $expected_records; 
+                is $io->input_line_number, $expected_records; 
+                ok $io->eof;
+                is @lines, $expected_records, 
+                    "Got $expected_records records\n" ;
+                ok $lines[0] eq substr($str, 0, $reclen)
+                    or print "# $lines[0]\n";
+                ok $lines[1] eq substr($str, $reclen, $reclen);
+            }
+
+            {
+                local $/ = "is";
+                my $io = $UncompressClass->new($name);
+                my @lines = ();
+                my $no = 0;
+                my $err = 0;
+                ok ! $io->eof;
+                while (my $a = $io->getline()) {
+                    push(@lines, $a);
+                    $err++ if $. != ++$no;
+                }
+            
+                ok $err == 0 ;
+                ok $io->eof;
+            
+                is $., 3; 
+                is $io->input_line_number, 3; 
+                ok @lines == 3 
+                    or print "# Got " . scalar(@lines) . " lines, expected 3\n" ;
+                ok join("-", @lines) eq
+                                 "This- is- an example\n" .
+                                "of a paragraph\n\n\n" .
+                                "and a single line.\n\n";
+            }
+            
+            
+            # Test read
+            
+            {
+                my $io = $UncompressClass->new($name);
+            
+
+                eval { $io->read(1) } ;
+                like $@, mkErr("buffer parameter is read-only");
+
+                $buf = "abcd";
+                is $io->read($buf, 0), 0, "Requested 0 bytes" ;
+                is $buf, "", "Buffer empty";
+
+                is $io->read($buf, 3), 3 ;
+                is $buf, "Thi";
+            
+                is $io->sysread($buf, 3, 2), 3 ;
+                is $buf, "Ths i"
+                    or print "# [$buf]\n" ;;
+                ok ! $io->eof;
+            
+                $buf = "ab" ;
+                is $io->read($buf, 3, 4), 3 ;
+                is $buf, "ab" . "\x00" x 2 . "s a"
+                    or print "# [$buf]\n" ;;
+                ok ! $io->eof;
+            
+                # read the rest of the file
+                $buf = '';
+                my $remain = length($str) - 9;
+                is $io->read($buf, $remain+1), $remain ;
+                is $buf, substr($str, 9);
+                ok $io->eof;
+
+                $buf = "hello";
+                is $io->read($buf, 10), 0 ;
+                is $buf, "", "Buffer empty";
+                ok $io->eof;
+
+                ok $io->close();
+                $buf = "hello";
+                is $io->read($buf, 10), 0 ;
+                is $buf, "hello", "Buffer not empty";
+                ok $io->eof;
+
+        #        $io->seek(-4, 2);
+        #    
+        #        ok ! $io->eof;
+        #    
+        #        ok read($io, $buf, 20) == 4 ;
+        #        ok $buf eq "e.\n\n";
+        #    
+        #        ok read($io, $buf, 20) == 0 ;
+        #        ok $buf eq "";
+        #   
+        #        ok ! $io->eof;
+            }
+
+        }
+
+        {
+            # Read from non-compressed file
+
+            my $str = <<EOT;
+This is an example
+of a paragraph
+
+
+and a single line.
+
+EOT
+
+            my $lex = new LexFile my $name ;
+
+            writeFile($name, $str);
+            my @tmp;
+            my $buf;
+            {
+                my $io = new $UncompressClass $name, -Transparent => 1 ;
+            
+                ok defined $io;
+                ok ! $io->eof;
+                ok $io->tell() == 0 ;
+                my @lines = $io->getlines();
+                is @lines, 6; 
+                ok $lines[1] eq "of a paragraph\n" ;
+                ok join('', @lines) eq $str ;
+                is $., 6; 
+                is $io->input_line_number, 6; 
+                ok $io->tell() == length($str) ;
+            
+                ok $io->eof;
+
+                ok ! ( defined($io->getline)  ||
+                          (@tmp = $io->getlines) ||
+                          defined($io->getline)         ||
+                          defined($io->getc)     ||
+                          $io->read($buf, 100)   != 0) ;
+            }
+            
+            
+            {
+                local $/;  # slurp mode
+                my $io = $UncompressClass->new($name);
+                ok ! $io->eof;
+                my @lines = $io->getlines;
+                is $., 1; 
+                is $io->input_line_number, 1; 
+                ok $io->eof;
+                ok @lines == 1 && $lines[0] eq $str;
+            
+                $io = $UncompressClass->new($name);
+                ok ! $io->eof;
+                my $line = $io->getline;
+                is $., 1; 
+                is $io->input_line_number, 1; 
+                ok $line eq $str;
+                ok $io->eof;
+            }
+            
+            {
+                local $/ = "";  # paragraph mode
+                my $io = $UncompressClass->new($name);
+                ok ! $io->eof;
+                my @lines = $io->getlines;
+                is $., 2; 
+                is $io->input_line_number, 2; 
+                ok $io->eof;
+                ok @lines == 2 
+                    or print "# exected 2 lines, got " . scalar(@lines) . "\n";
+                ok $lines[0] eq "This is an example\nof a paragraph\n\n\n"
+                    or print "# [$lines[0]]\n" ;
+                ok $lines[1] eq "and a single line.\n\n";
+            }
+            
+            {
+                # Record mode
+                my $reclen = 7 ;
+                my $expected_records = int(length($str) / $reclen)
+                                        + (length($str) % $reclen ? 1 : 0);
+                local $/ = \$reclen;
+
+                my $io = $UncompressClass->new($name);
+                is $., 0; 
+                is $io->input_line_number, 0; 
+
+                ok ! $io->eof;
+                my @lines = $io->getlines();
+                is $., $expected_records; 
+                is $io->input_line_number, $expected_records; 
+                ok $io->eof;
+                is @lines, $expected_records, 
+                    "Got $expected_records records\n" ;
+                ok $lines[0] eq substr($str, 0, $reclen)
+                    or print "# $lines[0]\n";
+                ok $lines[1] eq substr($str, $reclen, $reclen);
+            }
+
+            {
+                local $/ = "is";
+                my $io = $UncompressClass->new($name);
+                my @lines = ();
+                my $no = 0;
+                my $err = 0;
+                ok ! $io->eof;
+                while (my $a = $io->getline) {
+                    push(@lines, $a);
+                    $err++ if $. != ++$no;
+                }
+            
+                is $., 3; 
+                is $io->input_line_number, 3; 
+                ok $err == 0 ;
+                ok $io->eof;
+            
+
+                ok @lines == 3 ;
+                ok join("-", @lines) eq
+                                 "This- is- an example\n" .
+                                "of a paragraph\n\n\n" .
+                                "and a single line.\n\n";
+            }
+            
+            
+            # Test Read
+            
+            {
+                my $io = $UncompressClass->new($name);
+            
+                $buf = "abcd";
+                is $io->read($buf, 0), 0, "Requested 0 bytes" ;
+                is $buf, "", "Buffer empty";
+
+                ok $io->read($buf, 3) == 3 ;
+                ok $buf eq "Thi";
+            
+                ok $io->sysread($buf, 3, 2) == 3 ;
+                ok $buf eq "Ths i";
+                ok ! $io->eof;
+            
+                $buf = "ab" ;
+                is $io->read($buf, 3, 4), 3 ;
+                is $buf, "ab" . "\x00" x 2 . "s a"
+                    or print "# [$buf]\n" ;;
+                ok ! $io->eof;
+            
+                # read the rest of the file
+                $buf = '';
+                my $remain = length($str) - 9;
+                is $io->read($buf, $remain), $remain ;
+                is $buf, substr($str, 9);
+                ok $io->eof;
+
+                $buf = "hello";
+                is $io->read($buf, 10), 0 ;
+                is $buf, "", "Buffer empty";
+                ok $io->eof;
+
+                ok $io->close();
+                $buf = "hello";
+                is $io->read($buf, 10), 0 ;
+                is $buf, "hello", "Buffer not empty";
+                ok $io->eof;
+
+        #        $io->seek(-4, 2);
+        #    
+        #        ok ! $io->eof;
+        #    
+        #        ok read($io, $buf, 20) == 4 ;
+        #        ok $buf eq "e.\n\n";
+        #    
+        #        ok read($io, $buf, 20) == 0 ;
+        #        ok $buf eq "";
+        #    
+        #        ok ! $io->eof;
+            }
+
+
+        }
+
+        {
+            # Vary the length parameter in a read
+
+            my $str = <<EOT;
+x
+x
+This is an example
+of a paragraph
+
+
+and a single line.
+
+EOT
+            $str = $str x 100 ;
+
+
+            foreach my $bufsize (1, 3, 512, 4096, length($str)-1, length($str), length($str)+1)
+            {
+                foreach my $trans (0, 1)
+                {
+                    foreach my $append (0, 1)
+                    {
+                        title "Read Tests - buf length $bufsize, Transparent $trans, Append $append" ;
+
+                        my $lex = new LexFile my $name ;
+
+                        if ($trans) {
+                            writeFile($name, $str) ;
+                        }
+                        else {
+                            my $iow = new $CompressClass $name;
+                            $iow->print($str) ;
+                            $iow->close ;
+                        }
+
+                        
+                        my $io = $UncompressClass->new($name, 
+                                                       -Append => $append,
+                                                       -Transparent  => $trans);
+                    
+                        my $buf;
+                        
+                        is $io->tell(), 0;
+
+                        if ($append) {
+                            1 while $io->read($buf, $bufsize) > 0;
+                        }
+                        else {
+                            my $tmp ;
+                            $buf .= $tmp while $io->read($tmp, $bufsize) > 0 ;
+                        }
+                        is length $buf, length $str;
+                        ok $buf eq $str ;
+                        ok ! $io->error() ;
+                        ok $io->eof;
+                    }
+                }
+            }
+        }
+
+        foreach my $file (0, 1)
+        {
+            foreach my $trans (0, 1)
+            {
+                title "seek tests - file $file trans $trans" ;
+
+                my $buffer ;
+                my $buff ;
+                my $lex = new LexFile my $name ;
+
+                my $first = "beginning" ;
+                my $last  = "the end" ;
+
+                if ($trans)
+                {
+                    $buffer = $first . "\x00" x 10 . $last;
+                    writeFile($name, $buffer);
+                }
+                else
+                {
+                    my $output ;
+                    if ($file)
+                    {
+                        $output = $name ;
+                    }
+                    else
+                    {
+                        $output = \$buffer;
+                    }
+
+                    my $iow = new $CompressClass $output ;
+                    $iow->print($first) ;
+                    ok $iow->seek(5, SEEK_CUR) ;
+                    ok $iow->tell() == length($first)+5;
+                    ok $iow->seek(0, SEEK_CUR) ;
+                    ok $iow->tell() == length($first)+5;
+                    ok $iow->seek(length($first)+10, SEEK_SET) ;
+                    ok $iow->tell() == length($first)+10;
+
+                    $iow->print($last) ;
+                    $iow->close ;
+                }
+
+                my $input ;
+                if ($file)
+                {
+                    $input = $name ;
+                }
+                else
+                {
+                    $input = \$buffer ;
+                }
+
+                ok myGZreadFile($input) eq $first . "\x00" x 10 . $last ;
+
+                my $io = $UncompressClass->new($input, Strict => 1);
+                ok $io->seek(length($first), SEEK_CUR) 
+                    or diag $$UnError ;
+                ok ! $io->eof;
+                is $io->tell(), length($first);
+
+                ok $io->read($buff, 5) ;
+                is $buff, "\x00" x 5 ;
+                is $io->tell(), length($first) + 5;
+
+                ok $io->seek(0, SEEK_CUR) ;
+                my $here = $io->tell() ;
+                is $here, length($first)+5;
+
+                ok $io->seek($here+5, SEEK_SET) ;
+                is $io->tell(), $here+5 ;
+                ok $io->read($buff, 100) ;
+                ok $buff eq $last ;
+                ok $io->eof;
+            }
+        }
+
+        {
+            title "seek error cases" ;
+
+            my $b ;
+            my $a = new $CompressClass(\$b)  ;
+
+            ok ! $a->error() ;
+            eval { $a->seek(-1, 10) ; };
+            like $@, mkErr("^${CompressClass}::seek: unknown value, 10, for whence parameter");
+
+            eval { $a->seek(-1, SEEK_END) ; };
+            like $@, mkErr("^${CompressClass}::seek: cannot seek backwards");
+
+            $a->write("fred");
+            $a->close ;
+
+
+            my $u = new $UncompressClass(\$b)  ;
+
+            eval { $u->seek(-1, 10) ; };
+            like $@, mkErr("^${UncompressClass}::seek: unknown value, 10, for whence parameter");
+
+            eval { $u->seek(-1, SEEK_END) ; };
+            like $@, mkErr("^${UncompressClass}::seek: SEEK_END not allowed");
+
+            eval { $u->seek(-1, SEEK_CUR) ; };
+            like $@, mkErr("^${UncompressClass}::seek: cannot seek backwards");
+        }
+        
+        foreach my $fb (qw(filename buffer filehandle))
+        {
+            foreach my $append (0, 1)
+            {
+                {
+                    title "$CompressClass -- Append $append, Output to $fb" ;
+
+                    my $lex = new LexFile my $name ;
+
+                    my $already = 'already';
+                    my $buffer = $already;
+                    my $output;
+
+                    if ($fb eq 'buffer')
+                      { $output = \$buffer }
+                    elsif ($fb eq 'filename')
+                    {
+                        $output = $name ;
+                        writeFile($name, $buffer);
+                    }
+                    elsif ($fb eq 'filehandle')
+                    {
+                        $output = new IO::File ">$name" ;
+                        print $output $buffer;
+                    }
+
+                    my $a = new $CompressClass($output, Append => $append)  ;
+                    ok $a, "  Created $CompressClass";
+                    my $string = "appended";
+                    $a->write($string);
+                    $a->close ;
+
+                    my $data ; 
+                    if ($fb eq 'buffer')
+                    {
+                        $data = $buffer;
+                    }
+                    else
+                    {
+                        $output->close
+                            if $fb eq 'filehandle';
+                        $data = readFile($name);
+                    }
+
+                    if ($append || $fb eq 'filehandle')
+                    {
+                        is substr($data, 0, length($already)), $already, "  got prefix";
+                        substr($data, 0, length($already)) = '';
+                    }
+
+
+                    my $uncomp;
+                    my $x = new $UncompressClass(\$data, Append => 1)  ;
+                    ok $x, "  created $UncompressClass";
+
+                    my $len ;
+                    1 while ($len = $x->read($uncomp)) > 0 ;
+
+                    $x->close ;
+                    is $uncomp, $string, '  Got uncompressed data' ;
+                    
+                }
+            }
+        }
+
+        foreach my $type (qw(buffer filename filehandle))
+        {
+            foreach my $good (0, 1)
+            {
+                title "$UncompressClass -- InputLength, read from $type, good data => $good";
+
+                my $compressed ; 
+                my $string = "some data";
+                my $appended = "append";
+
+                if ($good)
+                {
+                    my $c = new $CompressClass(\$compressed);
+                    $c->write($string);
+                    $c->close();
+                }
+                else
+                {
+                    $compressed = $string ;
+                }
+
+                my $comp_len = length $compressed;
+                $compressed .= $appended;
+
+                my $lex = new LexFile my $name ;
+                my $input ;
+                writeFile ($name, $compressed);
+
+                if ($type eq 'buffer')
+                {
+                    $input = \$compressed;
+                }
+                if ($type eq 'filename')
+                {
+                    $input = $name;
+                }
+                elsif ($type eq 'filehandle')
+                {
+                    my $fh = new IO::File "<$name" ;
+                    ok $fh, "opened file $name ok";
+                    $input = $fh ;
+                }
+
+                my $x = new $UncompressClass($input, 
+                                             InputLength => $comp_len,
+                                             Transparent => 1)  ;
+                ok $x, "  created $UncompressClass";
+
+                my $len ;
+                my $output;
+                $len = $x->read($output, 100);
+
+                is $len, length($string);
+                is $output, $string;
+
+                if ($type eq 'filehandle')
+                {
+                    my $rest ;
+                    $input->read($rest, 1000);
+                    is $rest, $appended;
+                }
+            }
+
+
+        }
+        
+        foreach my $append (0, 1)
+        {
+            title "$UncompressClass -- Append $append" ;
+
+            my $lex = new LexFile my $name ;
+
+            my $string = "appended";
+            my $compressed ; 
+            my $c = new $CompressClass(\$compressed);
+            $c->write($string);
+            $c->close();
+
+            my $x = new $UncompressClass(\$compressed, Append => $append)  ;
+            ok $x, "  created $UncompressClass";
+
+            my $already = 'already';
+            my $output = $already;
+
+            my $len ;
+            $len = $x->read($output, 100);
+            is $len, length($string);
+
+            $x->close ;
+
+            if ($append)
+            {
+                is substr($output, 0, length($already)), $already, "  got prefix";
+                substr($output, 0, length($already)) = '';
+            }
+            is $output, $string, '  Got uncompressed data' ;
+        }
+        
+
+        foreach my $file (0, 1)
+        {
+            foreach my $trans (0, 1)
+            {
+                title "ungetc, File $file, Transparent $trans" ;
+
+                my $lex = new LexFile my $name ;
+
+                my $string = 'abcdeABCDE';
+                my $b ;
+                if ($trans)
+                {
+                    $b = $string ;
+                }
+                else
+                {
+                    my $a = new $CompressClass(\$b)  ;
+                    $a->write($string);
+                    $a->close ;
+                }
+
+                my $from ;
+                if ($file)
+                {
+                    writeFile($name, $b);
+                    $from = $name ;
+                }
+                else
+                {
+                    $from = \$b ;
+                }
+
+                my $u = $UncompressClass->new($from, Transparent => 1)  ;
+                my $first;
+                my $buff ;
+
+                # do an ungetc before reading
+                $u->ungetc("X");
+                $first = $u->getc();
+                is $first, 'X';
+
+                $first = $u->getc();
+                is $first, substr($string, 0,1);
+                $u->ungetc($first);
+                $first = $u->getc();
+                is $first, substr($string, 0,1);
+                $u->ungetc($first);
+
+                is $u->read($buff, 5), 5 ;
+                is $buff, substr($string, 0, 5);
+
+                $u->ungetc($buff) ;
+                is $u->read($buff, length($string)), length($string) ;
+                is $buff, $string;
+
+                is $u->read($buff, 1), 0;
+                ok $u->eof() ;
+
+                my $extra = 'extra';
+                $u->ungetc($extra);
+                ok ! $u->eof();
+                is $u->read($buff), length($extra) ;
+                is $buff, $extra;
+                
+                is $u->read($buff, 1), 0;
+                ok $u->eof() ;
+
+                # getc returns undef on eof
+                is $u->getc(), undef;
+                $u->close();
+
+            }
+        }
+
+        {
+            title "write tests - invalid data" ;
+
+            #my $lex = new LexFile my $name1 ;
+            my($Answer);
+
+            #ok ! -e $name1, "  File $name1 does not exist";
+
+            my @data = (
+                [ '{ }',         "${CompressClass}::write: input parameter not a filename, filehandle, array ref or scalar ref" ], 
+                [ '[ { } ]',     "${CompressClass}::write: input parameter not a filename, filehandle, array ref or scalar ref" ], 
+                [ '[ [ { } ] ]', "${CompressClass}::write: input parameter not a filename, filehandle, array ref or scalar ref" ], 
+                [ '[ "" ]',      "${CompressClass}::write: input filename is undef or null string" ], 
+                [ '[ undef ]',   "${CompressClass}::write: input filename is undef or null string" ], 
+                [ '[ \$Answer ]',"${CompressClass}::write: input and output buffer are identical" ], 
+                #[ "not readable", 'xx' ], 
+                # same filehandle twice, 'xx'
+               ) ;
+
+            foreach my $data (@data)
+            {
+                my ($send, $get) = @$data ;
+                title "${CompressClass}::write( $send )";
+                my($copy);
+                eval "\$copy = $send";
+                my $x = new $CompressClass(\$Answer);
+                ok $x, "  Created $CompressClass object";
+                eval { $x->write($copy) } ;
+                #like $@, "/^$get/", "  error - $get";
+                like $@, "/not a scalar reference /", "  error - not a scalar reference";
+            }
+
+    #        @data = (
+    #            [ '[ $name1 ]',  "input file '$name1' does not exist" ], 
+    #            #[ "not readable", 'xx' ], 
+    #            # same filehandle twice, 'xx'
+    #           ) ;
+    #
+    #        foreach my $data (@data)
+    #        {
+    #            my ($send, $get) = @$data ;
+    #            title "${CompressClass}::write( $send )";
+    #            my $copy;
+    #            eval "\$copy = $send";
+    #            my $x = new $CompressClass(\$Answer);
+    #            ok $x, "  Created $CompressClass object";
+    #            ok ! $x->write($copy), "  write fails"  ;
+    #            like $$Error, "/^$get/", "  error - $get";
+    #        }
+
+            #exit;
+            
+        }
+
+
+    #    sub deepCopy
+    #    {
+    #        if (! ref $_[0] || ref $_[0] eq 'SCALAR')
+    #        {
+    #            return $_[0] ;
+    #        }
+    #
+    #        if (ref $_[0] eq 'ARRAY')
+    #        {
+    #            my @a ;
+    #            for my $x ( @{ $_[0] })
+    #            {
+    #                push @a, deepCopy($x);
+    #            }
+    #
+    #            return \@a ;
+    #        }
+    #
+    #        croak "bad! $_[0]";
+    #
+    #    }
+    #
+    #    sub deepSubst
+    #    {
+    #        #my $data = shift ;
+    #        my $from = $_[1] ;
+    #        my $to   = $_[2] ;
+    #
+    #        if (! ref $_[0])
+    #        {
+    #            $_[0] = $to 
+    #                if $_[0] eq $from ;
+    #            return ;    
+    #
+    #        }
+    #
+    #        if (ref $_[0] eq 'SCALAR')
+    #        {
+    #            $_[0] = \$to 
+    #                if defined ${ $_[0] } && ${ $_[0] } eq $from ;
+    #            return ;    
+    #
+    #        }
+    #
+    #        if (ref $_[0] eq 'ARRAY')
+    #        {
+    #            for my $x ( @{ $_[0] })
+    #            {
+    #                deepSubst($x, $from, $to);
+    #            }
+    #            return ;
+    #        }
+    #        #croak "bad! $_[0]";
+    #    }
+
+    #    {
+    #        title "More write tests" ;
+    #
+    #        my $file1 = "file1" ;
+    #        my $file2 = "file2" ;
+    #        my $file3 = "file3" ;
+    #        my $lex = new LexFile $file1, $file2, $file3 ;
+    #
+    #        writeFile($file1, "F1");
+    #        writeFile($file2, "F2");
+    #        writeFile($file3, "F3");
+    #
+    #        my @data = (
+    #              [ '""',                                   ""      ],
+    #              [ 'undef',                                ""      ],
+    #              [ '"abcd"',                               "abcd"  ],
+    #
+    #              [ '\""',                                   ""     ],
+    #              [ '\undef',                                ""     ],
+    #              [ '\"abcd"',                               "abcd" ],
+    #
+    #              [ '[]',                                    ""     ],
+    #              [ '[[]]',                                  ""     ],
+    #              [ '[[[]]]',                                ""     ],
+    #              [ '[\""]',                                 ""     ],
+    #              [ '[\undef]',                              ""     ],
+    #              [ '[\"abcd"]',                             "abcd" ],
+    #              [ '[\"ab", \"cd"]',                        "abcd" ],
+    #              [ '[[\"ab"], [\"cd"]]',                    "abcd" ],
+    #
+    #              [ '$file1',                                $file1 ],
+    #              [ '$fh2',                                  "F2"   ],
+    #              [ '[$file1, \"abc"]',                      "F1abc"],
+    #              [ '[\"a", $file1, \"bc"]',                 "aF1bc"],
+    #              [ '[\"a", $fh1, \"bc"]',                   "aF1bc"],
+    #              [ '[\"a", $fh1, \"bc", $file2]',           "aF1bcF2"],
+    #              [ '[\"a", $fh1, \"bc", $file2, $fh3]',     "aF1bcF2F3"],
+    #            ) ;
+    #
+    #
+    #        foreach my $data (@data)
+    #        {
+    #            my ($send, $get) = @$data ;
+    #
+    #            my $fh1 = new IO::File "< $file1" ;
+    #            my $fh2 = new IO::File "< $file2" ;
+    #            my $fh3 = new IO::File "< $file3" ;
+    #
+    #            title "${CompressClass}::write( $send )";
+    #            my $copy;
+    #            eval "\$copy = $send";
+    #            my $Answer ;
+    #            my $x = new $CompressClass(\$Answer);
+    #            ok $x, "  Created $CompressClass object";
+    #            my $len = length $get;
+    #            is $x->write($copy), length($get), "  write $len bytes";
+    #            ok $x->close(), "  close ok" ;
+    #
+    #            is myGZreadFile(\$Answer), $get, "  got expected output" ;
+    #            cmp_ok $$Error, '==', 0, "  no error";
+    #
+    #
+    #        }
+    #        
+    #    }
+    }
+
+}
+
+1;
+
+
+
+
+
diff -urN perl-5.10.0/ext/IO_Compress_Base/t.xxx/compress/merge.pl perl-5.10.0/ext/IO_Compress_Base/t/compress/merge.pl
--- perl-5.10.0/ext/IO_Compress_Base/t.xxx/compress/merge.pl	1970-01-01 01:00:00.000000000 +0100
+++ perl-5.10.0/ext/IO_Compress_Base/t/compress/merge.pl	2008-09-03 15:57:30.000000000 +0200
@@ -0,0 +1,330 @@
+use lib 't';
+use strict;
+use warnings;
+use bytes;
+
+use Test::More ; 
+use CompTestUtils;
+
+use Compress::Raw::Zlib 2 ;
+
+BEGIN 
+{ 
+    plan(skip_all => "Merge needs Zlib 1.2.1 or better - you have Zlib "  
+                . Compress::Raw::Zlib::zlib_version()) 
+        if ZLIB_VERNUM() < 0x1210 ;
+
+    # use Test::NoWarnings, if available
+    my $extra = 0 ;
+    $extra = 1
+        if eval { require Test::NoWarnings ;  import Test::NoWarnings; 1 };
+
+    plan tests => 165 + $extra ;
+
+}
+
+
+sub run
+{
+
+    my $CompressClass   = identify();
+    my $UncompressClass = getInverse($CompressClass);
+    my $Error           = getErrorRef($CompressClass);
+    my $UnError         = getErrorRef($UncompressClass);
+
+    # Tests     
+    #   destination is a file that doesn't exist -- should work ok unless AnyDeflate
+    #   destination isn't compressed at all
+    #   destination is compressed but wrong format
+    #   destination is corrupt - error messages should be correct
+    #   use apend mode with old zlib - check that this is trapped
+    #   destination is not seekable, readable, writable - test for filename & handle
+
+    {
+        title "Misc error cases";
+
+        eval { new Compress::Raw::Zlib::InflateScan Bufsize => 0} ;
+        like $@, mkErr("^Compress::Raw::Zlib::InflateScan::new: Bufsize must be >= 1, you specified 0"), "  catch bufsize == 0";
+
+        eval { Compress::Raw::Zlib::inflateScanStream::createDeflateStream(undef, Bufsize => 0) } ;
+        like $@, mkErr("^Compress::Raw::Zlib::InflateScan::createDeflateStream: Bufsize must be >= 1, you specified 0"), "  catch bufsize == 0";
+
+    }
+
+    # output file/handle not writable
+    {
+
+        foreach my $to_file (0,1)
+        {
+            if ($to_file)
+              { title "$CompressClass - Merge to filename that isn't writable" }
+            else  
+              { title "$CompressClass - Merge to filehandle that isn't writable" }
+
+            my $lex = new LexFile my $out_file ;
+
+            # create empty file
+            open F, ">$out_file" ; print F "x"; close F;
+            ok   -e $out_file, "  file exists" ;
+            ok  !-z $out_file, "  and is not empty" ;
+            
+            # make unwritable
+            is chmod(0444, $out_file), 1, "  chmod worked" ;
+            ok   -e $out_file, "  still exists after chmod" ;
+
+            SKIP:
+            {
+                skip "Cannot create non-writable file", 3 
+                    if -w $out_file ;
+
+                ok ! -w $out_file, "  chmod made file unwritable" ;
+
+                my $dest ;
+                if ($to_file)
+                  { $dest = $out_file }
+                else
+                  { $dest = new IO::File "<$out_file"  }
+
+                my $gz = $CompressClass->new($dest, Merge => 1) ;
+                
+                ok ! $gz, "  Did not create $CompressClass object";
+
+                {
+                    if ($to_file) {
+                        is $$Error, "Output file '$out_file' is not writable",
+                                "  Got non-writable filename message" ;
+                    }
+                    else {
+                        ok $$Error, "  Got error message" ;
+                    }
+                }
+            }
+
+            chmod 0777, $out_file ;
+        }
+    }
+
+    # output is not compressed at all
+    {
+
+        my $lex = new LexFile my $out_file ;
+
+        foreach my $to_file ( qw(buffer file handle ) )
+        {
+            title "$CompressClass to $to_file, content is not compressed";
+
+            my $content = "abc" x 300 ;
+            my $buffer ;
+            my $disp_content = defined $content ? $content : '<undef>' ;
+            my $str_content = defined $content ? $content : '' ;
+
+            if ($to_file eq 'buffer')
+            {
+                $buffer = \$content ;
+            }
+            else
+            {
+                writeFile($out_file, $content);
+
+                if ($to_file eq 'handle')
+                {
+                    $buffer = new IO::File "+<$out_file" 
+                        or die "# Cannot open $out_file: $!";
+                }
+                else
+                  { $buffer = $out_file }
+            }
+
+            ok ! $CompressClass->new($buffer, Merge => 1), "  constructor fails";
+            {
+                like $$Error, '/Cannot create InflateScan object: (Header Error|unexpected end of file)/', "  got Bad Magic" ;
+            }
+
+        }
+    }
+
+    # output is empty
+    {
+
+        my $lex = new LexFile my $out_file ;
+
+        foreach my $to_file ( qw(buffer file handle ) )
+        {
+            title "$CompressClass to $to_file, content is empty";
+
+            my $content = '';
+            my $buffer ;
+            my $dest ;
+
+            if ($to_file eq 'buffer')
+            {
+                $dest = $buffer = \$content ;
+            }
+            else
+            {
+                writeFile($out_file, $content);
+                $dest = $out_file;
+
+                if ($to_file eq 'handle')
+                {
+                    $buffer = new IO::File "+<$out_file" 
+                        or die "# Cannot open $out_file: $!";
+                }
+                else
+                  { $buffer = $out_file }
+            }
+
+            ok my $gz = $CompressClass->new($buffer, Merge => 1, AutoClose => 1), "  constructor passes"
+                or diag $$Error;
+
+            $gz->write("FGHI");
+            $gz->close();
+
+            #hexDump($buffer);
+            my $out = anyUncompress($dest);
+
+            is $out, "FGHI", '  Merge OK';
+        }
+    }
+
+    {
+        title "$CompressClass - Merge to file that doesn't exist";
+
+        my $lex = new LexFile my $out_file ;
+        
+        ok ! -e $out_file, "  Destination file, '$out_file', does not exist";
+
+        ok my $gz1 = $CompressClass->new($out_file, Merge => 1)
+            or die "# $CompressClass->new failed: $$Error\n";
+        #hexDump($buffer);
+        $gz1->write("FGHI");
+        $gz1->close();
+
+        #hexDump($buffer);
+        my $out = anyUncompress($out_file);
+
+        is $out, "FGHI", '  Merged OK';
+    }
+
+    {
+
+        my $lex = new LexFile my $out_file ;
+
+        foreach my $to_file ( qw( buffer file handle ) )
+        {
+            foreach my $content (undef, '', 'x', 'abcde')
+            {
+                #next if ! defined $content && $to_file; 
+
+                my $buffer ;
+                my $disp_content = defined $content ? $content : '<undef>' ;
+                my $str_content = defined $content ? $content : '' ;
+
+                if ($to_file eq 'buffer')
+                {
+                    my $x ;
+                    $buffer = \$x ;
+                    title "$CompressClass to Buffer, content is '$disp_content'";
+                }
+                else
+                {
+                    $buffer = $out_file ;
+                    if ($to_file eq 'handle')
+                    {
+                        title "$CompressClass to Filehandle, content is '$disp_content'";
+                    }
+                    else
+                    {
+                        title "$CompressClass to File, content is '$disp_content'";
+                    }
+                }
+
+                my $gz = $CompressClass->new($buffer);
+                my $len = defined $content ? length($content) : 0 ;
+                is $gz->write($content), $len, "  write ok";
+                ok $gz->close(), " close ok";
+
+                #hexDump($buffer);
+                is anyUncompress($buffer), $str_content, '  Destination is ok';
+
+                #if ($corruption)
+                #{
+                    #    next if $TopTypes eq 'RawDeflate' && $content eq '';
+                    #
+                    #}
+
+                my $dest = $buffer ;    
+                if ($to_file eq 'handle')
+                {
+                    $dest = new IO::File "+<$buffer" ;
+                }
+
+                my $gz1 = $CompressClass->new($dest, Merge => 1, AutoClose => 1)
+                    or die "## Error is  $$Error\n";
+
+                #print "YYY\n";
+                #hexDump($buffer);
+                #print "XXX\n";
+                is $gz1->write("FGHI"), 4, "  write returned 4";
+                ok $gz1->close(), "  close ok";
+
+                #hexDump($buffer);
+                my $out = anyUncompress($buffer);
+
+                is $out, $str_content . "FGHI", '  Merged OK';
+                #exit;
+            }
+        }
+
+    }
+
+
+
+    {
+        my $Func = getTopFuncRef($CompressClass);
+        my $TopType = getTopFuncName($CompressClass);
+
+        my $buffer ;
+
+        my $lex = new LexFile my $out_file ;
+
+        foreach my $to_file (0, 1)
+        {
+            foreach my $content (undef, '', 'x', 'abcde')
+            {
+                my $disp_content = defined $content ? $content : '<undef>' ;
+                my $str_content = defined $content ? $content : '' ;
+                my $buffer ;
+                if ($to_file)
+                {
+                    $buffer = $out_file ;
+                    title "$TopType to File, content is '$disp_content'";
+                }
+                else
+                {
+                    my $x = '';
+                    $buffer = \$x ;
+                    title "$TopType to Buffer, content is '$disp_content'";
+                }
+                
+
+                ok $Func->(\$content, $buffer), " Compress content";
+                #hexDump($buffer);
+                is anyUncompress($buffer), $str_content, '  Destination is ok';
+
+
+                ok $Func->(\"FGHI", $buffer, Merge => 1), "  Merge content";
+
+                #hexDump($buffer);
+                my $out = anyUncompress($buffer);
+
+                is $out, $str_content . "FGHI", '  Merged OK';
+            }
+        }
+
+    }
+
+}
+
+
+1;
diff -urN perl-5.10.0/ext/IO_Compress_Base/t.xxx/compress/multi.pl perl-5.10.0/ext/IO_Compress_Base/t/compress/multi.pl
--- perl-5.10.0/ext/IO_Compress_Base/t.xxx/compress/multi.pl	1970-01-01 01:00:00.000000000 +0100
+++ perl-5.10.0/ext/IO_Compress_Base/t/compress/multi.pl	2008-09-03 15:57:30.000000000 +0200
@@ -0,0 +1,217 @@
+
+use lib 't';
+use strict;
+use warnings;
+use bytes;
+
+use Test::More ;
+use CompTestUtils;
+
+BEGIN {
+    # use Test::NoWarnings, if available
+    my $extra = 0 ;
+    $extra = 1
+        if eval { require Test::NoWarnings ;  import Test::NoWarnings; 1 };
+
+    plan tests => 694 + $extra ;
+
+    use_ok('IO::Uncompress::AnyUncompress', qw($AnyUncompressError)) ;
+
+}
+
+sub run
+{
+
+    my $CompressClass   = identify();
+    my $UncompressClass = getInverse($CompressClass);
+    my $Error           = getErrorRef($CompressClass);
+    my $UnError         = getErrorRef($UncompressClass);
+
+
+
+
+    my @buffers ;
+    push @buffers, <<EOM ;
+hello world
+this is a test
+some more stuff on this line
+ad finally...
+EOM
+
+    push @buffers, <<EOM ;
+some more stuff
+line 2
+EOM
+
+    push @buffers, <<EOM ;
+even more stuff
+EOM
+
+    {
+        my $cc ;
+        my $gz ;
+        my $hsize ;
+        my %headers = () ;
+        
+
+        foreach my $fb ( qw( file filehandle buffer ) )
+        {
+
+            foreach my $i (1 .. @buffers) {
+
+                title "Testing $CompressClass with $i streams to $fb";
+
+                my @buffs = @buffers[0..$i -1] ;
+
+                if ($CompressClass eq 'IO::Compress::Gzip') {
+                    %headers = (
+                                  Strict     => 1,
+                                  Comment    => "this is a comment",
+                                  ExtraField => ["so" => "me extra"],
+                                  HeaderCRC  => 1); 
+
+                }
+
+                my $lex = new LexFile my $name ;
+                my $output ;
+                if ($fb eq 'buffer')
+                {
+                    my $compressed = '';
+                    $output = \$compressed;
+                }
+                elsif ($fb eq 'filehandle')
+                {
+                    $output = new IO::File ">$name" ;
+                }
+                else
+                {
+                    $output = $name ;
+                }
+
+                my $x = new $CompressClass($output, AutoClose => 1, %headers);
+                isa_ok $x, $CompressClass, '  $x' ;
+
+                foreach my $buffer (@buffs) {
+                    ok $x->write($buffer), "    Write OK" ;
+                    # this will add an extra "empty" stream
+                    ok $x->newStream(), "    newStream OK" ;
+                }
+                ok $x->close, "  Close ok" ;
+
+                #hexDump($compressed) ;
+
+                foreach my $unc ($UncompressClass, 'IO::Uncompress::AnyUncompress') {
+                    title "  Testing $CompressClass with $unc and $i streams, from $fb";
+                    $cc = $output ;
+                    if ($fb eq 'filehandle')
+                    {
+                        $cc = new IO::File "<$name" ;
+                    }
+                    my @opts = $unc ne $UncompressClass 
+                                    ? (RawInflate => 1)
+                                    : ();
+                    my $gz = new $unc($cc,
+                                   @opts,
+                                   Strict      => 1,
+                                   AutoClose   => 1,
+                                   Append      => 1,
+                                   MultiStream => 1,
+                                   Transparent => 0)
+                        or diag $$UnError;
+                    isa_ok $gz, $UncompressClass, '    $gz' ;
+
+                    my $un = '';
+                    1 while $gz->read($un) > 0 ;
+                    #print "[[$un]]\n" while $gz->read($un) > 0 ;
+                    ok ! $gz->error(), "      ! error()"
+                        or diag "Error is " . $gz->error() ;
+                    ok $gz->eof(), "      eof()";
+                    ok $gz->close(), "    close() ok"
+                        or diag "errno $!\n" ;
+
+                    is $gz->streamCount(), $i +1, "    streamCount ok " .  ($i +1)
+                        or diag "Stream count is " . $gz->streamCount();
+                    ok $un eq join('', @buffs), "    expected output" ;
+
+                }
+
+                foreach my $unc ($UncompressClass, 'IO::Uncompress::AnyUncompress') {
+                    title "  Testing $CompressClass with $unc nextStream and $i streams, from $fb";
+                    $cc = $output ;
+                    if ($fb eq 'filehandle')
+                    {
+                        $cc = new IO::File "<$name" ;
+                    }
+                    my @opts = $unc ne $UncompressClass 
+                                    ? (RawInflate => 1)
+                                    : ();
+                    my $gz = new $unc($cc,
+                                   @opts,
+                                   Strict      => 1,
+                                   AutoClose   => 1,
+                                   Append      => 1,
+                                   MultiStream => 0,
+                                   Transparent => 0)
+                        or diag $$UnError;
+                    isa_ok $gz, $UncompressClass, '    $gz' ;
+
+                    for my $stream (1 .. $i)
+                    {
+                        my $buff = $buffs[$stream-1];
+                        my @lines = split("\n", $buff);
+                        my $lines = @lines;
+
+                        my $un = '';
+                        #while (<$gz>) {
+                        while ($_ = $gz->getline()) {
+                            $un .= $_;
+                        }
+                        is $., $lines, "    \$. is $lines";
+                        
+                        ok ! $gz->error(), "      ! error()"
+                            or diag "Error is " . $gz->error() ;
+                        ok $gz->eof(), "      eof()";
+                        is $gz->streamCount(), $stream, "    streamCount is $stream"
+                            or diag "Stream count is " . $gz->streamCount();
+                        ok $un eq $buff, "    expected output" ;
+                        #is $gz->tell(), length $buff, "    tell is ok";
+                        is $gz->nextStream(), 1, "    nextStream ok";
+                        is $gz->tell(), 0, "    tell is 0";
+                        is $., 0, '    $. is 0';
+                    }
+
+                    {
+                        my $un = '';
+                        #1 while $gz->read($un) > 0 ;
+                        is $., 0, "    \$. is 0";
+                        $gz->read($un) ;
+                        #print "[[$un]]\n" while $gz->read($un) > 0 ;
+                        ok ! $gz->error(), "      ! error()"
+                            or diag "Error is " . $gz->error() ;
+                        ok $gz->eof(), "      eof()";
+                        is $gz->streamCount(), $i+1, "    streamCount is ok"
+                            or diag "Stream count is " . $gz->streamCount();
+                        ok $un eq "", "    expected output" ;
+                        is $gz->tell(), 0, "    tell is 0";
+                    }
+
+                    is $gz->nextStream(), 0, "    nextStream ok";
+                    ok $gz->eof(), "      eof()";
+                    ok $gz->close(), "    close() ok"
+                        or diag "errno $!\n" ;
+
+                    is $gz->streamCount(), $i +1, "    streamCount ok"
+                        or diag "Stream count is " . $gz->streamCount();
+
+                }
+            }
+        }
+    }
+}
+
+
+# corrupt one of the streams - all previous should be ok
+# trailing stuff
+# check that "tell" works ok
+
+1;
diff -urN perl-5.10.0/ext/IO_Compress_Base/t.xxx/compress/newtied.pl perl-5.10.0/ext/IO_Compress_Base/t/compress/newtied.pl
--- perl-5.10.0/ext/IO_Compress_Base/t.xxx/compress/newtied.pl	1970-01-01 01:00:00.000000000 +0100
+++ perl-5.10.0/ext/IO_Compress_Base/t/compress/newtied.pl	2008-09-03 15:57:30.000000000 +0200
@@ -0,0 +1,374 @@
+use lib 't';
+use strict;
+use warnings;
+use bytes;
+
+use Test::More ;
+use CompTestUtils;
+
+our ($BadPerl, $UncompressClass);
+ 
+BEGIN 
+{ 
+    plan(skip_all => "Extra Tied Filehandle needs Perl 5.6 or better - you have Perl $]" )
+        if $] < 5.006 ;
+     
+    my $tests ;
+
+    $BadPerl = ($] >= 5.006 and $] <= 5.008) ;
+
+    if ($BadPerl) {
+        $tests = 78 ;
+    }
+    else {
+        $tests = 84 ;
+    }
+
+    # use Test::NoWarnings, if available
+    my $extra = 0 ;
+    $extra = 1
+        if eval { require Test::NoWarnings ;  import Test::NoWarnings; 1 };
+
+    plan tests => $tests + $extra ;
+
+}
+
+
+use IO::Handle qw(SEEK_SET SEEK_CUR SEEK_END);
+
+
+
+sub myGZreadFile
+{
+    my $filename = shift ;
+    my $init = shift ;
+
+
+    my $fil = new $UncompressClass $filename,
+                                    -Strict   => 1,
+                                    -Append   => 1
+                                    ;
+
+    my $data ;
+    $data = $init if defined $init ;
+    1 while $fil->read($data) > 0;
+
+    $fil->close ;
+    return $data ;
+}
+
+
+sub run
+{
+
+    my $CompressClass   = identify();
+    $UncompressClass = getInverse($CompressClass);
+    my $Error           = getErrorRef($CompressClass);
+    my $UnError         = getErrorRef($UncompressClass);
+
+    {
+        title "Testing $CompressClass and $UncompressClass";
+
+
+
+        {
+            # Write
+            # these tests come almost 100% from IO::String
+
+            my $lex = new LexFile my $name ;
+
+            my $io = $CompressClass->new($name);
+
+            is tell($io), 0 ;
+            is $io->tell(), 0 ;
+
+            my $heisan = "Heisan\n";
+            print $io $heisan ;
+
+            ok ! eof($io);
+            ok ! $io->eof();
+
+            is tell($io), length($heisan) ;
+            is $io->tell(), length($heisan) ;
+
+            $io->print("a", "b", "c");
+
+            {
+                local($\) = "\n";
+                print $io "d", "e";
+                local($,) = ",";
+                print $io "f", "g", "h";
+            }
+
+            my $foo = "1234567890";
+            
+            ok syswrite($io, $foo, length($foo)) == length($foo) ;
+            if ( $] < 5.6 )
+              { is $io->syswrite($foo, length $foo), length $foo }
+            else
+              { is $io->syswrite($foo), length $foo }
+            ok $io->syswrite($foo, length($foo)) == length $foo;
+            ok $io->write($foo, length($foo), 5) == 5;
+            ok $io->write("xxx\n", 100, -1) == 1;
+
+            for (1..3) {
+                printf $io "i(%d)", $_;
+                $io->printf("[%d]\n", $_);
+            }
+            select $io;
+            print "\n";
+            select STDOUT;
+
+            close $io ;
+
+            ok eof($io);
+            ok $io->eof();
+
+            is myGZreadFile($name), "Heisan\nabcde\nf,g,h\n" .
+                                    ("1234567890" x 3) . "67890\n" .
+                                        "i(1)[1]\ni(2)[2]\ni(3)[3]\n\n";
+
+
+        }
+
+        {
+            # Read
+            my $str = <<EOT;
+This is an example
+of a paragraph
+
+
+and a single line.
+
+EOT
+
+            my $lex = new LexFile my $name ;
+
+            my $iow = new $CompressClass $name ;
+            print $iow $str ;
+            close $iow;
+
+            my @tmp;
+            my $buf;
+            {
+                my $io = new $UncompressClass $name ;
+            
+                ok ! $io->eof;
+                ok ! eof $io;
+                is $io->tell(), 0 ;
+                is tell($io), 0 ;
+                my @lines = <$io>;
+                is @lines, 6
+                    or print "# Got " . scalar(@lines) . " lines, expected 6\n" ;
+                is $lines[1], "of a paragraph\n" ;
+                is join('', @lines), $str ;
+                is $., 6; 
+        #print "TELL says " . tell($io) , " should be ${ \length($str) }\n" ;
+                is $io->tell(), length($str) ;
+                is tell($io), length($str) ;
+            
+                ok $io->eof;
+                ok eof $io;
+
+                ok ! ( defined($io->getline)  ||
+                          (@tmp = $io->getlines) ||
+                          defined(<$io>)         ||
+                          defined($io->getc)     ||
+                          read($io, $buf, 100)   != 0) ;
+            }
+            
+            
+            {
+                local $/;  # slurp mode
+                my $io = $UncompressClass->new($name);
+                ok ! $io->eof;
+                my @lines = $io->getlines;
+                ok $io->eof;
+                ok @lines == 1 && $lines[0] eq $str;
+            
+                $io = $UncompressClass->new($name);
+                ok ! $io->eof;
+                my $line = <$io>;
+                ok $line eq $str;
+                ok $io->eof;
+            }
+            
+            {
+                local $/ = "";  # paragraph mode
+                my $io = $UncompressClass->new($name);
+                ok ! $io->eof;
+                my @lines = <$io>;
+                ok $io->eof;
+                ok @lines == 2 
+                    or print "# Got " . scalar(@lines) . " lines, expected 2\n" ;
+                ok $lines[0] eq "This is an example\nof a paragraph\n\n\n"
+                    or print "# $lines[0]\n";
+                ok $lines[1] eq "and a single line.\n\n";
+            }
+            
+            {
+                local $/ = "is";
+                my $io = $UncompressClass->new($name);
+                my @lines = ();
+                my $no = 0;
+                my $err = 0;
+                ok ! $io->eof;
+                while (<$io>) {
+                    push(@lines, $_);
+                    $err++ if $. != ++$no;
+                }
+            
+                ok $err == 0 ;
+                ok $io->eof;
+            
+                ok @lines == 3 
+                    or print "# Got " . scalar(@lines) . " lines, expected 3\n" ;
+                ok join("-", @lines) eq
+                                 "This- is- an example\n" .
+                                "of a paragraph\n\n\n" .
+                                "and a single line.\n\n";
+            }
+            
+            
+            # Test read
+            
+            {
+                my $io = $UncompressClass->new($name);
+
+                ok $io, "opened ok" ;
+            
+                #eval { read($io, $buf, -1); } ;
+                #like $@, mkErr("length parameter is negative"), "xxx $io $UncompressClass $RawInflateError" ;
+
+                #eval { read($io, 1) } ;
+                #like $@, mkErr("buffer parameter is read-only");
+
+                is read($io, $buf, 0), 0, "Requested 0 bytes" ;
+
+                ok read($io, $buf, 3) == 3 ;
+                ok $buf eq "Thi";
+            
+                ok sysread($io, $buf, 3, 2) == 3 ;
+                ok $buf eq "Ths i"
+                    or print "# [$buf]\n" ;;
+                ok ! $io->eof;
+            
+        #        $io->seek(-4, 2);
+        #    
+        #        ok ! $io->eof;
+        #    
+        #        ok read($io, $buf, 20) == 4 ;
+        #        ok $buf eq "e.\n\n";
+        #    
+        #        ok read($io, $buf, 20) == 0 ;
+        #        ok $buf eq "";
+        #   
+        #        ok ! $io->eof;
+            }
+
+        }
+
+
+
+        {
+            title "seek tests" ;
+
+            my $lex = new LexFile my $name ;
+
+            my $first = "beginning" ;
+            my $last  = "the end" ;
+            my $iow = new $CompressClass $name ;
+            print $iow $first ;
+            ok seek $iow, 10, SEEK_CUR ;
+            is tell($iow), length($first)+10;
+            ok $iow->seek(0, SEEK_CUR) ;
+            is tell($iow), length($first)+10;
+            print $iow $last ;
+            close $iow;
+
+            my $io = $UncompressClass->new($name);
+            ok myGZreadFile($name) eq $first . "\x00" x 10 . $last ;
+
+            $io = $UncompressClass->new($name);
+            ok seek $io, length($first)+10, SEEK_CUR ;
+            ok ! $io->eof;
+            is tell($io), length($first)+10;
+            ok seek $io, 0, SEEK_CUR ;
+            is tell($io), length($first)+10;
+            my $buff ;
+            ok read $io, $buff, 100 ;
+            ok $buff eq $last ;
+            ok $io->eof;
+        }
+
+        if (! $BadPerl)
+        {
+            # seek error cases
+            my $b ;
+            my $a = new $CompressClass(\$b)  ;
+
+            ok ! $a->error() ;
+            eval { seek($a, -1, 10) ; };
+            like $@, mkErr("seek: unknown value, 10, for whence parameter");
+
+            eval { seek($a, -1, SEEK_END) ; };
+            like $@, mkErr("cannot seek backwards");
+
+            print $a "fred";
+            close $a ;
+
+
+            my $u = new $UncompressClass(\$b)  ;
+
+            eval { seek($u, -1, 10) ; };
+            like $@, mkErr("seek: unknown value, 10, for whence parameter");
+
+            eval { seek($u, -1, SEEK_END) ; };
+            like $@, mkErr("seek: SEEK_END not allowed");
+
+            eval { seek($u, -1, SEEK_CUR) ; };
+            like $@, mkErr("cannot seek backwards");
+        }
+
+        {
+            title 'fileno' ;
+
+            my $lex = new LexFile my $name ;
+
+            my $hello = <<EOM ;
+hello world
+this is a test
+EOM
+
+            {
+              my $fh ;
+              ok $fh = new IO::File ">$name" ;
+              my $x ;
+              ok $x = new $CompressClass $fh  ;
+
+              ok $x->fileno() == fileno($fh) ;
+              ok $x->fileno() == fileno($x) ;
+              ok $x->write($hello) ;
+              ok $x->close ;
+              $fh->close() ;
+            }
+
+            my $uncomp;
+            {
+              my $x ;
+              ok my $fh1 = new IO::File "<$name" ;
+              ok $x = new $UncompressClass $fh1, -Append => 1  ;
+              ok $x->fileno() == fileno $fh1 ;
+              ok $x->fileno() == fileno $x ;
+
+              1 while $x->read($uncomp) > 0 ;
+
+              ok $x->close ;
+            }
+
+            ok $hello eq $uncomp ;
+        }
+    }
+}
+
+1;
diff -urN perl-5.10.0/ext/IO_Compress_Base/t.xxx/compress/oneshot.pl perl-5.10.0/ext/IO_Compress_Base/t/compress/oneshot.pl
--- perl-5.10.0/ext/IO_Compress_Base/t.xxx/compress/oneshot.pl	1970-01-01 01:00:00.000000000 +0100
+++ perl-5.10.0/ext/IO_Compress_Base/t/compress/oneshot.pl	2008-09-03 15:57:30.000000000 +0200
@@ -0,0 +1,1560 @@
+use lib 't';
+use strict;
+use warnings;
+use bytes;
+
+use Test::More ;
+use CompTestUtils;
+
+BEGIN {
+    plan(skip_all => "oneshot needs Perl 5.005 or better - you have Perl $]" )
+        if $] < 5.005 ;
+
+
+    # use Test::NoWarnings, if available
+    my $extra = 0 ;
+    $extra = 1
+        if eval { require Test::NoWarnings ;  import Test::NoWarnings; 1 };
+
+    plan tests => 970 + $extra ;
+
+    use_ok('IO::Uncompress::AnyUncompress', qw(anyuncompress $AnyUncompressError)) ;
+
+}
+
+sub run
+{
+
+    my $CompressClass   = identify();
+    my $UncompressClass = getInverse($CompressClass);
+    my $Error           = getErrorRef($CompressClass);
+    my $UnError         = getErrorRef($UncompressClass);
+    my $TopFuncName     = getTopFuncName($CompressClass);
+
+
+    my @MultiValues     = getMultiValues($CompressClass);
+
+    foreach my $bit ($CompressClass, $UncompressClass,
+                     'IO::Uncompress::AnyUncompress',
+                    )
+    {
+        my $Error = getErrorRef($bit);
+        my $Func = getTopFuncRef($bit);
+        my $TopType = getTopFuncName($bit);
+
+        title "Testing $TopType Error Cases";
+
+        my $a;
+        my $x ;
+
+        eval { $a = $Func->(\$a => \$x, Fred => 1) ;} ;
+        like $@, mkErr("^$TopType: unknown key value\\(s\\) Fred"), '  Illegal Parameters';
+
+        eval { $a = $Func->() ;} ;
+        like $@, "/^$TopType: expected at least 1 parameters/", '  No Parameters';
+
+        eval { $a = $Func->(\$x, \1) ;} ;
+        like $$Error, "/^$TopType: output buffer is read-only/", '  Output is read-only' ;
+
+        my $in ;
+        eval { $a = $Func->($in, \$x) ;} ;
+        like $@, mkErr("^$TopType: input filename is undef or null string"), 
+            '  Input filename undef' ;
+
+        $in = '';    
+        eval { $a = $Func->($in, \$x) ;} ;
+        like $@, mkErr("^$TopType: input filename is undef or null string"), 
+            '  Input filename empty' ;
+
+        {
+            my $lex1 = new LexFile my $in ;
+            writeFile($in, "abc");
+            my $out = $in ;
+            eval { $a = $Func->($in, $out) ;} ;
+            like $@, mkErr("^$TopType: input and output filename are identical"),
+                '  Input and Output filename are the same';
+        }
+
+        {
+            my $dir = "tmpdir";
+            my $lex = new LexDir $dir ;
+            mkdir $dir, 0777 ;
+
+            $a = $Func->($dir, \$x) ;
+            is $a, undef, "  $TopType returned undef";
+            like $$Error, "/input file '$dir' is a directory/",
+                '  Input filename is a directory';
+
+            $a = $Func->(\$x, $dir) ;
+            is $a, undef, "  $TopType returned undef";
+            like $$Error, "/output file '$dir' is a directory/",
+                '  Output filename is a directory';
+        }
+
+        eval { $a = $Func->(\$in, \$in) ;} ;
+        like $@, mkErr("^$TopType: input and output buffer are identical"),
+            '  Input and Output buffer are the same';
+            
+        SKIP:
+        {
+            # Threaded 5.6.x seems to have a problem comparing filehandles.
+            use Config;
+
+            skip 'Cannot compare filehandles with threaded $]', 2
+                if $] >= 5.006  && $] < 5.007 && $Config{useithreads};
+
+            my $lex = new LexFile my $out_file ;
+            open OUT, ">$out_file" ;
+            eval { $a = $Func->(\*OUT, \*OUT) ;} ;
+            like $@, mkErr("^$TopType: input and output handle are identical"),
+                '  Input and Output handle are the same';
+                
+            close OUT;
+            is -s $out_file, 0, "  File zero length" ;
+        }
+
+        {
+            my %x = () ;
+            my $object = bless \%x, "someClass" ;
+
+            # Buffer not a scalar reference
+            #eval { $a = $Func->(\$x, \%x) ;} ;
+            eval { $a = $Func->(\$x, $object) ;} ;
+            like $@, mkErr("^$TopType: illegal output parameter"),
+                '  Bad Output Param';
+                
+            # Buffer not a scalar reference
+            eval { $a = $Func->(\$x, \%x) ;} ;
+            like $@, mkErr("^$TopType: illegal output parameter"),
+                '  Bad Output Param';
+                
+
+            eval { $a = $Func->(\%x, \$x) ;} ;
+            like $@, mkErr("^$TopType: illegal input parameter"),
+                '  Bad Input Param';
+
+            #eval { $a = $Func->(\%x, \$x) ;} ;
+            eval { $a = $Func->($object, \$x) ;} ;
+            like $@, mkErr("^$TopType: illegal input parameter"),
+                '  Bad Input Param';
+        }
+
+        my $filename = 'abc.def';
+        ok ! -e $filename, "  input file '$filename' does not exist";
+        $a = $Func->($filename, \$x) ;
+        is $a, undef, "  $TopType returned undef";
+        like $$Error, "/^input file '$filename' does not exist\$/", "  input File '$filename' does not exist";
+            
+        $filename = '/tmp/abd/abc.def';
+        ok ! -e $filename, "  output File '$filename' does not exist";
+        $a = $Func->(\$x, $filename) ;
+        is $a, undef, "  $TopType returned undef";
+        like $$Error, ("/^(cannot open file '$filename'|input file '$filename' does not exist):/"), "  output File '$filename' does not exist";
+            
+        eval { $a = $Func->(\$x, '<abc>') } ;
+        like $$Error, "/Need input fileglob for outout fileglob/",
+                '  Output fileglob with no input fileglob';
+        is $a, undef, "  $TopType returned undef";
+
+        $a = $Func->('<abc)>', '<abc>') ;
+        is $a, undef, "  $TopType returned undef";
+        like $$Error, "/Unmatched \\) in input fileglob/",
+                "  Unmatched ) in input fileglob";
+    }
+
+    foreach my $bit ($UncompressClass,
+                     'IO::Uncompress::AnyUncompress',
+                    )
+    {
+        my $Error = getErrorRef($bit);
+        my $Func = getTopFuncRef($bit);
+        my $TopType = getTopFuncName($bit);
+
+        {
+            my $in ;
+            my $out ;
+            my @x ;
+
+            SKIP:
+            {
+                use Config;
+
+                skip 'readonly + threads', 1
+                    if $Config{useithreads};
+
+                
+                eval { $a = $Func->(\$in, \$out, TrailingData => \"abc") ;} ;
+                like $@, mkErr("^$TopType: Parameter 'TrailingData' not writable"),
+                    '  TrailingData output not writable';
+            }
+
+            eval { $a = $Func->(\$in, \$out, TrailingData => \@x) ;} ;
+            like $@, mkErr("^$TopType: Parameter 'TrailingData' not a scalar reference"),
+                '  TrailingData output not scaral reference';
+        }
+    }
+
+    foreach my $bit ($UncompressClass,
+                     'IO::Uncompress::AnyUncompress',
+                    )
+    {
+        my $Error = getErrorRef($bit);
+        my $Func = getTopFuncRef($bit);
+        my $TopType = getTopFuncName($bit);
+
+        my $data = "mary had a little lamb" ;
+        my $keep = $data ;
+
+        for my $trans ( 0, 1)
+        {
+            title "Non-compressed data with $TopType, Transparent => $trans ";
+            my $a;
+            my $x ;
+            my $out = '' ;
+
+            $a = $Func->(\$data, \$out, Transparent => $trans) ;
+
+            is $data, $keep, "  Input buffer not changed" ;
+
+            if ($trans)
+            {
+                ok $a, "  $TopType returned true" ;
+                is $out, $data, "  got expected output" ;
+                ok ! $$Error, "  no error [$$Error]" ;
+            }
+            else
+            {
+                ok ! $a, "  $TopType returned false" ;
+                #like $$Error, '/xxx/', "  error" ;
+                ok $$Error, "  error is '$$Error'" ;
+            }
+        }
+    }
+
+    foreach my $bit ($CompressClass
+                    )
+    {
+        my $Error = getErrorRef($bit);
+        my $Func = getTopFuncRef($bit);
+        my $TopType = getTopFuncName($bit);
+        my $TopTypeInverse = getInverse($bit);
+        my $FuncInverse = getTopFuncRef($TopTypeInverse);
+        my $ErrorInverse = getErrorRef($TopTypeInverse);
+
+        title "$TopTypeInverse - corrupt data";
+
+        my $data = "abcd" x 100 ;
+        my $out;
+
+        ok $Func->(\$data, \$out), "  $TopType ok";
+
+        # corrupt the compressed data
+        #substr($out, -10, 10) = "x" x 10 ;
+        substr($out, int(length($out)/3), 10) = 'abcdeabcde';
+
+        my $result;
+        ok ! $FuncInverse->(\$out => \$result, Transparent => 0), "  $TopTypeInverse ok";
+        ok $$ErrorInverse, "  Got error '$$ErrorInverse'" ;
+
+        #is $result, $data, "  data ok";
+
+        ok ! anyuncompress(\$out => \$result, Transparent => 0), "anyuncompress ok";
+        ok $AnyUncompressError, "  Got error '$AnyUncompressError'" ;
+    }
+
+
+    foreach my $bit ($CompressClass
+                    )
+    {
+        my $Error = getErrorRef($bit);
+        my $Func = getTopFuncRef($bit);
+        my $TopType = getTopFuncName($bit);
+        my $TopTypeInverse = getInverse($bit);
+        my $FuncInverse = getTopFuncRef($TopTypeInverse);
+
+        my @opts = ();
+        @opts = (RawInflate => 1)
+            if $CompressClass eq 'IO::Compress::RawInflate';
+
+        for my $append ( 1, 0 )
+        {
+            my $already = '';
+            $already = 'abcde' if $append ;
+
+            for my $buffer ( undef, '', "abcde" )
+            {
+
+                my $disp_content = defined $buffer ? $buffer : '<undef>' ;
+
+                my $keep = $buffer;
+                my $out_file = "abcde.out";
+                my $in_file = "abcde.in";
+
+                {
+                    title "$TopType - From Buff to Buff content '$disp_content' Append $append" ;
+
+                    my $output = $already;
+                    ok &$Func(\$buffer, \$output, Append => $append), '  Compressed ok' ;
+
+                    is $keep, $buffer, "  Input buffer not changed" ;
+                    my $got = anyUncompress(\$output, $already);
+                    $got = undef if ! defined $buffer && $got eq '' ;
+                    is $got, $buffer, "  Uncompressed matches original";
+
+                }
+
+                {
+                    title "$TopType - From Buff to Array Ref content '$disp_content' Append $append" ;
+
+                    my @output = ('first') ;
+                    ok &$Func(\$buffer, \@output, Append => $append), '  Compressed ok' ;
+
+                    is $output[0], 'first', "  Array[0] unchanged";
+                    is $keep, $buffer, "  Input buffer not changed" ;
+                    my $got = anyUncompress($output[1]);
+                    $got = undef if ! defined $buffer && $got eq '' ;
+                    is $got, $buffer, "  Uncompressed matches original";
+                }
+
+                {
+                    title "$TopType - From Array Ref to Array Ref content '$disp_content' Append $append" ;
+
+                    my $lex = new LexFile my $in_file ;
+                    writeFile($in_file, $buffer);
+                    my @output = ('first') ;
+                    my @input = ($in_file);
+                    ok &$Func(\@input, \@output, Append => $append), '  Compressed ok' ;
+
+                    is $output[0], 'first', "  Array[0] unchanged";
+                    my $got = anyUncompress($output[1]);
+                    $got = undef if ! defined $buffer && $got eq '' ;
+                    is $got, $buffer, "  Uncompressed matches original";
+                }
+
+                {
+                    title "$TopType - From Buff to Filename content '$disp_content' Append $append" ;
+
+                    my $lex = new LexFile my $out_file ;
+                    ok ! -e $out_file, "  Output file does not exist";
+                    writeFile($out_file, $already);
+
+                    ok &$Func(\$buffer, $out_file, Append => $append), '  Compressed ok' ;
+
+                    ok -e $out_file, "  Created output file";
+                    my $got = anyUncompress($out_file, $already);
+                    $got = undef if ! defined $buffer && $got eq '' ;
+                    is $got, $buffer, "  Uncompressed matches original";
+                }
+
+                {
+                    title "$TopType - From Buff to Handle content '$disp_content' Append $append" ;
+
+                    my $lex = new LexFile my $out_file ;
+
+                    ok ! -e $out_file, "  Output file does not exist";
+                    writeFile($out_file, $already);
+                    my $of = new IO::File ">>$out_file" ;
+                    ok $of, "  Created output filehandle" ;
+
+                    ok &$Func(\$buffer, $of, AutoClose => 1, Append => $append), '  Compressed ok' ;
+
+                    ok -e $out_file, "  Created output file";
+                    my $got = anyUncompress($out_file, $already);
+                    $got = undef if ! defined $buffer && $got eq '' ;
+                    is $got, $buffer, "  Uncompressed matches original";
+                }
+
+
+                {
+                    title "$TopType - From Filename to Filename content '$disp_content' Append $append" ;
+
+                    my $lex = new LexFile(my $in_file, my $out_file) ;
+                    writeFile($in_file, $buffer);
+
+                    ok ! -e $out_file, "  Output file does not exist";
+                    writeFile($out_file, $already);
+
+                    ok &$Func($in_file => $out_file, Append => $append), '  Compressed ok' ;
+
+                    ok -e $out_file, "  Created output file";
+                    my $got = anyUncompress($out_file, $already);
+                    $got = undef if ! defined $buffer && $got eq '' ;
+                    is $got, $buffer, "  Uncompressed matches original";
+
+                }
+
+                {
+                    title "$TopType - From Filename to Handle content '$disp_content' Append $append" ;
+
+                    my $lex = new LexFile(my $in_file, my $out_file) ;
+                    writeFile($in_file, $buffer);
+
+                    ok ! -e $out_file, "  Output file does not exist";
+                    writeFile($out_file, $already);
+                    my $out = new IO::File ">>$out_file" ;
+
+                    ok &$Func($in_file, $out, AutoClose => 1, Append => $append), '  Compressed ok' ;
+
+                    ok -e $out_file, "  Created output file";
+                    my $got = anyUncompress($out_file, $already);
+                    $got = undef if ! defined $buffer && $got eq '' ;
+                    is $got, $buffer, "  Uncompressed matches original";
+
+                }
+
+                {
+                    title "$TopType - From Filename to Buffer content '$disp_content' Append $append" ;
+
+                    my $lex = new LexFile(my $in_file, my $out_file) ;
+                    writeFile($in_file, $buffer);
+
+                    my $out = $already;
+
+                    ok &$Func($in_file => \$out, Append => $append), '  Compressed ok' ;
+
+                    my $got = anyUncompress(\$out, $already);
+                    $got = undef if ! defined $buffer && $got eq '' ;
+                    is $got, $buffer, "  Uncompressed matches original";
+
+                }
+                
+                {
+                    title "$TopType - From Handle to Filename content '$disp_content' Append $append" ;
+
+                    my $lex = new LexFile(my $in_file, my $out_file) ;
+                    writeFile($in_file, $buffer);
+                    my $in = new IO::File "<$in_file" ;
+
+                    ok ! -e $out_file, "  Output file does not exist";
+                    writeFile($out_file, $already);
+
+                    ok &$Func($in, $out_file, Append => $append), '  Compressed ok' 
+                        or diag "error is $$Error" ;
+
+                    ok -e $out_file, "  Created output file";
+                    my $got = anyUncompress($out_file, $already);
+                    $got = undef if ! defined $buffer && $got eq '' ;
+                    is $buffer, $got, "  Uncompressed matches original";
+
+                }
+
+                {
+                    title "$TopType - From Handle to Handle content '$disp_content' Append $append" ;
+
+                    my $lex = new LexFile(my $in_file, my $out_file) ;
+                    writeFile($in_file, $buffer);
+                    my $in = new IO::File "<$in_file" ;
+
+                    ok ! -e $out_file, "  Output file does not exist";
+                    writeFile($out_file, $already);
+                    my $out = new IO::File ">>$out_file" ;
+
+                    ok &$Func($in, $out, AutoClose => 1, Append => $append), '  Compressed ok' ;
+
+                    ok -e $out_file, "  Created output file";
+                    my $got = anyUncompress($out_file, $already);
+                    $got = undef if ! defined $buffer && $got eq '' ;
+                    is $buffer, $got, "  Uncompressed matches original";
+
+                }
+
+                {
+                    title "$TopType - From Handle to Buffer content '$disp_content' Append $append" ;
+
+                    my $lex = new LexFile(my $in_file, my $out_file) ;
+                    writeFile($in_file, $buffer);
+                    my $in = new IO::File "<$in_file" ;
+
+                    my $out = $already ;
+
+                    ok &$Func($in, \$out, Append => $append), '  Compressed ok' ;
+
+                    my $got = anyUncompress(\$out, $already);
+                    $got = undef if ! defined $buffer && $got eq '' ;
+                    is $buffer, $got, "  Uncompressed matches original";
+
+                }
+
+                {
+                    title "$TopType - From stdin (via '-') to Buffer content '$disp_content' Append $append" ;
+
+                    my $lex = new LexFile(my $in_file, my $out_file) ;
+                    writeFile($in_file, $buffer);
+
+                       open(SAVEIN, "<&STDIN");
+                    my $dummy = fileno SAVEIN ;
+                    ok open(STDIN, "<$in_file"), "  redirect STDIN";
+
+                    my $out = $already;
+
+                    ok &$Func('-', \$out, Append => $append), '  Compressed ok' 
+                        or diag $$Error ;
+
+                       open(STDIN, "<&SAVEIN");
+
+                    my $got = anyUncompress(\$out, $already);
+                    $got = undef if ! defined $buffer && $got eq '' ;
+                    is $buffer, $got, "  Uncompressed matches original";
+
+                }
+
+            }
+        }
+    }
+
+    foreach my $bit ($CompressClass)
+    {
+        my $Error = getErrorRef($bit);
+        my $Func = getTopFuncRef($bit);
+        my $TopType = getTopFuncName($bit);
+
+        my $TopTypeInverse = getInverse($bit);
+        my $FuncInverse = getTopFuncRef($TopTypeInverse);
+
+        my $lex = new LexFile(my $file1, my $file2) ;
+
+        writeFile($file1, "data1");
+        writeFile($file2, "data2");
+        my $of = new IO::File "<$file1" ;
+        ok $of, "  Created output filehandle" ;
+
+        #my @input = (   undef, "", $file2, \undef, \'', \"abcde", $of) ;
+        #my @expected = ("", "", $file2, "", "", "abcde", "data1");
+        #my @uexpected = ("", "", "data2", "", "", "abcde", "data1");
+        #my @input = (   $file2, \"abcde", $of) ;
+        #my @expected = ( $file2, "abcde", "data1");
+        #my @uexpected = ("data2", "abcde", "data1");
+
+        my @input = (   $file1, $file2) ;
+        #my @expected = ( $file1, $file2);
+        my @expected = ("data1", "data2");
+        my @uexpected = ("data1", "data2");
+
+        my @keep = @input ;
+
+        {
+            title "$TopType - From Array Ref to Array Ref" ;
+
+            my @output = ('first') ;
+            ok &$Func(\@input, \@output, AutoClose => 0), '  Compressed ok' ;
+
+            is $output[0], 'first', "  Array[0] unchanged";
+
+            is_deeply \@input, \@keep, "  Input array not changed" ;
+            my @got = shift @output;
+            foreach (@output) { push @got, anyUncompress($_) }
+
+            is_deeply \@got, ['first', @expected], "  Got Expected uncompressed data";
+
+        }
+
+        foreach my $ms (@MultiValues)
+        {
+            {
+                title "$TopType - From Array Ref to Buffer, MultiStream $ms" ;
+
+                # rewind the filehandle
+                $of->open("<$file1") ;
+
+                my $output  ;
+                ok &$Func(\@input, \$output, MultiStream => $ms, AutoClose => 0), '  Compressed ok' 
+                    or diag $$Error;
+
+                my $got = anyUncompress([ \$output, MultiStream => $ms ]);
+
+                is $got, join('', @uexpected), "  Got Expected uncompressed data";
+                my @headers = getHeaders(\$output);
+                is @headers, $ms ? @input : 1, "  Header count ok";
+            }
+
+            {
+                title "$TopType - From Array Ref to Filename, MultiStream $ms" ;
+
+                my $lex = new LexFile( my $file3) ;
+
+                # rewind the filehandle
+                $of->open("<$file1") ;
+
+                my $output  ;
+                ok &$Func(\@input, $file3, MultiStream => $ms, AutoClose => 0), '  Compressed ok' ;
+
+                my $got = anyUncompress([ $file3, MultiStream => $ms ]);
+
+                is $got, join('', @uexpected), "  Got Expected uncompressed data";
+                my @headers = getHeaders($file3);
+                is @headers, $ms ? @input : 1, "  Header count ok";
+            }
+
+            {
+                title "$TopType - From Array Ref to Filehandle, MultiStream $ms" ;
+
+                my $lex = new LexFile(my $file3) ;
+
+                my $fh3 = new IO::File ">$file3";
+
+                # rewind the filehandle
+                $of->open("<$file1") ;
+
+                my $output  ;
+                ok &$Func(\@input, $fh3, MultiStream => $ms, AutoClose => 0), '  Compressed ok' ;
+
+                $fh3->close();
+
+                my $got = anyUncompress([ $file3, MultiStream => $ms ]);
+
+                is $got, join('', @uexpected), "  Got Expected uncompressed data";
+                my @headers = getHeaders($file3);
+                is @headers, $ms ? @input : 1, "  Header count ok";
+            }
+        }
+    }
+
+    foreach my $bit ($UncompressClass,
+                    #'IO::Uncompress::AnyUncompress',
+                    )
+    {
+        my $Error = getErrorRef($bit);
+        my $Func = getTopFuncRef($bit);
+        my $TopType = getTopFuncName($bit);
+        my $CompressClass = getInverse($bit);
+        my $C_Func = getTopFuncRef($CompressClass);
+
+
+        
+        my $data = "mary had a little lamb" ;
+        my $keep = $data ;
+        my $extra = "after the main event";
+
+        foreach my $fb ( qw( filehandle buffer ) )
+        {
+            title "Trailingdata with $TopType, from $fb";
+
+            my $lex = new LexFile my $name ;
+            my $input ;
+
+            my $compressed ;
+            ok &$C_Func(\$data, \$compressed), '  Compressed ok' ;
+            $compressed .= $extra;
+
+            if ($fb eq 'buffer')
+            {
+                $input = \$compressed;
+            }
+            else
+            {
+                writeFile($name, $compressed);
+
+                $input = new IO::File "<$name" ;
+            }
+
+            my $trailing;
+            my $out;
+            ok $Func->($input, \$out, TrailingData => $trailing), "  Uncompressed OK" ;
+            is $out, $keep, "  Got uncompressed data";
+
+            my $rest = '';
+            if ($fb eq 'filehandle')
+            {
+                read($input, $rest, 10000) ;
+            }
+
+            is $trailing . $rest, $extra, "  Got trailing data";
+            
+        }
+    }
+
+
+#    foreach my $bit ($CompressClass)
+#    {
+#        my $Error = getErrorRef($bit);
+#        my $Func = getTopFuncRef($bit);
+#        my $TopType = getTopFuncName($bit);
+#
+#        my $TopTypeInverse = getInverse($bit);
+#        my $FuncInverse = getTopFuncRef($TopTypeInverse);
+#
+#        my @inFiles  = map { "in$_.tmp"  } 1..4;
+#        my @outFiles = map { "out$_.tmp" } 1..4;
+#        my $lex = new LexFile(@inFiles, @outFiles);
+#
+#        writeFile($_, "data $_") foreach @inFiles ;
+#        
+#        {
+#            title "$TopType - Hash Ref: to filename" ;
+#
+#            my $output ;
+#            ok &$Func( { $inFiles[0] => $outFiles[0],
+#                         $inFiles[1] => $outFiles[1],
+#                         $inFiles[2] => $outFiles[2] } ), '  Compressed ok' ;
+#
+#            foreach (0 .. 2)
+#            {
+#                my $got = anyUncompress($outFiles[$_]);
+#                is $got, "data $inFiles[$_]", "  Uncompressed $_ matches original";
+#            }
+#        }
+#
+#        {
+#            title "$TopType - Hash Ref: to buffer" ;
+#
+#            my @buffer ;
+#            ok &$Func( { $inFiles[0] => \$buffer[0],
+#                         $inFiles[1] => \$buffer[1],
+#                         $inFiles[2] => \$buffer[2] } ), '  Compressed ok' ;
+#
+#            foreach (0 .. 2)
+#            {
+#                my $got = anyUncompress(\$buffer[$_]);
+#                is $got, "data $inFiles[$_]", "  Uncompressed $_ matches original";
+#            }
+#        }
+#
+#        {
+#            title "$TopType - Hash Ref: to undef" ;
+#
+#            my @buffer ;
+#            my %hash = ( $inFiles[0] => undef,
+#                         $inFiles[1] => undef,
+#                         $inFiles[2] => undef, 
+#                     );  
+#
+#            ok &$Func( \%hash ), '  Compressed ok' ;
+#
+#            foreach (keys %hash)
+#            {
+#                my $got = anyUncompress(\$hash{$_});
+#                is $got, "data $_", "  Uncompressed $_ matches original";
+#            }
+#        }
+#
+#        {
+#            title "$TopType - Filename to Hash Ref" ;
+#
+#            my %output ;
+#            ok &$Func( $inFiles[0] => \%output), '  Compressed ok' ;
+#
+#            is keys %output, 1, "  one pair in hash" ;
+#            my ($k, $v) = each %output;
+#            is $k, $inFiles[0], "  key is '$inFiles[0]'";
+#            my $got = anyUncompress($v);
+#            is $got, "data $inFiles[0]", "  Uncompressed matches original";
+#        }
+#
+#        {
+#            title "$TopType - File Glob to Hash Ref" ;
+#
+#            my %output ;
+#            ok &$Func( '<in*.tmp>' => \%output), '  Compressed ok' ;
+#
+#            is keys %output, 4, "  four pairs in hash" ;
+#            foreach my $fil (@inFiles)
+#            {
+#                ok exists $output{$fil}, "  key '$fil' exists" ;
+#                my $got = anyUncompress($output{$fil});
+#                is $got, "data $fil", "  Uncompressed matches original";
+#            }
+#        }
+#
+#
+#    }
+
+#    foreach my $bit ($CompressClass)
+#    {
+#        my $Error = getErrorRef($bit);
+#        my $Func = getTopFuncRef($bit);
+#        my $TopType = getTopFuncName($bit);
+#
+#        my $TopTypeInverse = getInverse($bit);
+#        my $FuncInverse = getTopFuncRef($TopTypeInverse);
+#
+#        my @inFiles  = map { "in$_.tmp"  } 1..4;
+#        my @outFiles = map { "out$_.tmp" } 1..4;
+#        my $lex = new LexFile(@inFiles, @outFiles);
+#
+#        writeFile($_, "data $_") foreach @inFiles ;
+#        
+#
+#
+#    #    if (0)
+#    #    {
+#    #        title "$TopType - Hash Ref to Array Ref" ;
+#    #
+#    #        my @output = ('first') ;
+#    #        ok &$Func( { \@input, \@output } , AutoClose => 0), '  Compressed ok' ;
+#    #
+#    #        is $output[0], 'first', "  Array[0] unchanged";
+#    #
+#    #        is_deeply \@input, \@keep, "  Input array not changed" ;
+#    #        my @got = shift @output;
+#    #        foreach (@output) { push @got, anyUncompress($_) }
+#    #
+#    #        is_deeply \@got, ['first', @expected], "  Got Expected uncompressed data";
+#    #
+#    #    }
+#    #
+#    #    if (0)
+#    #    {
+#    #        title "$TopType - From Array Ref to Buffer" ;
+#    #
+#    #        # rewind the filehandle
+#    #        $of->open("<$file1") ;
+#    #
+#    #        my $output  ;
+#    #        ok &$Func(\@input, \$output, AutoClose => 0), '  Compressed ok' ;
+#    #
+#    #        my $got = anyUncompress(\$output);
+#    #
+#    #        is $got, join('', @expected), "  Got Expected uncompressed data";
+#    #    }
+#    #
+#    #    if (0)
+#    #    {
+#    #        title "$TopType - From Array Ref to Filename" ;
+#    #
+#    #        my ($file3) = ("file3");
+#    #        my $lex = new LexFile($file3) ;
+#    #
+#    #        # rewind the filehandle
+#    #        $of->open("<$file1") ;
+#    #
+#    #        my $output  ;
+#    #        ok &$Func(\@input, $file3, AutoClose => 0), '  Compressed ok' ;
+#    #
+#    #        my $got = anyUncompress($file3);
+#    #
+#    #        is $got, join('', @expected), "  Got Expected uncompressed data";
+#    #    }
+#    #
+#    #    if (0)
+#    #    {
+#    #        title "$TopType - From Array Ref to Filehandle" ;
+#    #
+#    #        my ($file3) = ("file3");
+#    #        my $lex = new LexFile($file3) ;
+#    #
+#    #        my $fh3 = new IO::File ">$file3";
+#    #
+#    #        # rewind the filehandle
+#    #        $of->open("<$file1") ;
+#    #
+#    #        my $output  ;
+#    #        ok &$Func(\@input, $fh3, AutoClose => 0), '  Compressed ok' ;
+#    #
+#    #        $fh3->close();
+#    #
+#    #        my $got = anyUncompress($file3);
+#    #
+#    #        is $got, join('', @expected), "  Got Expected uncompressed data";
+#    #    }
+#    }
+
+    foreach my $bit ($CompressClass
+                    )
+    {
+        my $Error = getErrorRef($bit);
+        my $Func = getTopFuncRef($bit);
+        my $TopType = getTopFuncName($bit);
+
+        for my $files ( [qw(a1)], [qw(a1 a2 a3)] )
+        {
+
+            my $tmpDir1 = 'tmpdir1';
+            my $tmpDir2 = 'tmpdir2';
+            my $lex = new LexDir($tmpDir1, $tmpDir2) ;
+
+            mkdir $tmpDir1, 0777;
+            mkdir $tmpDir2, 0777;
+
+            ok   -d $tmpDir1, "  Temp Directory $tmpDir1 exists";
+            #ok ! -d $tmpDir2, "  Temp Directory $tmpDir2 does not exist";
+
+            my @files = map { "$tmpDir1/$_.tmp" } @$files ;
+            foreach (@files) { writeFile($_, "abc $_") }
+
+            my @expected = map { "abc $_" } @files ;
+            my @outFiles = map { s/$tmpDir1/$tmpDir2/; $_ } @files ;
+
+            {
+                title "$TopType - From FileGlob to FileGlob files [@$files]" ;
+
+                ok &$Func("<$tmpDir1/a*.tmp>" => "<$tmpDir2/a#1.tmp>"), '  Compressed ok' 
+                    or diag $$Error ;
+
+                my @copy = @expected;
+                for my $file (@outFiles)
+                {
+                    is anyUncompress($file), shift @copy, "  got expected from $file" ;
+                }
+
+                is @copy, 0, "  got all files";
+            }
+
+            {
+                title "$TopType - From FileGlob to Array files [@$files]" ;
+
+                my @buffer = ('first') ;
+                ok &$Func("<$tmpDir1/a*.tmp>" => \@buffer), '  Compressed ok' 
+                    or diag $$Error ;
+
+                is shift @buffer, 'first';
+
+                my @copy = @expected;
+                for my $buffer (@buffer)
+                {
+                    is anyUncompress($buffer), shift @copy, "  got expected " ;
+                }
+
+                is @copy, 0, "  got all files";
+            }
+
+            foreach my $ms (@MultiValues)
+            {
+                {
+                    title "$TopType - From FileGlob to Buffer files [@$files], MS $ms" ;
+
+                    my $buffer ;
+                    ok &$Func("<$tmpDir1/a*.tmp>" => \$buffer, 
+                               MultiStream => $ms), '  Compressed ok' 
+                        or diag $$Error ;
+
+                    #hexDump(\$buffer);
+
+                    my $got = anyUncompress([ \$buffer, MultiStream => $ms ]);
+
+                    is $got, join("", @expected), "  got expected" ;
+                    my @headers = getHeaders(\$buffer);
+                    is @headers, $ms ? @files : 1, "  Header count ok";
+                }
+
+                {
+                    title "$TopType - From FileGlob to Filename files [@$files], MS $ms" ;
+
+                    my $filename = "abcde";
+                    my $lex = new LexFile($filename) ;
+                    
+                    ok &$Func("<$tmpDir1/a*.tmp>" => $filename,
+                              MultiStream => $ms), '  Compressed ok' 
+                        or diag $$Error ;
+
+                    #hexDump(\$buffer);
+
+                    my $got = anyUncompress([$filename, MultiStream => $ms]);
+
+                    is $got, join("", @expected), "  got expected" ;
+                    my @headers = getHeaders($filename);
+                    is @headers, $ms ? @files : 1, "  Header count ok";
+                }
+
+                {
+                    title "$TopType - From FileGlob to Filehandle files [@$files], MS $ms" ;
+
+                    my $filename = "abcde";
+                    my $lex = new LexFile($filename) ;
+                    my $fh = new IO::File ">$filename";
+                    
+                    ok &$Func("<$tmpDir1/a*.tmp>" => $fh, 
+                              MultiStream => $ms, AutoClose => 1), '  Compressed ok' 
+                        or diag $$Error ;
+
+                    #hexDump(\$buffer);
+
+                    my $got = anyUncompress([$filename, MultiStream => $ms]);
+
+                    is $got, join("", @expected), "  got expected" ;
+                    my @headers = getHeaders($filename);
+                    is @headers, $ms ? @files : 1, "  Header count ok";
+                }
+            }
+        }
+
+    }
+
+    foreach my $bit ($UncompressClass,
+                     'IO::Uncompress::AnyUncompress',
+                    )
+    {
+        my $Error = getErrorRef($bit);
+        my $Func = getTopFuncRef($bit);
+        my $TopType = getTopFuncName($bit);
+
+        my $buffer = "abcde" ;
+        my $buffer2 = "ABCDE" ;
+        my $keep_orig = $buffer;
+
+        my $comp = compressBuffer(getTopFuncName($UncompressClass), $buffer) ;
+        my $comp2 = compressBuffer(getTopFuncName($UncompressClass), $buffer2) ;
+        my $keep_comp = $comp;
+
+        my $incumbent = "incumbent data" ;
+
+        my @opts = (Strict => 1);
+        push @opts,  (RawInflate => 1)
+            if $bit eq 'IO::Uncompress::AnyUncompress';
+
+        for my $append (0, 1)
+        {
+            my $expected = $buffer ;
+            $expected = $incumbent . $buffer if $append ;
+
+            {
+                title "$TopType - From Buff to Buff, Append($append)" ;
+
+                my $output ;
+                $output = $incumbent if $append ;
+                ok &$Func(\$comp, \$output, Append => $append, @opts), '  Uncompressed ok' ;
+
+                is $keep_comp, $comp, "  Input buffer not changed" ;
+                is $output, $expected, "  Uncompressed matches original";
+            }
+
+            {
+                title "$TopType - From Buff to Array, Append($append)" ;
+
+                my @output = ('first');
+                #$output = $incumbent if $append ;
+                ok &$Func(\$comp, \@output, Append => $append, @opts), '  Uncompressed ok' ;
+
+                is $keep_comp, $comp, "  Input buffer not changed" ;
+                is $output[0], 'first', "  Uncompressed matches original";
+                is ${ $output[1] }, $buffer, "  Uncompressed matches original"
+                    or diag $output[1] ;
+                is @output, 2, "  only 2 elements in the array" ;
+            }
+
+            {
+                title "$TopType - From Buff to Filename, Append($append)" ;
+
+                my $lex = new LexFile(my $out_file) ;
+                if ($append)
+                  { writeFile($out_file, $incumbent) }
+                else
+                  { ok ! -e $out_file, "  Output file does not exist" }
+
+                ok &$Func(\$comp, $out_file, Append => $append, @opts), '  Uncompressed ok' ;
+
+                ok -e $out_file, "  Created output file";
+                my $content = readFile($out_file) ;
+
+                is $keep_comp, $comp, "  Input buffer not changed" ;
+                is $content, $expected, "  Uncompressed matches original";
+            }
+
+            {
+                title "$TopType - From Buff to Handle, Append($append)" ;
+
+                my $lex = new LexFile(my $out_file) ;
+                my $of ;
+                if ($append) {
+                    writeFile($out_file, $incumbent) ;
+                    $of = new IO::File "+< $out_file" ;
+                }
+                else {
+                    ok ! -e $out_file, "  Output file does not exist" ;
+                    $of = new IO::File "> $out_file" ;
+                }
+                isa_ok $of, 'IO::File', '  $of' ;
+
+                ok &$Func(\$comp, $of, Append => $append, AutoClose => 1, @opts), '  Uncompressed ok' ;
+
+                ok -e $out_file, "  Created output file";
+                my $content = readFile($out_file) ;
+
+                is $keep_comp, $comp, "  Input buffer not changed" ;
+                is $content, $expected, "  Uncompressed matches original";
+            }
+
+            {
+                title "$TopType - From Filename to Filename, Append($append)" ;
+
+                my $lex = new LexFile(my $in_file, my $out_file) ;
+                if ($append)
+                  { writeFile($out_file, $incumbent) }
+                else
+                  { ok ! -e $out_file, "  Output file does not exist" }
+
+                writeFile($in_file, $comp);
+
+                ok &$Func($in_file, $out_file, Append => $append, @opts), '  Uncompressed ok' ;
+
+                ok -e $out_file, "  Created output file";
+                my $content = readFile($out_file) ;
+
+                is $keep_comp, $comp, "  Input buffer not changed" ;
+                is $content, $expected, "  Uncompressed matches original";
+            }
+
+            {
+                title "$TopType - From Filename to Handle, Append($append)" ;
+
+                my $lex = new LexFile(my $in_file, my $out_file) ;
+                my $out ;
+                if ($append) {
+                    writeFile($out_file, $incumbent) ;
+                    $out = new IO::File "+< $out_file" ;
+                }
+                else {
+                    ok ! -e $out_file, "  Output file does not exist" ;
+                    $out = new IO::File "> $out_file" ;
+                }
+                isa_ok $out, 'IO::File', '  $out' ;
+
+                writeFile($in_file, $comp);
+
+                ok &$Func($in_file, $out, Append => $append, AutoClose => 1, @opts), '  Uncompressed ok' ;
+
+                ok -e $out_file, "  Created output file";
+                my $content = readFile($out_file) ;
+
+                is $keep_comp, $comp, "  Input buffer not changed" ;
+                is $content, $expected, "  Uncompressed matches original";
+            }
+
+            {
+                title "$TopType - From Filename to Buffer, Append($append)" ;
+
+                my $lex = new LexFile(my $in_file) ;
+                writeFile($in_file, $comp);
+
+                my $output ;
+                $output = $incumbent if $append ;
+
+                ok &$Func($in_file, \$output, Append => $append, @opts), '  Uncompressed ok' ;
+
+                is $keep_comp, $comp, "  Input buffer not changed" ;
+                is $output, $expected, "  Uncompressed matches original";
+            }
+
+            {
+                title "$TopType - From Handle to Filename, Append($append)" ;
+
+                my $lex = new LexFile(my $in_file, my $out_file) ;
+                if ($append)
+                  { writeFile($out_file, $incumbent) }
+                else
+                  { ok ! -e $out_file, "  Output file does not exist" }
+
+                writeFile($in_file, $comp);
+                my $in = new IO::File "<$in_file" ;
+
+                ok &$Func($in, $out_file, Append => $append, @opts), '  Uncompressed ok' ;
+
+                ok -e $out_file, "  Created output file";
+                my $content = readFile($out_file) ;
+
+                is $keep_comp, $comp, "  Input buffer not changed" ;
+                is $content, $expected, "  Uncompressed matches original";
+            }
+
+            {
+                title "$TopType - From Handle to Handle, Append($append)" ;
+
+                my $lex = new LexFile(my $in_file, my $out_file) ;
+                my $out ;
+                if ($append) {
+                    writeFile($out_file, $incumbent) ;
+                    $out = new IO::File "+< $out_file" ;
+                }
+                else {
+                    ok ! -e $out_file, "  Output file does not exist" ;
+                    $out = new IO::File "> $out_file" ;
+                }
+                isa_ok $out, 'IO::File', '  $out' ;
+
+                writeFile($in_file, $comp);
+                my $in = new IO::File "<$in_file" ;
+
+                ok &$Func($in, $out, Append => $append, AutoClose => 1, @opts), '  Uncompressed ok' ;
+
+                ok -e $out_file, "  Created output file";
+                my $content = readFile($out_file) ;
+
+                is $keep_comp, $comp, "  Input buffer not changed" ;
+                is $content, $expected, "  Uncompressed matches original";
+            }
+
+            {
+                title "$TopType - From Filename to Buffer, Append($append)" ;
+
+                my $lex = new LexFile(my $in_file) ;
+                writeFile($in_file, $comp);
+                my $in = new IO::File "<$in_file" ;
+
+                my $output ;
+                $output = $incumbent if $append ;
+
+                ok &$Func($in, \$output, Append => $append, @opts), '  Uncompressed ok' ;
+
+                is $keep_comp, $comp, "  Input buffer not changed" ;
+                is $output, $expected, "  Uncompressed matches original";
+            }
+
+            {
+                title "$TopType - From stdin (via '-') to Buffer content, Append($append) " ;
+
+                my $lex = new LexFile(my $in_file) ;
+                writeFile($in_file, $comp);
+
+                   open(SAVEIN, "<&STDIN");
+                my $dummy = fileno SAVEIN ;
+                ok open(STDIN, "<$in_file"), "  redirect STDIN";
+
+                my $output ;
+                $output = $incumbent if $append ;
+
+                ok &$Func('-', \$output, Append => $append, @opts), '  Uncompressed ok' 
+                    or diag $$Error ;
+
+                   open(STDIN, "<&SAVEIN");
+
+                is $keep_comp, $comp, "  Input buffer not changed" ;
+                is $output, $expected, "  Uncompressed matches original";
+            }
+        }
+
+        {
+            title "$TopType - From Handle to Buffer, InputLength" ;
+
+            my $lex = new LexFile(my $in_file, my $out_file) ;
+            my $out ;
+
+            my $expected = $buffer ;
+            my $appended = 'appended';
+            my $len_appended = length $appended;
+            writeFile($in_file, $comp . $appended . $comp . $appended) ;
+            my $in = new IO::File "<$in_file" ;
+
+            ok &$Func($in, \$out, Transparent => 0, InputLength => length $comp, @opts), '  Uncompressed ok' ;
+
+            is $out, $expected, "  Uncompressed matches original";
+
+            my $buff;
+            is $in->read($buff, $len_appended), $len_appended, "  Length of Appended data ok";
+            is $buff, $appended, "  Appended data ok";
+
+            $out = '';
+            ok &$Func($in, \$out, Transparent => 0, InputLength => length $comp, @opts), '  Uncompressed ok' ;
+
+            is $out, $expected, "  Uncompressed matches original";
+
+            $buff = '';
+            is $in->read($buff, $len_appended), $len_appended, "  Length of Appended data ok";
+            is $buff, $appended, "  Appended data ok";
+        }
+
+        for my $stdin ('-', *STDIN) # , \*STDIN)
+        {
+            title "$TopType - From stdin (via $stdin) to Buffer content, InputLength" ;
+
+            my $lex = new LexFile my $in_file ;
+            my $expected = $buffer ;
+            my $appended = 'appended';
+            my $len_appended = length $appended;
+            writeFile($in_file, $comp . $appended ) ;
+
+               open(SAVEIN, "<&STDIN");
+            my $dummy = fileno SAVEIN ;
+            ok open(STDIN, "<$in_file"), "  redirect STDIN";
+
+            my $output ;
+
+            ok &$Func($stdin, \$output, Transparent => 0, InputLength => length $comp, @opts), '  Uncompressed ok' 
+                or diag $$Error ;
+
+            my $buff ;
+            is read(STDIN, $buff, $len_appended), $len_appended, "  Length of Appended data ok";
+
+            is $output, $expected, "  Uncompressed matches original";
+            is $buff, $appended, "  Appended data ok";
+
+              open(STDIN, "<&SAVEIN");
+        }
+    }
+
+    foreach my $bit ($UncompressClass,
+                     'IO::Uncompress::AnyUncompress',
+                    )
+    {
+        # TODO -- Add Append mode tests
+
+        my $Error = getErrorRef($bit);
+        my $Func = getTopFuncRef($bit);
+        my $TopType = getTopFuncName($bit);
+
+        my $buffer = "abcde" ;
+        my $keep_orig = $buffer;
+
+        my $null = compressBuffer(getTopFuncName($UncompressClass), "") ;
+        my $undef = compressBuffer(getTopFuncName($UncompressClass), undef) ;
+        my $comp = compressBuffer(getTopFuncName($UncompressClass), $buffer) ;
+        my $keep_comp = $comp;
+
+        my @opts = ();
+        @opts = (RawInflate => 1)
+            if $bit eq 'IO::Uncompress::AnyUncompress';
+
+        my $incumbent = "incumbent data" ;
+
+        my $lex = new LexFile(my $file1, my $file2) ;
+
+        writeFile($file1, compressBuffer(getTopFuncName($UncompressClass),"data1"));
+        writeFile($file2, compressBuffer(getTopFuncName($UncompressClass),"data2"));
+
+        my $of = new IO::File "<$file1" ;
+        ok $of, "  Created output filehandle" ;
+
+        #my @input    = ($file2, \$undef, \$null, \$comp, $of) ;
+        #my @expected = ('data2', '',      '',    'abcde', 'data1');
+        my @input    = ($file1, $file2);
+        my @expected = ('data1', 'data2');
+
+        my @keep = @input ;
+
+        {
+            title "$TopType - From ArrayRef to Buffer" ;
+
+            my $output  ;
+            ok &$Func(\@input, \$output, AutoClose => 0, @opts), '  UnCompressed ok' ;
+
+            is $output, join('', @expected)
+        }
+
+        {
+            title "$TopType - From ArrayRef to Filename" ;
+
+            my $lex = new LexFile my $output;
+            $of->open("<$file1") ;
+
+            ok &$Func(\@input, $output, AutoClose => 0, @opts), '  UnCompressed ok' ;
+
+            is readFile($output), join('', @expected)
+        }
+
+        {
+            title "$TopType - From ArrayRef to Filehandle" ;
+
+            my $lex = new LexFile my $output;
+            my $fh = new IO::File ">$output" ;
+            $of->open("<$file1") ;
+
+            ok &$Func(\@input, $fh, AutoClose => 0, @opts), '  UnCompressed ok' ;
+            $fh->close;
+
+            is readFile($output), join('', @expected)
+        }
+
+        {
+            title "$TopType - From Array Ref to Array Ref" ;
+
+            my @output = (\'first') ;
+            $of->open("<$file1") ;
+            ok &$Func(\@input, \@output, AutoClose => 0, @opts), '  UnCompressed ok' ;
+
+            is_deeply \@input, \@keep, "  Input array not changed" ;
+            is_deeply [map { defined $$_ ? $$_ : "" } @output], 
+                      ['first', @expected], 
+                      "  Got Expected uncompressed data";
+
+        }
+    }
+
+    foreach my $bit ($UncompressClass,
+                     'IO::Uncompress::AnyUncompress',
+                    )
+    {
+        # TODO -- Add Append mode tests
+
+        my $Error = getErrorRef($bit);
+        my $Func = getTopFuncRef($bit);
+        my $TopType = getTopFuncName($bit);
+
+        my $tmpDir1 = 'tmpdir1';
+        my $tmpDir2 = 'tmpdir2';
+        my $lex = new LexDir($tmpDir1, $tmpDir2) ;
+
+        mkdir $tmpDir1, 0777;
+        mkdir $tmpDir2, 0777;
+
+        my @opts = ();
+        @opts = (RawInflate => 1)
+            if $bit eq 'IO::Uncompress::AnyUncompress';
+
+        ok   -d $tmpDir1, "  Temp Directory $tmpDir1 exists";
+        #ok ! -d $tmpDir2, "  Temp Directory $tmpDir2 does not exist";
+
+        my @files = map { "$tmpDir1/$_.tmp" } qw( a1 a2 a3) ;
+        foreach (@files) { writeFile($_, compressBuffer(getTopFuncName($UncompressClass), "abc $_")) }
+
+        my @expected = map { "abc $_" } @files ;
+        my @outFiles = map { s/$tmpDir1/$tmpDir2/; $_ } @files ;
+
+        {
+            title "$TopType - From FileGlob to FileGlob" ;
+
+            ok &$Func("<$tmpDir1/a*.tmp>" => "<$tmpDir2/a#1.tmp>", @opts), '  UnCompressed ok' 
+                or diag $$Error ;
+
+            my @copy = @expected;
+            for my $file (@outFiles)
+            {
+                is readFile($file), shift @copy, "  got expected from $file" ;
+            }
+
+            is @copy, 0, "  got all files";
+        }
+
+        {
+            title "$TopType - From FileGlob to Arrayref" ;
+
+            my @output = (\'first');
+            ok &$Func("<$tmpDir1/a*.tmp>" => \@output, @opts), '  UnCompressed ok' 
+                or diag $$Error ;
+
+            my @copy = ('first', @expected);
+            for my $data (@output)
+            {
+                is $$data, shift @copy, "  got expected data" ;
+            }
+
+            is @copy, 0, "  got all files";
+        }
+
+        {
+            title "$TopType - From FileGlob to Buffer" ;
+
+            my $output ;
+            ok &$Func("<$tmpDir1/a*.tmp>" => \$output, @opts), '  UnCompressed ok' 
+                or diag $$Error ;
+
+            is $output, join('', @expected), "  got expected uncompressed data";
+        }
+
+        {
+            title "$TopType - From FileGlob to Filename" ;
+
+            my $lex = new LexFile my $output ;
+            ok ! -e $output, "  $output does not exist" ;
+            ok &$Func("<$tmpDir1/a*.tmp>" => $output, @opts), '  UnCompressed ok' 
+                or diag $$Error ;
+
+            ok -e $output, "  $output does exist" ;
+            is readFile($output), join('', @expected), "  got expected uncompressed data";
+        }
+
+        {
+            title "$TopType - From FileGlob to Filehandle" ;
+
+            my $output = 'abc' ;
+            my $lex = new LexFile $output ;
+            my $fh = new IO::File ">$output" ;
+            ok &$Func("<$tmpDir1/a*.tmp>" => $fh, AutoClose => 1, @opts), '  UnCompressed ok' 
+                or diag $$Error ;
+
+            ok -e $output, "  $output does exist" ;
+            is readFile($output), join('', @expected), "  got expected uncompressed data";
+        }
+
+    }
+
+    foreach my $TopType ($CompressClass
+                         # TODO -- add the inflate classes
+                        )
+    {
+        my $Error = getErrorRef($TopType);
+        my $Func = getTopFuncRef($TopType);
+        my $Name = getTopFuncName($TopType);
+
+        title "More write tests" ;
+
+        my $lex = new LexFile(my $file1, my $file2, my $file3) ;
+
+        writeFile($file1, "F1");
+        writeFile($file2, "F2");
+        writeFile($file3, "F3");
+
+#        my @data = (
+#              [ '[\"ab", \"cd"]',                        "abcd" ],
+#
+#              [ '[\"a", $fh1, \"bc"]',                   "aF1bc"],
+#            ) ;
+#
+#
+#        foreach my $data (@data)
+#        {
+#            my ($send, $get) = @$data ;
+#
+#            my $fh1 = new IO::File "< $file1" ;
+#            my $fh2 = new IO::File "< $file2" ;
+#            my $fh3 = new IO::File "< $file3" ;
+#
+#            title "$send";
+#            my ($copy);
+#            eval "\$copy = $send";
+#            my $Answer ;
+#            ok &$Func($copy, \$Answer), "  $Name ok";
+#
+#            my $got = anyUncompress(\$Answer);
+#            is $got, $get, "  got expected output" ;
+#            ok ! $$Error,  "  no error"
+#                or diag "Error is $$Error";
+#
+#        }
+
+        title "Array Input Error tests" ;
+
+        my @data = (
+                   [ '[]',    "empty array reference"],
+                   [ '[[]]',    "unknown input parameter"],
+                   [ '[[[]]]',   "unknown input parameter"],
+                   [ '[[\"ab"], [\"cd"]]', "unknown input parameter"],
+                   [ '[\""]',     "not a filename"],
+                   [ '[\undef]',  "not a filename"],
+                   [ '[\"abcd"]', "not a filename"],
+                   [ '[\&xx]',      "unknown input parameter"],
+                   [ '[$fh2]',      "not a filename"],
+                ) ;
+
+
+        foreach my $data (@data)
+        {
+            my ($send, $get) = @$data ;
+
+            my $fh1 = new IO::File "< $file1" ;
+            my $fh2 = new IO::File "< $file2" ;
+            my $fh3 = new IO::File "< $file3" ;
+
+            title "$send";
+            my($copy);
+            eval "\$copy = $send";
+            my $Answer ;
+            my $a ;
+            eval { $a = &$Func($copy, \$Answer) };
+            ok ! $a, "  $Name fails";
+
+            is $$Error, $get, "  got error message";
+
+        }
+
+        @data = (
+                   '[""]', 
+                   '[undef]', 
+                ) ;
+
+
+        foreach my $send (@data)
+        {
+            title "$send";
+            my($copy);
+            eval "\$copy = $send";
+            my $Answer ;
+            eval { &$Func($copy, \$Answer) } ;
+            like $@, mkErr("^$TopFuncName: input filename is undef or null string"), 
+                "  got error message";
+
+        }
+    }
+
+}
+
+# TODO add more error cases
+
+1;
diff -urN perl-5.10.0/ext/IO_Compress_Base/t.xxx/compress/prime.pl perl-5.10.0/ext/IO_Compress_Base/t/compress/prime.pl
--- perl-5.10.0/ext/IO_Compress_Base/t.xxx/compress/prime.pl	1970-01-01 01:00:00.000000000 +0100
+++ perl-5.10.0/ext/IO_Compress_Base/t/compress/prime.pl	2008-09-03 15:57:30.000000000 +0200
@@ -0,0 +1,90 @@
+
+use lib 't';
+use strict;
+use warnings;
+use bytes;
+
+use Test::More ;
+use CompTestUtils;
+
+our ($extra);
+
+BEGIN {
+    # use Test::NoWarnings, if available
+    $extra = 0 ;
+    $extra = 1
+        if eval { require Test::NoWarnings ;  import Test::NoWarnings; 1 };
+
+}
+
+sub run
+{
+
+    my $CompressClass   = identify();
+    my $UncompressClass = getInverse($CompressClass);
+    my $Error           = getErrorRef($CompressClass);
+    my $UnError         = getErrorRef($UncompressClass);
+
+
+
+    my $hello = <<EOM ;
+hello world
+this is a test
+some more stuff on this line
+ad finally...
+EOM
+
+    print "#\n# Testing $UncompressClass\n#\n";
+
+    my $compressed = mkComplete($CompressClass, $hello);
+    my $cc = $compressed ;
+
+    plan tests => (length($compressed) * 6 * 7) + 1 + $extra ;
+
+    is anyUncompress(\$cc), $hello ;
+
+    for my $blocksize (1, 2, 13)
+    {
+        for my $i (0 .. length($compressed) - 1)
+        {
+            for my $useBuf (0 .. 1)
+            {
+                print "#\n# BlockSize $blocksize, Length $i, Buffer $useBuf\n#\n" ;
+                my $lex = new LexFile my $name ;
+        
+                my $prime = substr($compressed, 0, $i);
+                my $rest = substr($compressed, $i);
+        
+                my $start  ;
+                if ($useBuf) {
+                    $start = \$rest ;
+                }
+                else {
+                    $start = $name ;
+                    writeFile($name, $rest);
+                }
+
+                #my $gz = new $UncompressClass $name,
+                my $gz = new $UncompressClass $start,
+                                              -Append      => 1,
+                                              -BlockSize   => $blocksize,
+                                              -Prime       => $prime,
+                                              -Transparent => 0
+                                              ;
+                ok $gz;
+                ok ! $gz->error() ;
+                my $un ;
+                my $status = 1 ;
+                $status = $gz->read($un) while $status > 0 ;
+                is $status, 0 ;
+                ok ! $gz->error() 
+                    or print "Error is '" . $gz->error() . "'\n";
+                is $un, $hello ;
+                ok $gz->eof() ;
+                ok $gz->close() ;
+            }
+        }
+    }
+}
+ 
+1;
diff -urN perl-5.10.0/ext/IO_Compress_Base/t.xxx/compress/tied.pl perl-5.10.0/ext/IO_Compress_Base/t/compress/tied.pl
--- perl-5.10.0/ext/IO_Compress_Base/t.xxx/compress/tied.pl	1970-01-01 01:00:00.000000000 +0100
+++ perl-5.10.0/ext/IO_Compress_Base/t/compress/tied.pl	2008-09-03 15:57:30.000000000 +0200
@@ -0,0 +1,492 @@
+
+use lib 't';
+use strict;
+use warnings;
+use bytes;
+
+use Test::More ;
+use CompTestUtils;
+
+our ($BadPerl, $UncompressClass);
+ 
+BEGIN 
+{ 
+    plan(skip_all => "Tied Filehandle needs Perl 5.005 or better" )
+        if $] < 5.005 ;
+
+    # use Test::NoWarnings, if available
+    my $extra = 0 ;
+    $extra = 1
+        if eval { require Test::NoWarnings ;  import Test::NoWarnings; 1 };
+
+    my $tests ;
+    $BadPerl = ($] >= 5.006 and $] <= 5.008) ;
+
+    if ($BadPerl) {
+        $tests = 241 ;
+    }
+    else {
+        $tests = 249 ;
+    }
+
+    plan tests => $tests + $extra ;
+
+}
+ 
+ 
+use IO::Handle qw(SEEK_SET SEEK_CUR SEEK_END);
+ 
+
+
+sub myGZreadFile
+{
+    my $filename = shift ;
+    my $init = shift ;
+
+
+    my $fil = new $UncompressClass $filename,
+                                    -Strict   => 1,
+                                    -Append   => 1
+                                    ;
+
+    my $data ;
+    $data = $init if defined $init ;
+    1 while $fil->read($data) > 0;
+
+    $fil->close ;
+    return $data ;
+}
+
+sub run
+{
+
+    my $CompressClass   = identify();
+    $UncompressClass = getInverse($CompressClass);
+    my $Error           = getErrorRef($CompressClass);
+    my $UnError         = getErrorRef($UncompressClass);
+
+    {
+        next if $BadPerl ;
+
+
+        title "Testing $CompressClass";
+
+            
+        my $x ;
+        my $gz = new $CompressClass(\$x); 
+
+        my $buff ;
+
+        eval { getc($gz) } ;
+        like $@, mkErr("^getc Not Available: File opened only for output");
+
+        eval { read($gz, $buff, 1) } ;
+        like $@, mkErr("^read Not Available: File opened only for output");
+
+        eval { <$gz>  } ;
+        like $@, mkErr("^readline Not Available: File opened only for output");
+
+    }
+
+    {
+        next if $BadPerl;
+        $UncompressClass = getInverse($CompressClass);
+
+        title "Testing $UncompressClass";
+
+        my $gc ;
+        my $guz = new $CompressClass(\$gc); 
+        $guz->write("abc") ;
+        $guz->close();
+
+        my $x ;
+        my $gz = new $UncompressClass(\$gc); 
+
+        my $buff ;
+
+        eval { print $gz "abc" } ;
+        like $@, mkErr("^print Not Available: File opened only for intput");
+
+        eval { printf $gz "fmt", "abc" } ;
+        like $@, mkErr("^printf Not Available: File opened only for intput");
+
+        #eval { write($gz, $buff, 1) } ;
+        #like $@, mkErr("^write Not Available: File opened only for intput");
+
+    }
+
+    {
+        $UncompressClass = getInverse($CompressClass);
+
+        title "Testing $CompressClass and $UncompressClass";
+
+
+        {
+            # Write
+            # these tests come almost 100% from IO::String
+
+            my $lex = new LexFile my $name ;
+
+            my $io = $CompressClass->new($name);
+
+            is $io->tell(), 0 ;
+
+            my $heisan = "Heisan\n";
+            print $io $heisan ;
+
+            ok ! $io->eof;
+
+            is $io->tell(), length($heisan) ;
+
+            print($io "a", "b", "c");
+
+            {
+                local($\) = "\n";
+                print $io "d", "e";
+                local($,) = ",";
+                print $io "f", "g", "h";
+            }
+
+            my $foo = "1234567890";
+            
+            ok syswrite($io, $foo, length($foo)) == length($foo) ;
+            if ( $] < 5.6 )
+              { is $io->syswrite($foo, length $foo), length $foo }
+            else
+              { is $io->syswrite($foo), length $foo }
+            ok $io->syswrite($foo, length($foo)) == length $foo;
+            ok $io->write($foo, length($foo), 5) == 5;
+            ok $io->write("xxx\n", 100, -1) == 1;
+
+            for (1..3) {
+                printf $io "i(%d)", $_;
+                $io->printf("[%d]\n", $_);
+            }
+            select $io;
+            print "\n";
+            select STDOUT;
+
+            close $io ;
+
+            ok $io->eof;
+
+            is myGZreadFile($name), "Heisan\nabcde\nf,g,h\n" .
+                                    ("1234567890" x 3) . "67890\n" .
+                                        "i(1)[1]\ni(2)[2]\ni(3)[3]\n\n";
+
+
+        }
+
+        {
+            # Read
+            my $str = <<EOT;
+This is an example
+of a paragraph
+
+
+and a single line.
+
+EOT
+
+            my $lex = new LexFile my $name ;
+
+            my $iow = new $CompressClass $name ;
+            print $iow $str ;
+            close $iow;
+
+            my @tmp;
+            my $buf;
+            {
+                my $io = new $UncompressClass $name ;
+            
+                ok ! $io->eof, "  Not EOF";
+                is $io->tell(), 0, "  Tell is 0" ;
+                my @lines = <$io>;
+                is @lines, 6, "  Line is 6"
+                    or print "# Got " . scalar(@lines) . " lines, expected 6\n" ;
+                is $lines[1], "of a paragraph\n" ;
+                is join('', @lines), $str ;
+                is $., 6; 
+                is $io->tell(), length($str) ;
+            
+                ok $io->eof;
+
+                ok ! ( defined($io->getline)  ||
+                          (@tmp = $io->getlines) ||
+                          defined(<$io>)         ||
+                          defined($io->getc)     ||
+                          read($io, $buf, 100)   != 0) ;
+            }
+            
+            
+            {
+                local $/;  # slurp mode
+                my $io = $UncompressClass->new($name);
+                ok !$io->eof;
+                my @lines = $io->getlines;
+                ok $io->eof;
+                ok @lines == 1 && $lines[0] eq $str;
+            
+                $io = $UncompressClass->new($name);
+                ok ! $io->eof;
+                my $line = <$io>;
+                ok $line eq $str;
+                ok $io->eof;
+            }
+            
+            {
+                local $/ = "";  # paragraph mode
+                my $io = $UncompressClass->new($name);
+                ok ! $io->eof;
+                my @lines = <$io>;
+                ok $io->eof;
+                ok @lines == 2 
+                    or print "# Got " . scalar(@lines) . " lines, expected 2\n" ;
+                ok $lines[0] eq "This is an example\nof a paragraph\n\n\n"
+                    or print "# $lines[0]\n";
+                ok $lines[1] eq "and a single line.\n\n";
+            }
+            
+            {
+                local $/ = "is";
+                my $io = $UncompressClass->new($name);
+                my @lines = ();
+                my $no = 0;
+                my $err = 0;
+                ok ! $io->eof;
+                while (<$io>) {
+                    push(@lines, $_);
+                    $err++ if $. != ++$no;
+                }
+            
+                ok $err == 0 ;
+                ok $io->eof;
+            
+                ok @lines == 3 
+                    or print "# Got " . scalar(@lines) . " lines, expected 3\n" ;
+                ok join("-", @lines) eq
+                                 "This- is- an example\n" .
+                                "of a paragraph\n\n\n" .
+                                "and a single line.\n\n";
+            }
+            
+            
+            # Test read
+            
+            {
+                my $io = $UncompressClass->new($name);
+            
+
+                if (! $BadPerl) {
+                    eval { read($io, $buf, -1) } ;
+                    like $@, mkErr("length parameter is negative");
+                }
+
+                is read($io, $buf, 0), 0, "Requested 0 bytes" ;
+
+                ok read($io, $buf, 3) == 3 ;
+                ok $buf eq "Thi";
+            
+                ok sysread($io, $buf, 3, 2) == 3 ;
+                ok $buf eq "Ths i"
+                    or print "# [$buf]\n" ;;
+                ok ! $io->eof;
+            
+        #        $io->seek(-4, 2);
+        #    
+        #        ok ! $io->eof;
+        #    
+        #        ok read($io, $buf, 20) == 4 ;
+        #        ok $buf eq "e.\n\n";
+        #    
+        #        ok read($io, $buf, 20) == 0 ;
+        #        ok $buf eq "";
+        #   
+        #        ok ! $io->eof;
+            }
+
+        }
+
+        {
+            # Read from non-compressed file
+
+            my $str = <<EOT;
+This is an example
+of a paragraph
+
+
+and a single line.
+
+EOT
+
+            my $lex = new LexFile my $name ;
+
+            writeFile($name, $str);
+            my @tmp;
+            my $buf;
+            {
+                my $io = new $UncompressClass $name, -Transparent => 1 ;
+            
+                ok defined $io;
+                ok ! $io->eof;
+                ok $io->tell() == 0 ;
+                my @lines = <$io>;
+                ok @lines == 6; 
+                ok $lines[1] eq "of a paragraph\n" ;
+                ok join('', @lines) eq $str ;
+                ok $. == 6; 
+                ok $io->tell() == length($str) ;
+            
+                ok $io->eof;
+
+                ok ! ( defined($io->getline)  ||
+                          (@tmp = $io->getlines) ||
+                          defined(<$io>)         ||
+                          defined($io->getc)     ||
+                          read($io, $buf, 100)   != 0) ;
+            }
+            
+            
+            {
+                local $/;  # slurp mode
+                my $io = $UncompressClass->new($name);
+                ok ! $io->eof;
+                my @lines = $io->getlines;
+                ok $io->eof;
+                ok @lines == 1 && $lines[0] eq $str;
+            
+                $io = $UncompressClass->new($name);
+                ok ! $io->eof;
+                my $line = <$io>;
+                ok $line eq $str;
+                ok $io->eof;
+            }
+            
+            {
+                local $/ = "";  # paragraph mode
+                my $io = $UncompressClass->new($name);
+                ok ! $io->eof;
+                my @lines = <$io>;
+                ok $io->eof;
+                ok @lines == 2 
+                    or print "# exected 2 lines, got " . scalar(@lines) . "\n";
+                ok $lines[0] eq "This is an example\nof a paragraph\n\n\n"
+                    or print "# [$lines[0]]\n" ;
+                ok $lines[1] eq "and a single line.\n\n";
+            }
+            
+            {
+                local $/ = "is";
+                my $io = $UncompressClass->new($name);
+                my @lines = ();
+                my $no = 0;
+                my $err = 0;
+                ok ! $io->eof;
+                while (<$io>) {
+                    push(@lines, $_);
+                    $err++ if $. != ++$no;
+                }
+            
+                ok $err == 0 ;
+                ok $io->eof;
+            
+                ok @lines == 3 ;
+                ok join("-", @lines) eq
+                                 "This- is- an example\n" .
+                                "of a paragraph\n\n\n" .
+                                "and a single line.\n\n";
+            }
+            
+            
+            # Test read
+            
+            {
+                my $io = $UncompressClass->new($name);
+            
+                ok read($io, $buf, 3) == 3 ;
+                ok $buf eq "Thi";
+            
+                ok sysread($io, $buf, 3, 2) == 3 ;
+                ok $buf eq "Ths i";
+                ok ! $io->eof;
+            
+        #        $io->seek(-4, 2);
+        #    
+        #        ok ! $io->eof;
+        #    
+        #        ok read($io, $buf, 20) == 4 ;
+        #        ok $buf eq "e.\n\n";
+        #    
+        #        ok read($io, $buf, 20) == 0 ;
+        #        ok $buf eq "";
+        #    
+        #        ok ! $io->eof;
+            }
+
+
+        }
+
+        {
+            # Vary the length parameter in a read
+
+            my $str = <<EOT;
+x
+x
+This is an example
+of a paragraph
+
+
+and a single line.
+
+EOT
+            $str = $str x 100 ;
+
+
+            foreach my $bufsize (1, 3, 512, 4096, length($str)-1, length($str), length($str)+1)
+            {
+                foreach my $trans (0, 1)
+                {
+                    foreach my $append (0, 1)
+                    {
+                        title "Read Tests - buf length $bufsize, Transparent $trans, Append $append" ;
+
+                        my $lex = new LexFile my $name ;
+
+                        if ($trans) {
+                            writeFile($name, $str) ;
+                        }
+                        else {
+                            my $iow = new $CompressClass $name ;
+                            print $iow $str ;
+                            close $iow;
+                        }
+
+                        
+                        my $io = $UncompressClass->new($name, 
+                                                       -Append => $append,
+                                                       -Transparent  => $trans);
+                    
+                        my $buf;
+                        
+                        is $io->tell(), 0;
+
+                        if ($append) {
+                            1 while $io->read($buf, $bufsize) > 0;
+                        }
+                        else {
+                            my $tmp ;
+                            $buf .= $tmp while $io->read($tmp, $bufsize) > 0 ;
+                        }
+                        is length $buf, length $str;
+                        ok $buf eq $str ;
+                        ok ! $io->error() ;
+                        ok $io->eof;
+                    }
+                }
+            }
+        }
+
+    }
+}
+
+1;
diff -urN perl-5.10.0/ext/IO_Compress_Base/t.xxx/compress/truncate.pl perl-5.10.0/ext/IO_Compress_Base/t/compress/truncate.pl
--- perl-5.10.0/ext/IO_Compress_Base/t.xxx/compress/truncate.pl	1970-01-01 01:00:00.000000000 +0100
+++ perl-5.10.0/ext/IO_Compress_Base/t/compress/truncate.pl	2008-09-03 15:57:30.000000000 +0200
@@ -0,0 +1,169 @@
+
+use lib 't';
+use strict;
+use warnings;
+use bytes;
+
+use Test::More ;
+use CompTestUtils;
+
+sub run
+{
+    my $CompressClass   = identify();
+    my $UncompressClass = getInverse($CompressClass);
+    my $Error           = getErrorRef($CompressClass);
+    my $UnError         = getErrorRef($UncompressClass);
+    
+#    my $hello = <<EOM ;
+#hello world
+#this is a test
+#some more stuff on this line
+#and finally...
+#EOM
+
+    # ASCII hex equivalent of the text above. This makes the test
+    # harness behave identically on an EBCDIC platform.
+    my $hello = 
+      "\x68\x65\x6c\x6c\x6f\x20\x77\x6f\x72\x6c\x64\x0a\x74\x68\x69\x73" .
+      "\x20\x69\x73\x20\x61\x20\x74\x65\x73\x74\x0a\x73\x6f\x6d\x65\x20" .
+      "\x6d\x6f\x72\x65\x20\x73\x74\x75\x66\x66\x20\x6f\x6e\x20\x74\x68" .
+      "\x69\x73\x20\x6c\x69\x6e\x65\x0a\x61\x6e\x64\x20\x66\x69\x6e\x61" .
+      "\x6c\x6c\x79\x2e\x2e\x2e\x0a" ;
+
+    my $blocksize = 10 ;
+
+
+    my ($info, $compressed) = mkComplete($CompressClass, $hello);
+
+    my $header_size  = $info->{HeaderLength};
+    my $trailer_size = $info->{TrailerLength};
+    my $fingerprint_size = $info->{FingerprintLength};
+    ok 1, "Compressed size is " . length($compressed) ;
+    ok 1, "Fingerprint size is $fingerprint_size" ;
+    ok 1, "Header size is $header_size" ;
+    ok 1, "Trailer size is $trailer_size" ;
+
+    for my $trans ( 0 .. 1)
+    {
+        title "Truncating $CompressClass, Transparent $trans";
+
+
+        foreach my $i (1 .. $fingerprint_size-1)
+        {
+            my $lex = new LexFile my $name ;
+        
+            title "Fingerprint Truncation - length $i, Transparent $trans";
+
+            my $part = substr($compressed, 0, $i);
+            writeFile($name, $part);
+
+            my $gz = new $UncompressClass $name,
+                                          -BlockSize   => $blocksize,
+                                          -Transparent => $trans;
+            if ($trans) {
+                ok $gz;
+                ok ! $gz->error() ;
+                my $buff ;
+                is $gz->read($buff), length($part) ;
+                ok $buff eq $part ;
+                ok $gz->eof() ;
+                $gz->close();
+            }
+            else {
+                ok !$gz;
+            }
+
+        }
+
+        #
+        # Any header corruption past the fingerprint is considered catastrophic
+        # so even if Transparent is set, it should still fail
+        #
+        foreach my $i ($fingerprint_size .. $header_size -1)
+        {
+            my $lex = new LexFile my $name ;
+        
+            title "Header Truncation - length $i, Transparent $trans";
+
+            my $part = substr($compressed, 0, $i);
+            writeFile($name, $part);
+            ok ! defined new $UncompressClass $name,
+                                              -BlockSize   => $blocksize,
+                                              -Transparent => $trans;
+            #ok $gz->eof() ;
+        }
+
+        
+        foreach my $i ($header_size .. length($compressed) - 1 - $trailer_size)
+        {
+            next if $i == 0 ;
+
+            my $lex = new LexFile my $name ;
+        
+            title "Compressed Data Truncation - length $i, Transparent $trans";
+
+            my $part = substr($compressed, 0, $i);
+            writeFile($name, $part);
+            ok my $gz = new $UncompressClass $name,
+                                             -Strict      => 1,
+                                             -BlockSize   => $blocksize,
+                                             -Transparent => $trans
+                 or diag $$UnError;
+
+            my $un ;
+            my $status = 1 ;
+            $status = $gz->read($un) while $status > 0 ;
+            cmp_ok $status, "<", 0 ;
+            ok $gz->error() ;
+            ok $gz->eof() ;
+            $gz->close();
+        }
+        
+        # RawDeflate does not have a trailer
+        next if $CompressClass eq 'IO::Compress::RawDeflate' ;
+
+        title "Compressed Trailer Truncation";
+        foreach my $i (length($compressed) - $trailer_size .. length($compressed) -1 )
+        {
+            foreach my $lax (0, 1)
+            {
+                my $lex = new LexFile my $name ;
+            
+                ok 1, "Compressed Trailer Truncation - Length $i, Lax $lax, Transparent $trans" ;
+                my $part = substr($compressed, 0, $i);
+                writeFile($name, $part);
+                ok my $gz = new $UncompressClass $name,
+                                                 -BlockSize   => $blocksize,
+                                                 -Strict      => !$lax,
+                                                 -Append      => 1,   
+                                                 -Transparent => $trans;
+                my $un = '';
+                my $status = 1 ;
+                $status = $gz->read($un) while $status > 0 ;
+
+                if ($lax)
+                {
+                    is $un, $hello;
+                    is $status, 0 
+                        or diag "Status $status Error is " . $gz->error() ;
+                    ok $gz->eof()
+                        or diag "Status $status Error is " . $gz->error() ;
+                    ok ! $gz->error() ;
+                }
+                else
+                {
+                    cmp_ok $status, "<", 0 
+                        or diag "Status $status Error is " . $gz->error() ;
+                    ok $gz->eof()
+                        or diag "Status $status Error is " . $gz->error() ;
+                    ok $gz->error() ;
+                }
+                
+                $gz->close();
+            }
+        }
+    }
+}
+
+1;
+
diff -urN perl-5.10.0/ext/IO_Compress_Base/t.xxx/compress/zlib-generic.pl perl-5.10.0/ext/IO_Compress_Base/t/compress/zlib-generic.pl
--- perl-5.10.0/ext/IO_Compress_Base/t.xxx/compress/zlib-generic.pl	1970-01-01 01:00:00.000000000 +0100
+++ perl-5.10.0/ext/IO_Compress_Base/t/compress/zlib-generic.pl	2008-09-03 15:57:30.000000000 +0200
@@ -0,0 +1,233 @@
+
+use strict;
+use warnings;
+use bytes;
+
+use Test::More ;
+use CompTestUtils;
+
+BEGIN 
+{ 
+    # use Test::NoWarnings, if available
+    my $extra = 0 ;
+    $extra = 1
+        if eval { require Test::NoWarnings ;  import Test::NoWarnings; 1 };
+
+    plan tests => 49 + $extra ;
+}
+
+
+
+my $CompressClass   = identify();
+my $UncompressClass = getInverse($CompressClass);
+my $Error           = getErrorRef($CompressClass);
+my $UnError         = getErrorRef($UncompressClass);
+
+use Compress::Raw::Zlib;
+use IO::Handle qw(SEEK_SET SEEK_CUR SEEK_END);
+
+sub myGZreadFile
+{
+    my $filename = shift ;
+    my $init = shift ;
+
+
+    my $fil = new $UncompressClass $filename,
+                                    -Strict   => 1,
+                                    -Append   => 1
+                                    ;
+
+    my $data = '';
+    $data = $init if defined $init ;
+    1 while $fil->read($data) > 0;
+
+    $fil->close ;
+    return $data ;
+}
+
+
+{
+
+    title "Testing $CompressClass Errors";
+
+}
+
+
+{
+    title "Testing $UncompressClass Errors";
+
+}
+
+{
+    title "Testing $CompressClass and $UncompressClass";
+
+    {
+        title "flush" ;
+
+
+        my $lex = new LexFile my $name ;
+
+        my $hello = <<EOM ;
+hello world
+this is a test
+EOM
+
+        {
+          my $x ;
+          ok $x = new $CompressClass $name  ;
+
+          ok $x->write($hello), "write" ;
+          ok $x->flush(Z_FINISH), "flush";
+          ok $x->close, "close" ;
+        }
+
+        {
+          my $uncomp;
+          ok my $x = new $UncompressClass $name, -Append => 1  ;
+
+          my $len ;
+          1 while ($len = $x->read($uncomp)) > 0 ;
+
+          is $len, 0, "read returned 0";
+
+          ok $x->close ;
+          is $uncomp, $hello ;
+        }
+    }
+
+
+    if ($CompressClass ne 'RawDeflate')
+    {
+        # write empty file
+        #========================================
+
+        my $buffer = '';
+        {
+          my $x ;
+          ok $x = new $CompressClass(\$buffer) ;
+          ok $x->close ;
+      
+        }
+
+        my $keep = $buffer ;
+        my $uncomp= '';
+        {
+          my $x ;
+          ok $x = new $UncompressClass(\$buffer, Append => 1)  ;
+
+          1 while $x->read($uncomp) > 0  ;
+
+          ok $x->close ;
+        }
+
+        ok $uncomp eq '' ;
+        ok $buffer eq $keep ;
+
+    }
+
+    
+    {
+        title "inflateSync on plain file";
+
+        my $hello = "I am a HAL 9000 computer" x 2001 ;
+
+        my $k = new $UncompressClass(\$hello, Transparent => 1);
+        ok $k ;
+     
+        # Skip to the flush point -- no-op for plain file
+        my $status = $k->inflateSync();
+        is $status, 1 
+            or diag $k->error() ;
+     
+        my $rest; 
+        is $k->read($rest, length($hello)), length($hello)
+            or diag $k->error() ;
+        ok $rest eq $hello ;
+
+        ok $k->close();
+    }
+
+    {
+        title "$CompressClass: inflateSync for real";
+
+        # create a deflate stream with flush points
+
+        my $hello = "I am a HAL 9000 computer" x 2001 ;
+        my $goodbye = "Will I dream?" x 2010;
+        my ($x, $err, $answer, $X, $Z, $status);
+        my $Answer ;
+     
+        ok ($x = new $CompressClass(\$Answer));
+        ok $x ;
+     
+        is $x->write($hello), length($hello);
+    
+        # create a flush point
+        ok $x->flush(Z_FULL_FLUSH) ;
+         
+        is $x->write($goodbye), length($goodbye);
+    
+        ok $x->close() ;
+     
+        my $k;
+        $k = new $UncompressClass(\$Answer, BlockSize => 1);
+        ok $k ;
+     
+        my $initial;
+        is $k->read($initial, 1), 1 ;
+        is $initial, substr($hello, 0, 1);
+
+        # Skip to the flush point
+        $status = $k->inflateSync();
+        is $status, 1, "   inflateSync returned 1"
+            or diag $k->error() ;
+     
+        my $rest; 
+        is $k->read($rest, length($hello) + length($goodbye)), 
+                length($goodbye)
+            or diag $k->error() ;
+        ok $rest eq $goodbye, " got expected output" ;
+
+        ok $k->close();
+    }
+
+    {
+        title "$CompressClass: inflateSync no FLUSH point";
+
+        # create a deflate stream with flush points
+
+        my $hello = "I am a HAL 9000 computer" x 2001 ;
+        my ($x, $err, $answer, $X, $Z, $status);
+        my $Answer ;
+     
+        ok ($x = new $CompressClass(\$Answer));
+        ok $x ;
+     
+        is $x->write($hello), length($hello);
+    
+        ok $x->close() ;
+     
+        my $k = new $UncompressClass(\$Answer, BlockSize => 1);
+        ok $k ;
+     
+        my $initial;
+        is $k->read($initial, 1), 1 ;
+        is $initial, substr($hello, 0, 1);
+
+        # Skip to the flush point
+        $status = $k->inflateSync();
+        is $status, 0 
+            or diag $k->error() ;
+     
+        ok $k->close();
+        is $k->inflateSync(), 0 ;
+    }
+
+}
+
+
+1;
+
+
+
+
diff -urN perl-5.10.0/ext/IO_Compress_Base/t.xxx/globmapper.t perl-5.10.0/ext/IO_Compress_Base/t/globmapper.t
--- perl-5.10.0/ext/IO_Compress_Base/t.xxx/globmapper.t	1970-01-01 01:00:00.000000000 +0100
+++ perl-5.10.0/ext/IO_Compress_Base/t/globmapper.t	2007-12-18 11:47:07.000000000 +0100
@@ -0,0 +1,304 @@
+BEGIN {
+    if ($ENV{PERL_CORE}) {
+	chdir 't' if -d 't';
+	@INC = ("../lib", "lib/compress");
+    }
+}
+
+use lib qw(t t/compress);
+use strict ;
+use warnings ;
+
+use Test::More ;
+use CompTestUtils;
+
+
+BEGIN 
+{ 
+    plan(skip_all => "File::GlobMapper needs Perl 5.005 or better - you have
+Perl $]" )
+        if $] < 5.005 ;
+
+    # use Test::NoWarnings, if available
+    my $extra = 0 ;
+    $extra = 1
+        if eval { require Test::NoWarnings ;  import Test::NoWarnings; 1 };
+
+    plan tests => 68 + $extra ;
+
+    use_ok('File::GlobMapper') ; 
+}
+
+{
+    title "Error Cases" ;
+
+    my $gm;
+
+    for my $delim ( qw/ ( ) { } [ ] / )
+    {
+        $gm = new File::GlobMapper("${delim}abc", '*.X');
+        ok ! $gm, "  new failed" ;
+        is $File::GlobMapper::Error, "Unmatched $delim in input fileglob", 
+            "  catch unmatched $delim";
+    }
+
+    for my $delim ( qw/ ( ) [ ] / )
+    {
+        $gm = new File::GlobMapper("{${delim}abc}", '*.X');
+        ok ! $gm, "  new failed" ;
+        is $File::GlobMapper::Error, "Unmatched $delim in input fileglob", 
+            "  catch unmatched $delim inside {}";
+    }
+
+    
+}
+
+{
+    title "input glob matches zero files";
+
+    my $tmpDir = 'td';
+    my $lex = new LexDir $tmpDir;
+
+    my $gm = new File::GlobMapper("$tmpDir/Z*", '*.X');
+    ok $gm, "  created GlobMapper object" ;
+
+    my $map = $gm->getFileMap() ;
+    is @{ $map }, 0, "  returned 0 maps";
+    is_deeply $map, [], " zero maps" ;
+
+    my $hash = $gm->getHash() ;
+    is_deeply $hash, {}, "  zero maps" ;
+}
+
+{
+    title 'test wildcard mapping of * in destination';
+
+    my $tmpDir = 'td';
+    my $lex = new LexDir $tmpDir;
+    mkdir $tmpDir, 0777 ;
+
+    touch map { "$tmpDir/$_.tmp" } qw( abc1 abc2 abc3 ) ;
+
+    my $gm = new File::GlobMapper("$tmpDir/ab*.tmp", "*X");
+    ok $gm, "  created GlobMapper object" ;
+
+    my $map = $gm->getFileMap() ;
+    is @{ $map }, 3, "  returned 3 maps";
+    is_deeply $map,
+        [ [map { "$tmpDir/$_" } qw(abc1.tmp abc1.tmpX)],
+          [map { "$tmpDir/$_" } qw(abc2.tmp abc2.tmpX)],
+          [map { "$tmpDir/$_" } qw(abc3.tmp abc3.tmpX)],
+        ], "  got mapping";
+
+    my $hash = $gm->getHash() ;
+    is_deeply $hash,
+        { map { "$tmpDir/$_" } qw(abc1.tmp abc1.tmpX
+                                  abc2.tmp abc2.tmpX
+                                  abc3.tmp abc3.tmpX),
+        }, "  got mapping";
+}
+
+{
+    title 'no wildcards in input or destination';
+
+    my $tmpDir = 'td';
+    my $lex = new LexDir $tmpDir;
+    mkdir $tmpDir, 0777 ;
+
+    touch map { "$tmpDir/$_.tmp" } qw( abc1 abc2 abc3 ) ;
+
+    my $gm = new File::GlobMapper("$tmpDir/abc2.tmp", "$tmpDir/abc2.tmp");
+    ok $gm, "  created GlobMapper object" ;
+
+    my $map = $gm->getFileMap() ;
+    is @{ $map }, 1, "  returned 1 maps";
+    is_deeply $map,
+        [ [map { "$tmpDir/$_.tmp" } qw(abc2 abc2)],
+        ], "  got mapping";
+
+    my $hash = $gm->getHash() ;
+    is_deeply $hash,
+        { map { "$tmpDir/$_.tmp" } qw(abc2 abc2),
+        }, "  got mapping";
+}
+
+{
+    title 'test wildcard mapping of {} in destination';
+
+    my $tmpDir = 'td';
+    my $lex = new LexDir $tmpDir;
+    mkdir $tmpDir, 0777 ;
+
+    touch map { "$tmpDir/$_.tmp" } qw( abc1 abc2 abc3 ) ;
+
+    my $gm = new File::GlobMapper("$tmpDir/abc{1,3}.tmp", "*.X");
+    #diag "Input pattern is $gm->{InputPattern}";
+    ok $gm, "  created GlobMapper object" ;
+
+    my $map = $gm->getFileMap() ;
+    is @{ $map }, 2, "  returned 2 maps";
+    is_deeply $map,
+        [ [map { "$tmpDir/$_" } qw(abc1.tmp abc1.tmp.X)],
+          [map { "$tmpDir/$_" } qw(abc3.tmp abc3.tmp.X)],
+        ], "  got mapping";
+
+    $gm = new File::GlobMapper("$tmpDir/abc{1,3}.tmp", "$tmpDir/X.#1.X")
+        or diag $File::GlobMapper::Error ;
+    #diag "Input pattern is $gm->{InputPattern}";
+    ok $gm, "  created GlobMapper object" ;
+
+    $map = $gm->getFileMap() ;
+    is @{ $map }, 2, "  returned 2 maps";
+    is_deeply $map,
+        [ [map { "$tmpDir/$_" } qw(abc1.tmp X.1.X)],
+          [map { "$tmpDir/$_" } qw(abc3.tmp X.3.X)],
+        ], "  got mapping";
+
+}
+
+
+{
+    title 'test wildcard mapping of multiple * to #';
+
+    my $tmpDir = 'td';
+    my $lex = new LexDir $tmpDir;
+    mkdir $tmpDir, 0777 ;
+
+    touch map { "$tmpDir/$_.tmp" } qw( abc1 abc2 abc3 ) ;
+
+    my $gm = new File::GlobMapper("$tmpDir/*b(*).tmp", "$tmpDir/X-#2-#1-X");
+    ok $gm, "  created GlobMapper object" 
+        or diag $File::GlobMapper::Error ;
+
+    my $map = $gm->getFileMap() ;
+    is @{ $map }, 3, "  returned 3 maps";
+    is_deeply $map,
+        [ [map { "$tmpDir/$_" } qw(abc1.tmp X-c1-a-X)],
+          [map { "$tmpDir/$_" } qw(abc2.tmp X-c2-a-X)],
+          [map { "$tmpDir/$_" } qw(abc3.tmp X-c3-a-X)],
+        ], "  got mapping";
+}
+
+{
+    title 'test wildcard mapping of multiple ? to #';
+
+    my $tmpDir = 'td';
+    my $lex = new LexDir $tmpDir;
+    mkdir $tmpDir, 0777 ;
+
+    touch map { "$tmpDir/$_.tmp" } qw( abc1 abc2 abc3 ) ;
+
+    my $gm = new File::GlobMapper("$tmpDir/?b(*).tmp", "$tmpDir/X-#2-#1-X");
+    ok $gm, "  created GlobMapper object" ;
+
+    my $map = $gm->getFileMap() ;
+    is @{ $map }, 3, "  returned 3 maps";
+    is_deeply $map,
+        [ [map { "$tmpDir/$_" } qw(abc1.tmp X-c1-a-X)],
+          [map { "$tmpDir/$_" } qw(abc2.tmp X-c2-a-X)],
+          [map { "$tmpDir/$_" } qw(abc3.tmp X-c3-a-X)],
+        ], "  got mapping";
+}
+
+{
+    title 'test wildcard mapping of multiple ?,* and [] to #';
+
+    my $tmpDir = 'td';
+    my $lex = new LexDir $tmpDir;
+    mkdir $tmpDir, 0777 ;
+
+    touch map { "$tmpDir/$_.tmp" } qw( abc1 abc2 abc3 ) ;
+
+    my $gm = new File::GlobMapper("./$tmpDir/?b[a-z]*.tmp", "./$tmpDir/X-#3-#2-#1-X");
+    ok $gm, "  created GlobMapper object" ;
+
+    #diag "Input pattern is $gm->{InputPattern}";
+    my $map = $gm->getFileMap() ;
+    is @{ $map }, 3, "  returned 3 maps";
+    is_deeply $map,
+        [ [map { "./$tmpDir/$_" } qw(abc1.tmp X-1-c-a-X)],
+          [map { "./$tmpDir/$_" } qw(abc2.tmp X-2-c-a-X)],
+          [map { "./$tmpDir/$_" } qw(abc3.tmp X-3-c-a-X)],
+        ], "  got mapping";
+}
+
+{
+    title 'input glob matches a file multiple times';
+
+    my $tmpDir = 'td';
+    my $lex = new LexDir $tmpDir;
+    mkdir $tmpDir, 0777 ;
+
+    touch "$tmpDir/abc.tmp";
+
+    my $gm = new File::GlobMapper("$tmpDir/{a*,*c}.tmp", '*.X');
+    ok $gm, "  created GlobMapper object" ;
+
+    my $map = $gm->getFileMap() ;
+    is @{ $map }, 1, "  returned 1 maps";
+    is_deeply $map,
+        [ [map { "$tmpDir/$_" } qw(abc.tmp abc.tmp.X)], ], "  got mapping";
+
+    my $hash = $gm->getHash() ;
+    is_deeply $hash,
+        { map { "$tmpDir/$_" } qw(abc.tmp abc.tmp.X) }, "  got mapping";
+
+}
+
+{
+    title 'multiple input files map to one output file';
+
+    my $tmpDir = 'td';
+    my $lex = new LexDir $tmpDir;
+    mkdir $tmpDir, 0777 ;
+
+    touch map { "$tmpDir/$_.tmp" } qw( abc def) ;
+
+    my $gm = new File::GlobMapper("$tmpDir/*.tmp", "$tmpDir/fred");
+    ok ! $gm, "  did not create GlobMapper object" ;
+
+    is $File::GlobMapper::Error, 'multiple input files map to one output file', "  Error is expected" ;
+
+    #my $map = $gm->getFileMap() ;
+    #is @{ $map }, 1, "  returned 1 maps";
+    #is_deeply $map,
+    #[ [map { "$tmpDir/$_" } qw(abc1 abc.X)], ], "  got mapping";
+}
+
+{
+    title "globmap" ;
+
+    my $tmpDir = 'td';
+    my $lex = new LexDir $tmpDir;
+    mkdir $tmpDir, 0777 ;
+
+    touch map { "$tmpDir/$_.tmp" } qw( abc1 abc2 abc3 ) ;
+
+    my $map = File::GlobMapper::globmap("$tmpDir/*b*.tmp", "$tmpDir/X-#2-#1-X");
+    ok $map, "  got map" 
+        or diag $File::GlobMapper::Error ;
+
+    is @{ $map }, 3, "  returned 3 maps";
+    is_deeply $map,
+        [ [map { "$tmpDir/$_" } qw(abc1.tmp X-c1-a-X)],
+          [map { "$tmpDir/$_" } qw(abc2.tmp X-c2-a-X)],
+          [map { "$tmpDir/$_" } qw(abc3.tmp X-c3-a-X)],
+        ], "  got mapping";
+}
+
+# TODO
+# test each of the wildcard metacharacters can be mapped to the output filename
+#
+#   ~ [] {} . *
+
+# input & output glob with no wildcards is ok
+# input with no wild or output with no wild is bad
+# input wild has concatenated *'s
+# empty string for either both from & to
+# escaped chars within [] and {}, including the chars []{}
+# escaped , within {}
+# missing ] and missing }
+# {} and {,} are special cases
+# {ab*,de*}
+# {abc,{},{de,f}} => abc {} de f
+
diff -urN perl-5.10.0/ext/IO_Compress_Base/t.xxx/Test/Builder.pm perl-5.10.0/ext/IO_Compress_Base/t/Test/Builder.pm
--- perl-5.10.0/ext/IO_Compress_Base/t.xxx/Test/Builder.pm	1970-01-01 01:00:00.000000000 +0100
+++ perl-5.10.0/ext/IO_Compress_Base/t/Test/Builder.pm	2008-05-05 14:09:24.000000000 +0200
@@ -0,0 +1,1625 @@
+package Test::Builder;
+
+use 5.004;
+
+# $^C was only introduced in 5.005-ish.  We do this to prevent
+# use of uninitialized value warnings in older perls.
+$^C ||= 0;
+
+use strict;
+our ($VERSION);
+$VERSION = '0.30';
+$VERSION = eval $VERSION;    # make the alpha version come out as a number
+
+# Make Test::Builder thread-safe for ithreads.
+BEGIN {
+    use Config;
+    # Load threads::shared when threads are turned on
+    if( $] >= 5.008 && $Config{useithreads} && $INC{'threads.pm'}) {
+        require threads::shared;
+
+        # Hack around YET ANOTHER threads::shared bug.  It would 
+        # occassionally forget the contents of the variable when sharing it.
+        # So we first copy the data, then share, then put our copy back.
+        *share = sub (\[$@%]) {
+            my $type = ref $_[0];
+            my $data;
+
+            if( $type eq 'HASH' ) {
+                %$data = %{$_[0]};
+            }
+            elsif( $type eq 'ARRAY' ) {
+                @$data = @{$_[0]};
+            }
+            elsif( $type eq 'SCALAR' ) {
+                $$data = ${$_[0]};
+            }
+            else {
+                die "Unknown type: ".$type;
+            }
+
+            $_[0] = &threads::shared::share($_[0]);
+
+            if( $type eq 'HASH' ) {
+                %{$_[0]} = %$data;
+            }
+            elsif( $type eq 'ARRAY' ) {
+                @{$_[0]} = @$data;
+            }
+            elsif( $type eq 'SCALAR' ) {
+                ${$_[0]} = $$data;
+            }
+            else {
+                die "Unknown type: ".$type;
+            }
+
+            return $_[0];
+        };
+    }
+    # 5.8.0's threads::shared is busted when threads are off.
+    # We emulate it here.
+    else {
+        *share = sub { return $_[0] };
+        *lock  = sub { 0 };
+    }
+}
+
+
+=head1 NAME
+
+Test::Builder - Backend for building test libraries
+
+=head1 SYNOPSIS
+
+  package My::Test::Module;
+  use Test::Builder;
+  require Exporter;
+  @ISA = qw(Exporter);
+  @EXPORT = qw(ok);
+
+  my $Test = Test::Builder->new;
+  $Test->output('my_logfile');
+
+  sub import {
+      my($self) = shift;
+      my $pack = caller;
+
+      $Test->exported_to($pack);
+      $Test->plan(@_);
+
+      $self->export_to_level(1, $self, 'ok');
+  }
+
+  sub ok {
+      my($test, $name) = @_;
+
+      $Test->ok($test, $name);
+  }
+
+
+=head1 DESCRIPTION
+
+Test::Simple and Test::More have proven to be popular testing modules,
+but they're not always flexible enough.  Test::Builder provides the a
+building block upon which to write your own test libraries I<which can
+work together>.
+
+=head2 Construction
+
+=over 4
+
+=item B<new>
+
+  my $Test = Test::Builder->new;
+
+Returns a Test::Builder object representing the current state of the
+test.
+
+Since you only run one test per program C<new> always returns the same
+Test::Builder object.  No matter how many times you call new(), you're
+getting the same object.  This is called a singleton.  This is done so that
+multiple modules share such global information as the test counter and
+where test output is going.
+
+If you want a completely new Test::Builder object different from the
+singleton, use C<create>.
+
+=cut
+
+my $Test = Test::Builder->new;
+sub new {
+    my($class) = shift;
+    $Test ||= $class->create;
+    return $Test;
+}
+
+
+=item B<create>
+
+  my $Test = Test::Builder->create;
+
+Ok, so there can be more than one Test::Builder object and this is how
+you get it.  You might use this instead of C<new()> if you're testing
+a Test::Builder based module, but otherwise you probably want C<new>.
+
+B<NOTE>: the implementation is not complete.  C<level>, for example, is
+still shared amongst B<all> Test::Builder objects, even ones created using
+this method.  Also, the method name may change in the future.
+
+=cut
+
+sub create {
+    my $class = shift;
+
+    my $self = bless {}, $class;
+    $self->reset;
+
+    return $self;
+}
+
+=item B<reset>
+
+  $Test->reset;
+
+Reinitializes the Test::Builder singleton to its original state.
+Mostly useful for tests run in persistent environments where the same
+test might be run multiple times in the same process.
+
+=cut
+
+our ($Level);
+
+sub reset {
+    my ($self) = @_;
+
+    # We leave this a global because it has to be localized and localizing
+    # hash keys is just asking for pain.  Also, it was documented.
+    $Level = 1;
+
+    $self->{Test_Died}    = 0;
+    $self->{Have_Plan}    = 0;
+    $self->{No_Plan}      = 0;
+    $self->{Original_Pid} = $$;
+
+    share($self->{Curr_Test});
+    $self->{Curr_Test}    = 0;
+    $self->{Test_Results} = &share([]);
+
+    $self->{Exported_To}    = undef;
+    $self->{Expected_Tests} = 0;
+
+    $self->{Skip_All}   = 0;
+
+    $self->{Use_Nums}   = 1;
+
+    $self->{No_Header}  = 0;
+    $self->{No_Ending}  = 0;
+
+    $self->_dup_stdhandles unless $^C;
+
+    return undef;
+}
+
+=back
+
+=head2 Setting up tests
+
+These methods are for setting up tests and declaring how many there
+are.  You usually only want to call one of these methods.
+
+=over 4
+
+=item B<exported_to>
+
+  my $pack = $Test->exported_to;
+  $Test->exported_to($pack);
+
+Tells Test::Builder what package you exported your functions to.
+This is important for getting TODO tests right.
+
+=cut
+
+sub exported_to {
+    my($self, $pack) = @_;
+
+    if( defined $pack ) {
+        $self->{Exported_To} = $pack;
+    }
+    return $self->{Exported_To};
+}
+
+=item B<plan>
+
+  $Test->plan('no_plan');
+  $Test->plan( skip_all => $reason );
+  $Test->plan( tests => $num_tests );
+
+A convenient way to set up your tests.  Call this and Test::Builder
+will print the appropriate headers and take the appropriate actions.
+
+If you call plan(), don't call any of the other methods below.
+
+=cut
+
+sub plan {
+    my($self, $cmd, $arg) = @_;
+
+    return unless $cmd;
+
+    if( $self->{Have_Plan} ) {
+        die sprintf "You tried to plan twice!  Second plan at %s line %d\n",
+          ($self->caller)[1,2];
+    }
+
+    if( $cmd eq 'no_plan' ) {
+        $self->no_plan;
+    }
+    elsif( $cmd eq 'skip_all' ) {
+        return $self->skip_all($arg);
+    }
+    elsif( $cmd eq 'tests' ) {
+        if( $arg ) {
+            return $self->expected_tests($arg);
+        }
+        elsif( !defined $arg ) {
+            die "Got an undefined number of tests.  Looks like you tried to ".
+                "say how many tests you plan to run but made a mistake.\n";
+        }
+        elsif( !$arg ) {
+            die "You said to run 0 tests!  You've got to run something.\n";
+        }
+    }
+    else {
+        require Carp;
+        my @args = grep { defined } ($cmd, $arg);
+        Carp::croak("plan() doesn't understand @args");
+    }
+
+    return 1;
+}
+
+=item B<expected_tests>
+
+    my $max = $Test->expected_tests;
+    $Test->expected_tests($max);
+
+Gets/sets the # of tests we expect this test to run and prints out
+the appropriate headers.
+
+=cut
+
+sub expected_tests {
+    my $self = shift;
+    my($max) = @_;
+
+    if( @_ ) {
+        die "Number of tests must be a postive integer.  You gave it '$max'.\n"
+          unless $max =~ /^\+?\d+$/ and $max > 0;
+
+        $self->{Expected_Tests} = $max;
+        $self->{Have_Plan}      = 1;
+
+        $self->_print("1..$max\n") unless $self->no_header;
+    }
+    return $self->{Expected_Tests};
+}
+
+
+=item B<no_plan>
+
+  $Test->no_plan;
+
+Declares that this test will run an indeterminate # of tests.
+
+=cut
+
+sub no_plan {
+    my $self = shift;
+
+    $self->{No_Plan}   = 1;
+    $self->{Have_Plan} = 1;
+}
+
+=item B<has_plan>
+
+  $plan = $Test->has_plan
+
+Find out whether a plan has been defined. $plan is either C<undef> (no plan has been set), C<no_plan> (indeterminate # of tests) or an integer (the number of expected tests).
+
+=cut
+
+sub has_plan {
+    my $self = shift;
+
+    return($self->{Expected_Tests}) if $self->{Expected_Tests};
+    return('no_plan') if $self->{No_Plan};
+    return(undef);
+};
+
+
+=item B<skip_all>
+
+  $Test->skip_all;
+  $Test->skip_all($reason);
+
+Skips all the tests, using the given $reason.  Exits immediately with 0.
+
+=cut
+
+sub skip_all {
+    my($self, $reason) = @_;
+
+    my $out = "1..0";
+    $out .= " # Skip $reason" if $reason;
+    $out .= "\n";
+
+    $self->{Skip_All} = 1;
+
+    $self->_print($out) unless $self->no_header;
+    exit(0);
+}
+
+=back
+
+=head2 Running tests
+
+These actually run the tests, analogous to the functions in
+Test::More.
+
+$name is always optional.
+
+=over 4
+
+=item B<ok>
+
+  $Test->ok($test, $name);
+
+Your basic test.  Pass if $test is true, fail if $test is false.  Just
+like Test::Simple's ok().
+
+=cut
+
+sub ok {
+    my($self, $test, $name) = @_;
+
+    # $test might contain an object which we don't want to accidentally
+    # store, so we turn it into a boolean.
+    $test = $test ? 1 : 0;
+
+    unless( $self->{Have_Plan} ) {
+        require Carp;
+        Carp::croak("You tried to run a test without a plan!  Gotta have a plan.");
+    }
+
+    lock $self->{Curr_Test};
+    $self->{Curr_Test}++;
+
+    # In case $name is a string overloaded object, force it to stringify.
+    $self->_unoverload(\$name);
+
+    $self->diag(<<ERR) if defined $name and $name =~ /^[\d\s]+$/;
+    You named your test '$name'.  You shouldn't use numbers for your test names.
+    Very confusing.
+ERR
+
+    my($pack, $file, $line) = $self->caller;
+
+    my $todo = $self->todo($pack);
+    $self->_unoverload(\$todo);
+
+    my $out;
+    my $result = &share({});
+
+    unless( $test ) {
+        $out .= "not ";
+        @$result{ 'ok', 'actual_ok' } = ( ( $todo ? 1 : 0 ), 0 );
+    }
+    else {
+        @$result{ 'ok', 'actual_ok' } = ( 1, $test );
+    }
+
+    $out .= "ok";
+    $out .= " $self->{Curr_Test}" if $self->use_numbers;
+
+    if( defined $name ) {
+        $name =~ s|#|\\#|g;     # # in a name can confuse Test::Harness.
+        $out   .= " - $name";
+        $result->{name} = $name;
+    }
+    else {
+        $result->{name} = '';
+    }
+
+    if( $todo ) {
+        $out   .= " # TODO $todo";
+        $result->{reason} = $todo;
+        $result->{type}   = 'todo';
+    }
+    else {
+        $result->{reason} = '';
+        $result->{type}   = '';
+    }
+
+    $self->{Test_Results}[$self->{Curr_Test}-1] = $result;
+    $out .= "\n";
+
+    $self->_print($out);
+
+    unless( $test ) {
+        my $msg = $todo ? "Failed (TODO)" : "Failed";
+        $self->_print_diag("\n") if $ENV{HARNESS_ACTIVE};
+        $self->diag("    $msg test ($file at line $line)\n");
+    } 
+
+    return $test ? 1 : 0;
+}
+
+
+sub _unoverload {
+    my $self  = shift;
+
+    local($@,$!);
+
+    eval { require overload } || return;
+
+    foreach my $thing (@_) {
+        eval { 
+            if( defined $$thing ) {
+                if( my $string_meth = overload::Method($$thing, '""') ) {
+                    $$thing = $$thing->$string_meth();
+                }
+            }
+        };
+    }
+}
+
+
+=item B<is_eq>
+
+  $Test->is_eq($got, $expected, $name);
+
+Like Test::More's is().  Checks if $got eq $expected.  This is the
+string version.
+
+=item B<is_num>
+
+  $Test->is_num($got, $expected, $name);
+
+Like Test::More's is().  Checks if $got == $expected.  This is the
+numeric version.
+
+=cut
+
+sub is_eq {
+    my($self, $got, $expect, $name) = @_;
+    local $Level = $Level + 1;
+
+    if( !defined $got || !defined $expect ) {
+        # undef only matches undef and nothing else
+        my $test = !defined $got && !defined $expect;
+
+        $self->ok($test, $name);
+        $self->_is_diag($got, 'eq', $expect) unless $test;
+        return $test;
+    }
+
+    return $self->cmp_ok($got, 'eq', $expect, $name);
+}
+
+sub is_num {
+    my($self, $got, $expect, $name) = @_;
+    local $Level = $Level + 1;
+
+    if( !defined $got || !defined $expect ) {
+        # undef only matches undef and nothing else
+        my $test = !defined $got && !defined $expect;
+
+        $self->ok($test, $name);
+        $self->_is_diag($got, '==', $expect) unless $test;
+        return $test;
+    }
+
+    return $self->cmp_ok($got, '==', $expect, $name);
+}
+
+sub _is_diag {
+    my($self, $got, $type, $expect) = @_;
+
+    foreach my $val (\$got, \$expect) {
+        if( defined $$val ) {
+            if( $type eq 'eq' ) {
+                # quote and force string context
+                $$val = "'$$val'"
+            }
+            else {
+                # force numeric context
+                $$val = $$val+0;
+            }
+        }
+        else {
+            $$val = 'undef';
+        }
+    }
+
+    return $self->diag(sprintf <<DIAGNOSTIC, $got, $expect);
+         got: %s
+    expected: %s
+DIAGNOSTIC
+
+}    
+
+=item B<isnt_eq>
+
+  $Test->isnt_eq($got, $dont_expect, $name);
+
+Like Test::More's isnt().  Checks if $got ne $dont_expect.  This is
+the string version.
+
+=item B<isnt_num>
+
+  $Test->is_num($got, $dont_expect, $name);
+
+Like Test::More's isnt().  Checks if $got ne $dont_expect.  This is
+the numeric version.
+
+=cut
+
+sub isnt_eq {
+    my($self, $got, $dont_expect, $name) = @_;
+    local $Level = $Level + 1;
+
+    if( !defined $got || !defined $dont_expect ) {
+        # undef only matches undef and nothing else
+        my $test = defined $got || defined $dont_expect;
+
+        $self->ok($test, $name);
+        $self->_cmp_diag($got, 'ne', $dont_expect) unless $test;
+        return $test;
+    }
+
+    return $self->cmp_ok($got, 'ne', $dont_expect, $name);
+}
+
+sub isnt_num {
+    my($self, $got, $dont_expect, $name) = @_;
+    local $Level = $Level + 1;
+
+    if( !defined $got || !defined $dont_expect ) {
+        # undef only matches undef and nothing else
+        my $test = defined $got || defined $dont_expect;
+
+        $self->ok($test, $name);
+        $self->_cmp_diag($got, '!=', $dont_expect) unless $test;
+        return $test;
+    }
+
+    return $self->cmp_ok($got, '!=', $dont_expect, $name);
+}
+
+
+=item B<like>
+
+  $Test->like($this, qr/$regex/, $name);
+  $Test->like($this, '/$regex/', $name);
+
+Like Test::More's like().  Checks if $this matches the given $regex.
+
+You'll want to avoid qr// if you want your tests to work before 5.005.
+
+=item B<unlike>
+
+  $Test->unlike($this, qr/$regex/, $name);
+  $Test->unlike($this, '/$regex/', $name);
+
+Like Test::More's unlike().  Checks if $this B<does not match> the
+given $regex.
+
+=cut
+
+sub like {
+    my($self, $this, $regex, $name) = @_;
+
+    local $Level = $Level + 1;
+    $self->_regex_ok($this, $regex, '=~', $name);
+}
+
+sub unlike {
+    my($self, $this, $regex, $name) = @_;
+
+    local $Level = $Level + 1;
+    $self->_regex_ok($this, $regex, '!~', $name);
+}
+
+=item B<maybe_regex>
+
+  $Test->maybe_regex(qr/$regex/);
+  $Test->maybe_regex('/$regex/');
+
+Convenience method for building testing functions that take regular
+expressions as arguments, but need to work before perl 5.005.
+
+Takes a quoted regular expression produced by qr//, or a string
+representing a regular expression.
+
+Returns a Perl value which may be used instead of the corresponding
+regular expression, or undef if it's argument is not recognised.
+
+For example, a version of like(), sans the useful diagnostic messages,
+could be written as:
+
+  sub laconic_like {
+      my ($self, $this, $regex, $name) = @_;
+      my $usable_regex = $self->maybe_regex($regex);
+      die "expecting regex, found '$regex'\n"
+          unless $usable_regex;
+      $self->ok($this =~ m/$usable_regex/, $name);
+  }
+
+=cut
+
+
+sub maybe_regex {
+    my ($self, $regex) = @_;
+    my $usable_regex = undef;
+
+    return $usable_regex unless defined $regex;
+
+    my($re, $opts);
+
+    # Check for qr/foo/
+    if( ref $regex eq 'Regexp' ) {
+        $usable_regex = $regex;
+    }
+    # Check for '/foo/' or 'm,foo,'
+    elsif( ($re, $opts)        = $regex =~ m{^ /(.*)/ (\w*) $ }sx           or
+           (undef, $re, $opts) = $regex =~ m,^ m([^\w\s]) (.+) \1 (\w*) $,sx
+         )
+    {
+        $usable_regex = length $opts ? "(?$opts)$re" : $re;
+    }
+
+    return $usable_regex;
+};
+
+sub _regex_ok {
+    my($self, $this, $regex, $cmp, $name) = @_;
+
+    local $Level = $Level + 1;
+
+    my $ok = 0;
+    my $usable_regex = $self->maybe_regex($regex);
+    unless (defined $usable_regex) {
+        $ok = $self->ok( 0, $name );
+        $self->diag("    '$regex' doesn't look much like a regex to me.");
+        return $ok;
+    }
+
+    {
+        local $^W = 0;
+        my $test = $this =~ /$usable_regex/ ? 1 : 0;
+        $test = !$test if $cmp eq '!~';
+        $ok = $self->ok( $test, $name );
+    }
+
+    unless( $ok ) {
+        $this = defined $this ? "'$this'" : 'undef';
+        my $match = $cmp eq '=~' ? "doesn't match" : "matches";
+        $self->diag(sprintf <<DIAGNOSTIC, $this, $match, $regex);
+                  %s
+    %13s '%s'
+DIAGNOSTIC
+
+    }
+
+    return $ok;
+}
+
+=item B<cmp_ok>
+
+  $Test->cmp_ok($this, $type, $that, $name);
+
+Works just like Test::More's cmp_ok().
+
+    $Test->cmp_ok($big_num, '!=', $other_big_num);
+
+=cut
+
+sub cmp_ok {
+    my($self, $got, $type, $expect, $name) = @_;
+
+    my $test;
+    {
+        local $^W = 0;
+        local($@,$!);   # don't interfere with $@
+                        # eval() sometimes resets $!
+        $test = eval "\$got $type \$expect";
+    }
+    local $Level = $Level + 1;
+    my $ok = $self->ok($test, $name);
+
+    unless( $ok ) {
+        if( $type =~ /^(eq|==)$/ ) {
+            $self->_is_diag($got, $type, $expect);
+        }
+        else {
+            $self->_cmp_diag($got, $type, $expect);
+        }
+    }
+    return $ok;
+}
+
+sub _cmp_diag {
+    my($self, $got, $type, $expect) = @_;
+    
+    $got    = defined $got    ? "'$got'"    : 'undef';
+    $expect = defined $expect ? "'$expect'" : 'undef';
+    return $self->diag(sprintf <<DIAGNOSTIC, $got, $type, $expect);
+    %s
+        %s
+    %s
+DIAGNOSTIC
+}
+
+=item B<BAILOUT>
+
+    $Test->BAILOUT($reason);
+
+Indicates to the Test::Harness that things are going so badly all
+testing should terminate.  This includes running any additional test
+scripts.
+
+It will exit with 255.
+
+=cut
+
+sub BAILOUT {
+    my($self, $reason) = @_;
+
+    $self->_print("Bail out!  $reason");
+    exit 255;
+}
+
+=item B<skip>
+
+    $Test->skip;
+    $Test->skip($why);
+
+Skips the current test, reporting $why.
+
+=cut
+
+sub skip {
+    my($self, $why) = @_;
+    $why ||= '';
+    $self->_unoverload(\$why);
+
+    unless( $self->{Have_Plan} ) {
+        require Carp;
+        Carp::croak("You tried to run tests without a plan!  Gotta have a plan.");
+    }
+
+    lock($self->{Curr_Test});
+    $self->{Curr_Test}++;
+
+    $self->{Test_Results}[$self->{Curr_Test}-1] = &share({
+        'ok'      => 1,
+        actual_ok => 1,
+        name      => '',
+        type      => 'skip',
+        reason    => $why,
+    });
+
+    my $out = "ok";
+    $out   .= " $self->{Curr_Test}" if $self->use_numbers;
+    $out   .= " # skip";
+    $out   .= " $why"       if length $why;
+    $out   .= "\n";
+
+    $self->_print($out);
+
+    return 1;
+}
+
+
+=item B<todo_skip>
+
+  $Test->todo_skip;
+  $Test->todo_skip($why);
+
+Like skip(), only it will declare the test as failing and TODO.  Similar
+to
+
+    print "not ok $tnum # TODO $why\n";
+
+=cut
+
+sub todo_skip {
+    my($self, $why) = @_;
+    $why ||= '';
+
+    unless( $self->{Have_Plan} ) {
+        require Carp;
+        Carp::croak("You tried to run tests without a plan!  Gotta have a plan.");
+    }
+
+    lock($self->{Curr_Test});
+    $self->{Curr_Test}++;
+
+    $self->{Test_Results}[$self->{Curr_Test}-1] = &share({
+        'ok'      => 1,
+        actual_ok => 0,
+        name      => '',
+        type      => 'todo_skip',
+        reason    => $why,
+    });
+
+    my $out = "not ok";
+    $out   .= " $self->{Curr_Test}" if $self->use_numbers;
+    $out   .= " # TODO & SKIP $why\n";
+
+    $self->_print($out);
+
+    return 1;
+}
+
+
+=begin _unimplemented
+
+=item B<skip_rest>
+
+  $Test->skip_rest;
+  $Test->skip_rest($reason);
+
+Like skip(), only it skips all the rest of the tests you plan to run
+and terminates the test.
+
+If you're running under no_plan, it skips once and terminates the
+test.
+
+=end _unimplemented
+
+=back
+
+
+=head2 Test style
+
+=over 4
+
+=item B<level>
+
+    $Test->level($how_high);
+
+How far up the call stack should $Test look when reporting where the
+test failed.
+
+Defaults to 1.
+
+Setting $Test::Builder::Level overrides.  This is typically useful
+localized:
+
+    {
+        local $Test::Builder::Level = 2;
+        $Test->ok($test);
+    }
+
+=cut
+
+sub level {
+    my($self, $level) = @_;
+
+    if( defined $level ) {
+        $Level = $level;
+    }
+    return $Level;
+}
+
+
+=item B<use_numbers>
+
+    $Test->use_numbers($on_or_off);
+
+Whether or not the test should output numbers.  That is, this if true:
+
+  ok 1
+  ok 2
+  ok 3
+
+or this if false
+
+  ok
+  ok
+  ok
+
+Most useful when you can't depend on the test output order, such as
+when threads or forking is involved.
+
+Test::Harness will accept either, but avoid mixing the two styles.
+
+Defaults to on.
+
+=cut
+
+sub use_numbers {
+    my($self, $use_nums) = @_;
+
+    if( defined $use_nums ) {
+        $self->{Use_Nums} = $use_nums;
+    }
+    return $self->{Use_Nums};
+}
+
+=item B<no_header>
+
+    $Test->no_header($no_header);
+
+If set to true, no "1..N" header will be printed.
+
+=item B<no_ending>
+
+    $Test->no_ending($no_ending);
+
+Normally, Test::Builder does some extra diagnostics when the test
+ends.  It also changes the exit code as described below.
+
+If this is true, none of that will be done.
+
+=cut
+
+sub no_header {
+    my($self, $no_header) = @_;
+
+    if( defined $no_header ) {
+        $self->{No_Header} = $no_header;
+    }
+    return $self->{No_Header};
+}
+
+sub no_ending {
+    my($self, $no_ending) = @_;
+
+    if( defined $no_ending ) {
+        $self->{No_Ending} = $no_ending;
+    }
+    return $self->{No_Ending};
+}
+
+
+=back
+
+=head2 Output
+
+Controlling where the test output goes.
+
+It's ok for your test to change where STDOUT and STDERR point to,
+Test::Builder's default output settings will not be affected.
+
+=over 4
+
+=item B<diag>
+
+    $Test->diag(@msgs);
+
+Prints out the given @msgs.  Like C<print>, arguments are simply
+appended together.
+
+Normally, it uses the failure_output() handle, but if this is for a
+TODO test, the todo_output() handle is used.
+
+Output will be indented and marked with a # so as not to interfere
+with test output.  A newline will be put on the end if there isn't one
+already.
+
+We encourage using this rather than calling print directly.
+
+Returns false.  Why?  Because diag() is often used in conjunction with
+a failing test (C<ok() || diag()>) it "passes through" the failure.
+
+    return ok(...) || diag(...);
+
+=for blame transfer
+Mark Fowler <mark@twoshortplanks.com>
+
+=cut
+
+sub diag {
+    my($self, @msgs) = @_;
+    return unless @msgs;
+
+    # Prevent printing headers when compiling (i.e. -c)
+    return if $^C;
+
+    # Smash args together like print does.
+    # Convert undef to 'undef' so its readable.
+    my $msg = join '', map { defined($_) ? $_ : 'undef' } @msgs;
+
+    # Escape each line with a #.
+    $msg =~ s/^/# /gm;
+
+    # Stick a newline on the end if it needs it.
+    $msg .= "\n" unless $msg =~ /\n\Z/;
+
+    local $Level = $Level + 1;
+    $self->_print_diag($msg);
+
+    return 0;
+}
+
+=begin _private
+
+=item B<_print>
+
+    $Test->_print(@msgs);
+
+Prints to the output() filehandle.
+
+=end _private
+
+=cut
+
+sub _print {
+    my($self, @msgs) = @_;
+
+    # Prevent printing headers when only compiling.  Mostly for when
+    # tests are deparsed with B::Deparse
+    return if $^C;
+
+    my $msg = join '', @msgs;
+
+    local($\, $", $,) = (undef, ' ', '');
+    my $fh = $self->output;
+
+    # Escape each line after the first with a # so we don't
+    # confuse Test::Harness.
+    $msg =~ s/\n(.)/\n# $1/sg;
+
+    # Stick a newline on the end if it needs it.
+    $msg .= "\n" unless $msg =~ /\n\Z/;
+
+    print $fh $msg;
+}
+
+
+=item B<_print_diag>
+
+    $Test->_print_diag(@msg);
+
+Like _print, but prints to the current diagnostic filehandle.
+
+=cut
+
+sub _print_diag {
+    my $self = shift;
+
+    local($\, $", $,) = (undef, ' ', '');
+    my $fh = $self->todo ? $self->todo_output : $self->failure_output;
+    print $fh @_;
+}    
+
+=item B<output>
+
+    $Test->output($fh);
+    $Test->output($file);
+
+Where normal "ok/not ok" test output should go.
+
+Defaults to STDOUT.
+
+=item B<failure_output>
+
+    $Test->failure_output($fh);
+    $Test->failure_output($file);
+
+Where diagnostic output on test failures and diag() should go.
+
+Defaults to STDERR.
+
+=item B<todo_output>
+
+    $Test->todo_output($fh);
+    $Test->todo_output($file);
+
+Where diagnostics about todo test failures and diag() should go.
+
+Defaults to STDOUT.
+
+=cut
+
+sub output {
+    my($self, $fh) = @_;
+
+    if( defined $fh ) {
+        $self->{Out_FH} = _new_fh($fh);
+    }
+    return $self->{Out_FH};
+}
+
+sub failure_output {
+    my($self, $fh) = @_;
+
+    if( defined $fh ) {
+        $self->{Fail_FH} = _new_fh($fh);
+    }
+    return $self->{Fail_FH};
+}
+
+sub todo_output {
+    my($self, $fh) = @_;
+
+    if( defined $fh ) {
+        $self->{Todo_FH} = _new_fh($fh);
+    }
+    return $self->{Todo_FH};
+}
+
+
+sub _new_fh {
+    my($file_or_fh) = shift;
+
+    my $fh;
+    if( _is_fh($file_or_fh) ) {
+        $fh = $file_or_fh;
+    }
+    else {
+        $fh = do { local *FH };
+        open $fh, ">$file_or_fh" or 
+            die "Can't open test output log $file_or_fh: $!";
+	_autoflush($fh);
+    }
+
+    return $fh;
+}
+
+
+sub _is_fh {
+    my $maybe_fh = shift;
+
+    return 1 if ref \$maybe_fh eq 'GLOB'; # its a glob
+
+    return UNIVERSAL::isa($maybe_fh,               'GLOB')       ||
+           UNIVERSAL::isa($maybe_fh,               'IO::Handle') ||
+
+           # 5.5.4's tied() and can() doesn't like getting undef
+           UNIVERSAL::can((tied($maybe_fh) || ''), 'TIEHANDLE');
+}
+
+
+sub _autoflush {
+    my($fh) = shift;
+    my $old_fh = select $fh;
+    $| = 1;
+    select $old_fh;
+}
+
+
+sub _dup_stdhandles {
+    my $self = shift;
+
+    $self->_open_testhandles;
+
+    # Set everything to unbuffered else plain prints to STDOUT will
+    # come out in the wrong order from our own prints.
+    _autoflush(\*TESTOUT);
+    _autoflush(\*STDOUT);
+    _autoflush(\*TESTERR);
+    _autoflush(\*STDERR);
+
+    $self->output(\*TESTOUT);
+    $self->failure_output(\*TESTERR);
+    $self->todo_output(\*TESTOUT);
+}
+
+
+my $Opened_Testhandles = 0;
+sub _open_testhandles {
+    return if $Opened_Testhandles;
+    # We dup STDOUT and STDERR so people can change them in their
+    # test suites while still getting normal test output.
+    open(TESTOUT, ">&STDOUT") or die "Can't dup STDOUT:  $!";
+    open(TESTERR, ">&STDERR") or die "Can't dup STDERR:  $!";
+    $Opened_Testhandles = 1;
+}
+
+
+=back
+
+
+=head2 Test Status and Info
+
+=over 4
+
+=item B<current_test>
+
+    my $curr_test = $Test->current_test;
+    $Test->current_test($num);
+
+Gets/sets the current test number we're on.  You usually shouldn't
+have to set this.
+
+If set forward, the details of the missing tests are filled in as 'unknown'.
+if set backward, the details of the intervening tests are deleted.  You
+can erase history if you really want to.
+
+=cut
+
+sub current_test {
+    my($self, $num) = @_;
+
+    lock($self->{Curr_Test});
+    if( defined $num ) {
+        unless( $self->{Have_Plan} ) {
+            require Carp;
+            Carp::croak("Can't change the current test number without a plan!");
+        }
+
+        $self->{Curr_Test} = $num;
+
+        # If the test counter is being pushed forward fill in the details.
+        my $test_results = $self->{Test_Results};
+        if( $num > @$test_results ) {
+            my $start = @$test_results ? @$test_results : 0;
+            for ($start..$num-1) {
+                $test_results->[$_] = &share({
+                    'ok'      => 1, 
+                    actual_ok => undef, 
+                    reason    => 'incrementing test number', 
+                    type      => 'unknown', 
+                    name      => undef 
+                });
+            }
+        }
+        # If backward, wipe history.  Its their funeral.
+        elsif( $num < @$test_results ) {
+            $#{$test_results} = $num - 1;
+        }
+    }
+    return $self->{Curr_Test};
+}
+
+
+=item B<summary>
+
+    my @tests = $Test->summary;
+
+A simple summary of the tests so far.  True for pass, false for fail.
+This is a logical pass/fail, so todos are passes.
+
+Of course, test #1 is $tests[0], etc...
+
+=cut
+
+sub summary {
+    my($self) = shift;
+
+    return map { $_->{'ok'} } @{ $self->{Test_Results} };
+}
+
+=item B<details>
+
+    my @tests = $Test->details;
+
+Like summary(), but with a lot more detail.
+
+    $tests[$test_num - 1] = 
+            { 'ok'       => is the test considered a pass?
+              actual_ok  => did it literally say 'ok'?
+              name       => name of the test (if any)
+              type       => type of test (if any, see below).
+              reason     => reason for the above (if any)
+            };
+
+'ok' is true if Test::Harness will consider the test to be a pass.
+
+'actual_ok' is a reflection of whether or not the test literally
+printed 'ok' or 'not ok'.  This is for examining the result of 'todo'
+tests.  
+
+'name' is the name of the test.
+
+'type' indicates if it was a special test.  Normal tests have a type
+of ''.  Type can be one of the following:
+
+    skip        see skip()
+    todo        see todo()
+    todo_skip   see todo_skip()
+    unknown     see below
+
+Sometimes the Test::Builder test counter is incremented without it
+printing any test output, for example, when current_test() is changed.
+In these cases, Test::Builder doesn't know the result of the test, so
+it's type is 'unkown'.  These details for these tests are filled in.
+They are considered ok, but the name and actual_ok is left undef.
+
+For example "not ok 23 - hole count # TODO insufficient donuts" would
+result in this structure:
+
+    $tests[22] =    # 23 - 1, since arrays start from 0.
+      { ok        => 1,   # logically, the test passed since it's todo
+        actual_ok => 0,   # in absolute terms, it failed
+        name      => 'hole count',
+        type      => 'todo',
+        reason    => 'insufficient donuts'
+      };
+
+=cut
+
+sub details {
+    my $self = shift;
+    return @{ $self->{Test_Results} };
+}
+
+=item B<todo>
+
+    my $todo_reason = $Test->todo;
+    my $todo_reason = $Test->todo($pack);
+
+todo() looks for a $TODO variable in your tests.  If set, all tests
+will be considered 'todo' (see Test::More and Test::Harness for
+details).  Returns the reason (ie. the value of $TODO) if running as
+todo tests, false otherwise.
+
+todo() is about finding the right package to look for $TODO in.  It
+uses the exported_to() package to find it.  If that's not set, it's
+pretty good at guessing the right package to look at based on $Level.
+
+Sometimes there is some confusion about where todo() should be looking
+for the $TODO variable.  If you want to be sure, tell it explicitly
+what $pack to use.
+
+=cut
+
+sub todo {
+    my($self, $pack) = @_;
+
+    $pack = $pack || $self->exported_to || $self->caller($Level);
+    return 0 unless $pack;
+
+    no strict 'refs';
+    return defined ${$pack.'::TODO'} ? ${$pack.'::TODO'}
+                                     : 0;
+}
+
+=item B<caller>
+
+    my $package = $Test->caller;
+    my($pack, $file, $line) = $Test->caller;
+    my($pack, $file, $line) = $Test->caller($height);
+
+Like the normal caller(), except it reports according to your level().
+
+=cut
+
+sub caller {
+    my($self, $height) = @_;
+    $height ||= 0;
+
+    my @caller = CORE::caller($self->level + $height + 1);
+    return wantarray ? @caller : $caller[0];
+}
+
+=back
+
+=cut
+
+=begin _private
+
+=over 4
+
+=item B<_sanity_check>
+
+  $self->_sanity_check();
+
+Runs a bunch of end of test sanity checks to make sure reality came
+through ok.  If anything is wrong it will die with a fairly friendly
+error message.
+
+=cut
+
+#'#
+sub _sanity_check {
+    my $self = shift;
+
+    _whoa($self->{Curr_Test} < 0,  'Says here you ran a negative number of tests!');
+    _whoa(!$self->{Have_Plan} and $self->{Curr_Test}, 
+          'Somehow your tests ran without a plan!');
+    _whoa($self->{Curr_Test} != @{ $self->{Test_Results} },
+          'Somehow you got a different number of results than tests ran!');
+}
+
+=item B<_whoa>
+
+  _whoa($check, $description);
+
+A sanity check, similar to assert().  If the $check is true, something
+has gone horribly wrong.  It will die with the given $description and
+a note to contact the author.
+
+=cut
+
+sub _whoa {
+    my($check, $desc) = @_;
+    if( $check ) {
+        die <<WHOA;
+WHOA!  $desc
+This should never happen!  Please contact the author immediately!
+WHOA
+    }
+}
+
+=item B<_my_exit>
+
+  _my_exit($exit_num);
+
+Perl seems to have some trouble with exiting inside an END block.  5.005_03
+and 5.6.1 both seem to do odd things.  Instead, this function edits $?
+directly.  It should ONLY be called from inside an END block.  It
+doesn't actually exit, that's your job.
+
+=cut
+
+sub _my_exit {
+    $? = $_[0];
+
+    return 1;
+}
+
+
+=back
+
+=end _private
+
+=cut
+
+$SIG{__DIE__} = sub {
+    # We don't want to muck with death in an eval, but $^S isn't
+    # totally reliable.  5.005_03 and 5.6.1 both do the wrong thing
+    # with it.  Instead, we use caller.  This also means it runs under
+    # 5.004!
+    my $in_eval = 0;
+    for( my $stack = 1;  my $sub = (CORE::caller($stack))[3];  $stack++ ) {
+        $in_eval = 1 if $sub =~ /^\(eval\)/;
+    }
+    $Test->{Test_Died} = 1 unless $in_eval;
+};
+
+sub _ending {
+    my $self = shift;
+
+    $self->_sanity_check();
+
+    # Don't bother with an ending if this is a forked copy.  Only the parent
+    # should do the ending.
+    # Exit if plan() was never called.  This is so "require Test::Simple" 
+    # doesn't puke.
+    if( ($self->{Original_Pid} != $$) or
+	(!$self->{Have_Plan} && !$self->{Test_Died}) )
+    {
+	_my_exit($?);
+	return;
+    }
+
+    # Figure out if we passed or failed and print helpful messages.
+    my $test_results = $self->{Test_Results};
+    if( @$test_results ) {
+        # The plan?  We have no plan.
+        if( $self->{No_Plan} ) {
+            $self->_print("1..$self->{Curr_Test}\n") unless $self->no_header;
+            $self->{Expected_Tests} = $self->{Curr_Test};
+        }
+
+        # Auto-extended arrays and elements which aren't explicitly
+        # filled in with a shared reference will puke under 5.8.0
+        # ithreads.  So we have to fill them in by hand. :(
+        my $empty_result = &share({});
+        for my $idx ( 0..$self->{Expected_Tests}-1 ) {
+            $test_results->[$idx] = $empty_result
+              unless defined $test_results->[$idx];
+        }
+
+        my $num_failed = grep !$_->{'ok'}, 
+                              @{$test_results}[0..$self->{Expected_Tests}-1];
+        $num_failed += abs($self->{Expected_Tests} - @$test_results);
+
+        if( $self->{Curr_Test} < $self->{Expected_Tests} ) {
+            my $s = $self->{Expected_Tests} == 1 ? '' : 's';
+            $self->diag(<<"FAIL");
+Looks like you planned $self->{Expected_Tests} test$s but only ran $self->{Curr_Test}.
+FAIL
+        }
+        elsif( $self->{Curr_Test} > $self->{Expected_Tests} ) {
+            my $num_extra = $self->{Curr_Test} - $self->{Expected_Tests};
+            my $s = $self->{Expected_Tests} == 1 ? '' : 's';
+            $self->diag(<<"FAIL");
+Looks like you planned $self->{Expected_Tests} test$s but ran $num_extra extra.
+FAIL
+        }
+        elsif ( $num_failed ) {
+            my $s = $num_failed == 1 ? '' : 's';
+            $self->diag(<<"FAIL");
+Looks like you failed $num_failed test$s of $self->{Expected_Tests}.
+FAIL
+        }
+
+        if( $self->{Test_Died} ) {
+            $self->diag(<<"FAIL");
+Looks like your test died just after $self->{Curr_Test}.
+FAIL
+
+            _my_exit( 255 ) && return;
+        }
+
+        _my_exit( $num_failed <= 254 ? $num_failed : 254  ) && return;
+    }
+    elsif ( $self->{Skip_All} ) {
+        _my_exit( 0 ) && return;
+    }
+    elsif ( $self->{Test_Died} ) {
+        $self->diag(<<'FAIL');
+Looks like your test died before it could output anything.
+FAIL
+        _my_exit( 255 ) && return;
+    }
+    else {
+        $self->diag("No tests run!\n");
+        _my_exit( 255 ) && return;
+    }
+}
+
+END {
+    $Test->_ending if defined $Test and !$Test->no_ending;
+}
+
+=head1 EXIT CODES
+
+If all your tests passed, Test::Builder will exit with zero (which is
+normal).  If anything failed it will exit with how many failed.  If
+you run less (or more) tests than you planned, the missing (or extras)
+will be considered failures.  If no tests were ever run Test::Builder
+will throw a warning and exit with 255.  If the test died, even after
+having successfully completed all its tests, it will still be
+considered a failure and will exit with 255.
+
+So the exit codes are...
+
+    0                   all tests successful
+    255                 test died
+    any other number    how many failed (including missing or extras)
+
+If you fail more than 254 tests, it will be reported as 254.
+
+
+=head1 THREADS
+
+In perl 5.8.0 and later, Test::Builder is thread-safe.  The test
+number is shared amongst all threads.  This means if one thread sets
+the test number using current_test() they will all be effected.
+
+Test::Builder is only thread-aware if threads.pm is loaded I<before>
+Test::Builder.
+
+=head1 EXAMPLES
+
+CPAN can provide the best examples.  Test::Simple, Test::More,
+Test::Exception and Test::Differences all use Test::Builder.
+
+=head1 SEE ALSO
+
+Test::Simple, Test::More, Test::Harness
+
+=head1 AUTHORS
+
+Original code by chromatic, maintained by Michael G Schwern
+E<lt>schwern@pobox.comE<gt>
+
+=head1 COPYRIGHT
+
+Copyright 2002, 2004 by chromatic E<lt>chromatic@wgz.orgE<gt> and
+                        Michael G Schwern E<lt>schwern@pobox.comE<gt>.
+
+This program is free software; you can redistribute it and/or 
+modify it under the same terms as Perl itself.
+
+See F<http://www.perl.com/perl/misc/Artistic.html>
+
+=cut
+
+1;
diff -urN perl-5.10.0/ext/IO_Compress_Base/t.xxx/Test/More.pm perl-5.10.0/ext/IO_Compress_Base/t/Test/More.pm
--- perl-5.10.0/ext/IO_Compress_Base/t.xxx/Test/More.pm	1970-01-01 01:00:00.000000000 +0100
+++ perl-5.10.0/ext/IO_Compress_Base/t/Test/More.pm	2008-05-05 14:09:25.000000000 +0200
@@ -0,0 +1,1493 @@
+package Test::More;
+
+use 5.004;
+
+use strict;
+use Test::Builder;
+
+
+# Can't use Carp because it might cause use_ok() to accidentally succeed
+# even though the module being used forgot to use Carp.  Yes, this
+# actually happened.
+sub _carp {
+    my($file, $line) = (caller(1))[1,2];
+    warn @_, " at $file line $line\n";
+}
+
+
+
+require Exporter;
+our ($VERSION, @ISA, @EXPORT, %EXPORT_TAGS, $TODO);
+$VERSION = '0.60';
+$VERSION = eval $VERSION;    # make the alpha version come out as a number
+
+@ISA    = qw(Exporter);
+@EXPORT = qw(ok use_ok require_ok
+             is isnt like unlike is_deeply
+             cmp_ok
+             skip todo todo_skip
+             pass fail
+             eq_array eq_hash eq_set
+             $TODO
+             plan
+             can_ok  isa_ok
+             diag
+            );
+
+my $Test = Test::Builder->new;
+my $Show_Diag = 1;
+
+
+# 5.004's Exporter doesn't have export_to_level.
+sub _export_to_level
+{
+      my $pkg = shift;
+      my $level = shift;
+      (undef) = shift;                  # redundant arg
+      my $callpkg = caller($level);
+      $pkg->export($callpkg, @_);
+}
+
+
+=head1 NAME
+
+Test::More - yet another framework for writing test scripts
+
+=head1 SYNOPSIS
+
+  use Test::More tests => $Num_Tests;
+  # or
+  use Test::More qw(no_plan);
+  # or
+  use Test::More skip_all => $reason;
+
+  BEGIN { use_ok( 'Some::Module' ); }
+  require_ok( 'Some::Module' );
+
+  # Various ways to say "ok"
+  ok($this eq $that, $test_name);
+
+  is  ($this, $that,    $test_name);
+  isnt($this, $that,    $test_name);
+
+  # Rather than print STDERR "# here's what went wrong\n"
+  diag("here's what went wrong");
+
+  like  ($this, qr/that/, $test_name);
+  unlike($this, qr/that/, $test_name);
+
+  cmp_ok($this, '==', $that, $test_name);
+
+  is_deeply($complex_structure1, $complex_structure2, $test_name);
+
+  SKIP: {
+      skip $why, $how_many unless $have_some_feature;
+
+      ok( foo(),       $test_name );
+      is( foo(42), 23, $test_name );
+  };
+
+  TODO: {
+      local $TODO = $why;
+
+      ok( foo(),       $test_name );
+      is( foo(42), 23, $test_name );
+  };
+
+  can_ok($module, @methods);
+  isa_ok($object, $class);
+
+  pass($test_name);
+  fail($test_name);
+
+  # UNIMPLEMENTED!!!
+  my @status = Test::More::status;
+
+  # UNIMPLEMENTED!!!
+  BAIL_OUT($why);
+
+
+=head1 DESCRIPTION
+
+B<STOP!> If you're just getting started writing tests, have a look at
+Test::Simple first.  This is a drop in replacement for Test::Simple
+which you can switch to once you get the hang of basic testing.
+
+The purpose of this module is to provide a wide range of testing
+utilities.  Various ways to say "ok" with better diagnostics,
+facilities to skip tests, test future features and compare complicated
+data structures.  While you can do almost anything with a simple
+C<ok()> function, it doesn't provide good diagnostic output.
+
+
+=head2 I love it when a plan comes together
+
+Before anything else, you need a testing plan.  This basically declares
+how many tests your script is going to run to protect against premature
+failure.
+
+The preferred way to do this is to declare a plan when you C<use Test::More>.
+
+  use Test::More tests => $Num_Tests;
+
+There are rare cases when you will not know beforehand how many tests
+your script is going to run.  In this case, you can declare that you
+have no plan.  (Try to avoid using this as it weakens your test.)
+
+  use Test::More qw(no_plan);
+
+B<NOTE>: using no_plan requires a Test::Harness upgrade else it will
+think everything has failed.  See L<BUGS>)
+
+In some cases, you'll want to completely skip an entire testing script.
+
+  use Test::More skip_all => $skip_reason;
+
+Your script will declare a skip with the reason why you skipped and
+exit immediately with a zero (success).  See L<Test::Harness> for
+details.
+
+If you want to control what functions Test::More will export, you
+have to use the 'import' option.  For example, to import everything
+but 'fail', you'd do:
+
+  use Test::More tests => 23, import => ['!fail'];
+
+Alternatively, you can use the plan() function.  Useful for when you
+have to calculate the number of tests.
+
+  use Test::More;
+  plan tests => keys %Stuff * 3;
+
+or for deciding between running the tests at all:
+
+  use Test::More;
+  if( $^O eq 'MacOS' ) {
+      plan skip_all => 'Test irrelevant on MacOS';
+  }
+  else {
+      plan tests => 42;
+  }
+
+=cut
+
+sub plan {
+    my(@plan) = @_;
+
+    my $idx = 0;
+    my @cleaned_plan;
+    while( $idx <= $#plan ) {
+        my $item = $plan[$idx];
+
+        if( $item eq 'no_diag' ) {
+            $Show_Diag = 0;
+        }
+        else {
+            push @cleaned_plan, $item;
+        }
+
+        $idx++;
+    }
+
+    $Test->plan(@cleaned_plan);
+}
+
+sub import {
+    my($class) = shift;
+
+    my $caller = caller;
+
+    $Test->exported_to($caller);
+
+    my $idx = 0;
+    my @plan;
+    my @imports;
+    while( $idx <= $#_ ) {
+        my $item = $_[$idx];
+
+        if( $item eq 'import' ) {
+            push @imports, @{$_[$idx+1]};
+            $idx++;
+        }
+        else {
+            push @plan, $item;
+        }
+
+        $idx++;
+    }
+
+    plan(@plan);
+
+    __PACKAGE__->_export_to_level(1, __PACKAGE__, @imports);
+}
+
+
+=head2 Test names
+
+By convention, each test is assigned a number in order.  This is
+largely done automatically for you.  However, it's often very useful to
+assign a name to each test.  Which would you rather see:
+
+  ok 4
+  not ok 5
+  ok 6
+
+or
+
+  ok 4 - basic multi-variable
+  not ok 5 - simple exponential
+  ok 6 - force == mass * acceleration
+
+The later gives you some idea of what failed.  It also makes it easier
+to find the test in your script, simply search for "simple
+exponential".
+
+All test functions take a name argument.  It's optional, but highly
+suggested that you use it.
+
+
+=head2 I'm ok, you're not ok.
+
+The basic purpose of this module is to print out either "ok #" or "not
+ok #" depending on if a given test succeeded or failed.  Everything
+else is just gravy.
+
+All of the following print "ok" or "not ok" depending on if the test
+succeeded or failed.  They all also return true or false,
+respectively.
+
+=over 4
+
+=item B<ok>
+
+  ok($this eq $that, $test_name);
+
+This simply evaluates any expression (C<$this eq $that> is just a
+simple example) and uses that to determine if the test succeeded or
+failed.  A true expression passes, a false one fails.  Very simple.
+
+For example:
+
+    ok( $exp{9} == 81,                   'simple exponential' );
+    ok( Film->can('db_Main'),            'set_db()' );
+    ok( $p->tests == 4,                  'saw tests' );
+    ok( !grep !defined $_, @items,       'items populated' );
+
+(Mnemonic:  "This is ok.")
+
+$test_name is a very short description of the test that will be printed
+out.  It makes it very easy to find a test in your script when it fails
+and gives others an idea of your intentions.  $test_name is optional,
+but we B<very> strongly encourage its use.
+
+Should an ok() fail, it will produce some diagnostics:
+
+    not ok 18 - sufficient mucus
+    #     Failed test 18 (foo.t at line 42)
+
+This is actually Test::Simple's ok() routine.
+
+=cut
+
+sub ok ($;$) {
+    my($test, $name) = @_;
+    $Test->ok($test, $name);
+}
+
+=item B<is>
+
+=item B<isnt>
+
+  is  ( $this, $that, $test_name );
+  isnt( $this, $that, $test_name );
+
+Similar to ok(), is() and isnt() compare their two arguments
+with C<eq> and C<ne> respectively and use the result of that to
+determine if the test succeeded or failed.  So these:
+
+    # Is the ultimate answer 42?
+    is( ultimate_answer(), 42,          "Meaning of Life" );
+
+    # $foo isn't empty
+    isnt( $foo, '',     "Got some foo" );
+
+are similar to these:
+
+    ok( ultimate_answer() eq 42,        "Meaning of Life" );
+    ok( $foo ne '',     "Got some foo" );
+
+(Mnemonic:  "This is that."  "This isn't that.")
+
+So why use these?  They produce better diagnostics on failure.  ok()
+cannot know what you are testing for (beyond the name), but is() and
+isnt() know what the test was and why it failed.  For example this
+test:
+
+    my $foo = 'waffle';  my $bar = 'yarblokos';
+    is( $foo, $bar,   'Is foo the same as bar?' );
+
+Will produce something like this:
+
+    not ok 17 - Is foo the same as bar?
+    #     Failed test (foo.t at line 139)
+    #          got: 'waffle'
+    #     expected: 'yarblokos'
+
+So you can figure out what went wrong without rerunning the test.
+
+You are encouraged to use is() and isnt() over ok() where possible,
+however do not be tempted to use them to find out if something is
+true or false!
+
+  # XXX BAD!
+  is( exists $brooklyn{tree}, 1, 'A tree grows in Brooklyn' );
+
+This does not check if C<exists $brooklyn{tree}> is true, it checks if
+it returns 1.  Very different.  Similar caveats exist for false and 0.
+In these cases, use ok().
+
+  ok( exists $brooklyn{tree},    'A tree grows in Brooklyn' );
+
+For those grammatical pedants out there, there's an C<isn't()>
+function which is an alias of isnt().
+
+=cut
+
+sub is ($$;$) {
+    $Test->is_eq(@_);
+}
+
+sub isnt ($$;$) {
+    $Test->isnt_eq(@_);
+}
+
+*isn't = \&isnt;
+
+
+=item B<like>
+
+  like( $this, qr/that/, $test_name );
+
+Similar to ok(), like() matches $this against the regex C<qr/that/>.
+
+So this:
+
+    like($this, qr/that/, 'this is like that');
+
+is similar to:
+
+    ok( $this =~ /that/, 'this is like that');
+
+(Mnemonic "This is like that".)
+
+The second argument is a regular expression.  It may be given as a
+regex reference (i.e. C<qr//>) or (for better compatibility with older
+perls) as a string that looks like a regex (alternative delimiters are
+currently not supported):
+
+    like( $this, '/that/', 'this is like that' );
+
+Regex options may be placed on the end (C<'/that/i'>).
+
+Its advantages over ok() are similar to that of is() and isnt().  Better
+diagnostics on failure.
+
+=cut
+
+sub like ($$;$) {
+    $Test->like(@_);
+}
+
+
+=item B<unlike>
+
+  unlike( $this, qr/that/, $test_name );
+
+Works exactly as like(), only it checks if $this B<does not> match the
+given pattern.
+
+=cut
+
+sub unlike ($$;$) {
+    $Test->unlike(@_);
+}
+
+
+=item B<cmp_ok>
+
+  cmp_ok( $this, $op, $that, $test_name );
+
+Halfway between ok() and is() lies cmp_ok().  This allows you to
+compare two arguments using any binary perl operator.
+
+    # ok( $this eq $that );
+    cmp_ok( $this, 'eq', $that, 'this eq that' );
+
+    # ok( $this == $that );
+    cmp_ok( $this, '==', $that, 'this == that' );
+
+    # ok( $this && $that );
+    cmp_ok( $this, '&&', $that, 'this && that' );
+    ...etc...
+
+Its advantage over ok() is when the test fails you'll know what $this
+and $that were:
+
+    not ok 1
+    #     Failed test (foo.t at line 12)
+    #     '23'
+    #         &&
+    #     undef
+
+It's also useful in those cases where you are comparing numbers and
+is()'s use of C<eq> will interfere:
+
+    cmp_ok( $big_hairy_number, '==', $another_big_hairy_number );
+
+=cut
+
+sub cmp_ok($$$;$) {
+    $Test->cmp_ok(@_);
+}
+
+
+=item B<can_ok>
+
+  can_ok($module, @methods);
+  can_ok($object, @methods);
+
+Checks to make sure the $module or $object can do these @methods
+(works with functions, too).
+
+    can_ok('Foo', qw(this that whatever));
+
+is almost exactly like saying:
+
+    ok( Foo->can('this') && 
+        Foo->can('that') && 
+        Foo->can('whatever') 
+      );
+
+only without all the typing and with a better interface.  Handy for
+quickly testing an interface.
+
+No matter how many @methods you check, a single can_ok() call counts
+as one test.  If you desire otherwise, use:
+
+    foreach my $meth (@methods) {
+        can_ok('Foo', $meth);
+    }
+
+=cut
+
+sub can_ok ($@) {
+    my($proto, @methods) = @_;
+    my $class = ref $proto || $proto;
+
+    unless( @methods ) {
+        my $ok = $Test->ok( 0, "$class->can(...)" );
+        $Test->diag('    can_ok() called with no methods');
+        return $ok;
+    }
+
+    my @nok = ();
+    foreach my $method (@methods) {
+        local($!, $@);  # don't interfere with caller's $@
+                        # eval sometimes resets $!
+        eval { $proto->can($method) } || push @nok, $method;
+    }
+
+    my $name;
+    $name = @methods == 1 ? "$class->can('$methods[0]')" 
+                          : "$class->can(...)";
+    
+    my $ok = $Test->ok( !@nok, $name );
+
+    $Test->diag(map "    $class->can('$_') failed\n", @nok);
+
+    return $ok;
+}
+
+=item B<isa_ok>
+
+  isa_ok($object, $class, $object_name);
+  isa_ok($ref,    $type,  $ref_name);
+
+Checks to see if the given C<< $object->isa($class) >>.  Also checks to make
+sure the object was defined in the first place.  Handy for this sort
+of thing:
+
+    my $obj = Some::Module->new;
+    isa_ok( $obj, 'Some::Module' );
+
+where you'd otherwise have to write
+
+    my $obj = Some::Module->new;
+    ok( defined $obj && $obj->isa('Some::Module') );
+
+to safeguard against your test script blowing up.
+
+It works on references, too:
+
+    isa_ok( $array_ref, 'ARRAY' );
+
+The diagnostics of this test normally just refer to 'the object'.  If
+you'd like them to be more specific, you can supply an $object_name
+(for example 'Test customer').
+
+=cut
+
+sub isa_ok ($$;$) {
+    my($object, $class, $obj_name) = @_;
+
+    my $diag;
+    $obj_name = 'The object' unless defined $obj_name;
+    my $name = "$obj_name isa $class";
+    if( !defined $object ) {
+        $diag = "$obj_name isn't defined";
+    }
+    elsif( !ref $object ) {
+        $diag = "$obj_name isn't a reference";
+    }
+    else {
+        # We can't use UNIVERSAL::isa because we want to honor isa() overrides
+        local($@, $!);  # eval sometimes resets $!
+        my $rslt = eval { $object->isa($class) };
+        if( $@ ) {
+            if( $@ =~ /^Can't call method "isa" on unblessed reference/ ) {
+                if( !UNIVERSAL::isa($object, $class) ) {
+                    my $ref = ref $object;
+                    $diag = "$obj_name isn't a '$class' it's a '$ref'";
+                }
+            } else {
+                die <<WHOA;
+WHOA! I tried to call ->isa on your object and got some weird error.
+This should never happen.  Please contact the author immediately.
+Here's the error.
+$@
+WHOA
+            }
+        }
+        elsif( !$rslt ) {
+            my $ref = ref $object;
+            $diag = "$obj_name isn't a '$class' it's a '$ref'";
+        }
+    }
+            
+      
+
+    my $ok;
+    if( $diag ) {
+        $ok = $Test->ok( 0, $name );
+        $Test->diag("    $diag\n");
+    }
+    else {
+        $ok = $Test->ok( 1, $name );
+    }
+
+    return $ok;
+}
+
+
+=item B<pass>
+
+=item B<fail>
+
+  pass($test_name);
+  fail($test_name);
+
+Sometimes you just want to say that the tests have passed.  Usually
+the case is you've got some complicated condition that is difficult to
+wedge into an ok().  In this case, you can simply use pass() (to
+declare the test ok) or fail (for not ok).  They are synonyms for
+ok(1) and ok(0).
+
+Use these very, very, very sparingly.
+
+=cut
+
+sub pass (;$) {
+    $Test->ok(1, @_);
+}
+
+sub fail (;$) {
+    $Test->ok(0, @_);
+}
+
+=back
+
+=head2 Diagnostics
+
+If you pick the right test function, you'll usually get a good idea of
+what went wrong when it failed.  But sometimes it doesn't work out
+that way.  So here we have ways for you to write your own diagnostic
+messages which are safer than just C<print STDERR>.
+
+=over 4
+
+=item B<diag>
+
+  diag(@diagnostic_message);
+
+Prints a diagnostic message which is guaranteed not to interfere with
+test output.  Like C<print> @diagnostic_message is simply concatinated
+together.
+
+Handy for this sort of thing:
+
+    ok( grep(/foo/, @users), "There's a foo user" ) or
+        diag("Since there's no foo, check that /etc/bar is set up right");
+
+which would produce:
+
+    not ok 42 - There's a foo user
+    #     Failed test (foo.t at line 52)
+    # Since there's no foo, check that /etc/bar is set up right.
+
+You might remember C<ok() or diag()> with the mnemonic C<open() or
+die()>.
+
+All diag()s can be made silent by passing the "no_diag" option to
+Test::More.  C<use Test::More tests => 1, 'no_diag'>.  This is useful
+if you have diagnostics for personal testing but then wish to make
+them silent for release without commenting out each individual
+statement.
+
+B<NOTE> The exact formatting of the diagnostic output is still
+changing, but it is guaranteed that whatever you throw at it it won't
+interfere with the test.
+
+=cut
+
+sub diag {
+    return unless $Show_Diag;
+    $Test->diag(@_);
+}
+
+
+=back
+
+=head2 Module tests
+
+You usually want to test if the module you're testing loads ok, rather
+than just vomiting if its load fails.  For such purposes we have
+C<use_ok> and C<require_ok>.
+
+=over 4
+
+=item B<use_ok>
+
+   BEGIN { use_ok($module); }
+   BEGIN { use_ok($module, @imports); }
+
+These simply use the given $module and test to make sure the load
+happened ok.  It's recommended that you run use_ok() inside a BEGIN
+block so its functions are exported at compile-time and prototypes are
+properly honored.
+
+If @imports are given, they are passed through to the use.  So this:
+
+   BEGIN { use_ok('Some::Module', qw(foo bar)) }
+
+is like doing this:
+
+   use Some::Module qw(foo bar);
+
+Version numbers can be checked like so:
+
+   # Just like "use Some::Module 1.02"
+   BEGIN { use_ok('Some::Module', 1.02) }
+
+Don't try to do this:
+
+   BEGIN {
+       use_ok('Some::Module');
+
+       ...some code that depends on the use...
+       ...happening at compile time...
+   }
+
+because the notion of "compile-time" is relative.  Instead, you want:
+
+  BEGIN { use_ok('Some::Module') }
+  BEGIN { ...some code that depends on the use... }
+
+
+=cut
+
+sub use_ok ($;@) {
+    my($module, @imports) = @_;
+    @imports = () unless @imports;
+
+    my($pack,$filename,$line) = caller;
+
+    local($@,$!);   # eval sometimes interferes with $!
+
+    if( @imports == 1 and $imports[0] =~ /^\d+(?:\.\d+)?$/ ) {
+        # probably a version check.  Perl needs to see the bare number
+        # for it to work with non-Exporter based modules.
+        eval <<USE;
+package $pack;
+use $module $imports[0];
+USE
+    }
+    else {
+        eval <<USE;
+package $pack;
+use $module \@imports;
+USE
+    }
+
+    my $ok = $Test->ok( !$@, "use $module;" );
+
+    unless( $ok ) {
+        chomp $@;
+        $@ =~ s{^BEGIN failed--compilation aborted at .*$}
+                {BEGIN failed--compilation aborted at $filename line $line.}m;
+        $Test->diag(<<DIAGNOSTIC);
+    Tried to use '$module'.
+    Error:  $@
+DIAGNOSTIC
+
+    }
+
+    return $ok;
+}
+
+=item B<require_ok>
+
+   require_ok($module);
+   require_ok($file);
+
+Like use_ok(), except it requires the $module or $file.
+
+=cut
+
+sub require_ok ($) {
+    my($module) = shift;
+
+    my $pack = caller;
+
+    # Try to deterine if we've been given a module name or file.
+    # Module names must be barewords, files not.
+    $module = qq['$module'] unless _is_module_name($module);
+
+    local($!, $@); # eval sometimes interferes with $!
+    eval <<REQUIRE;
+package $pack;
+require $module;
+REQUIRE
+
+    my $ok = $Test->ok( !$@, "require $module;" );
+
+    unless( $ok ) {
+        chomp $@;
+        $Test->diag(<<DIAGNOSTIC);
+    Tried to require '$module'.
+    Error:  $@
+DIAGNOSTIC
+
+    }
+
+    return $ok;
+}
+
+
+sub _is_module_name {
+    my $module = shift;
+
+    # Module names start with a letter.
+    # End with an alphanumeric.
+    # The rest is an alphanumeric or ::
+    $module =~ s/\b::\b//g;
+    $module =~ /^[a-zA-Z]\w*$/;
+}
+
+=back
+
+=head2 Conditional tests
+
+Sometimes running a test under certain conditions will cause the
+test script to die.  A certain function or method isn't implemented
+(such as fork() on MacOS), some resource isn't available (like a 
+net connection) or a module isn't available.  In these cases it's
+necessary to skip tests, or declare that they are supposed to fail
+but will work in the future (a todo test).
+
+For more details on the mechanics of skip and todo tests see
+L<Test::Harness>.
+
+The way Test::More handles this is with a named block.  Basically, a
+block of tests which can be skipped over or made todo.  It's best if I
+just show you...
+
+=over 4
+
+=item B<SKIP: BLOCK>
+
+  SKIP: {
+      skip $why, $how_many if $condition;
+
+      ...normal testing code goes here...
+  }
+
+This declares a block of tests that might be skipped, $how_many tests
+there are, $why and under what $condition to skip them.  An example is
+the easiest way to illustrate:
+
+    SKIP: {
+        eval { require HTML::Lint };
+
+        skip "HTML::Lint not installed", 2 if $@;
+
+        my $lint = new HTML::Lint;
+        isa_ok( $lint, "HTML::Lint" );
+
+        $lint->parse( $html );
+        is( $lint->errors, 0, "No errors found in HTML" );
+    }
+
+If the user does not have HTML::Lint installed, the whole block of
+code I<won't be run at all>.  Test::More will output special ok's
+which Test::Harness interprets as skipped, but passing, tests.
+
+It's important that $how_many accurately reflects the number of tests
+in the SKIP block so the # of tests run will match up with your plan.
+If your plan is C<no_plan> $how_many is optional and will default to 1.
+
+It's perfectly safe to nest SKIP blocks.  Each SKIP block must have
+the label C<SKIP>, or Test::More can't work its magic.
+
+You don't skip tests which are failing because there's a bug in your
+program, or for which you don't yet have code written.  For that you
+use TODO.  Read on.
+
+=cut
+
+#'#
+sub skip {
+    my($why, $how_many) = @_;
+
+    unless( defined $how_many ) {
+        # $how_many can only be avoided when no_plan is in use.
+        _carp "skip() needs to know \$how_many tests are in the block"
+          unless $Test->has_plan eq 'no_plan';
+        $how_many = 1;
+    }
+
+    for( 1..$how_many ) {
+        $Test->skip($why);
+    }
+
+    local $^W = 0;
+    last SKIP;
+}
+
+
+=item B<TODO: BLOCK>
+
+    TODO: {
+        local $TODO = $why if $condition;
+
+        ...normal testing code goes here...
+    }
+
+Declares a block of tests you expect to fail and $why.  Perhaps it's
+because you haven't fixed a bug or haven't finished a new feature:
+
+    TODO: {
+        local $TODO = "URI::Geller not finished";
+
+        my $card = "Eight of clubs";
+        is( URI::Geller->your_card, $card, 'Is THIS your card?' );
+
+        my $spoon;
+        URI::Geller->bend_spoon;
+        is( $spoon, 'bent',    "Spoon bending, that's original" );
+    }
+
+With a todo block, the tests inside are expected to fail.  Test::More
+will run the tests normally, but print out special flags indicating
+they are "todo".  Test::Harness will interpret failures as being ok.
+Should anything succeed, it will report it as an unexpected success.
+You then know the thing you had todo is done and can remove the
+TODO flag.
+
+The nice part about todo tests, as opposed to simply commenting out a
+block of tests, is it's like having a programmatic todo list.  You know
+how much work is left to be done, you're aware of what bugs there are,
+and you'll know immediately when they're fixed.
+
+Once a todo test starts succeeding, simply move it outside the block.
+When the block is empty, delete it.
+
+B<NOTE>: TODO tests require a Test::Harness upgrade else it will
+treat it as a normal failure.  See L<BUGS>)
+
+
+=item B<todo_skip>
+
+    TODO: {
+        todo_skip $why, $how_many if $condition;
+
+        ...normal testing code...
+    }
+
+With todo tests, it's best to have the tests actually run.  That way
+you'll know when they start passing.  Sometimes this isn't possible.
+Often a failing test will cause the whole program to die or hang, even
+inside an C<eval BLOCK> with and using C<alarm>.  In these extreme
+cases you have no choice but to skip over the broken tests entirely.
+
+The syntax and behavior is similar to a C<SKIP: BLOCK> except the
+tests will be marked as failing but todo.  Test::Harness will
+interpret them as passing.
+
+=cut
+
+sub todo_skip {
+    my($why, $how_many) = @_;
+
+    unless( defined $how_many ) {
+        # $how_many can only be avoided when no_plan is in use.
+        _carp "todo_skip() needs to know \$how_many tests are in the block"
+          unless $Test->has_plan eq 'no_plan';
+        $how_many = 1;
+    }
+
+    for( 1..$how_many ) {
+        $Test->todo_skip($why);
+    }
+
+    local $^W = 0;
+    last TODO;
+}
+
+=item When do I use SKIP vs. TODO?
+
+B<If it's something the user might not be able to do>, use SKIP.
+This includes optional modules that aren't installed, running under
+an OS that doesn't have some feature (like fork() or symlinks), or maybe
+you need an Internet connection and one isn't available.
+
+B<If it's something the programmer hasn't done yet>, use TODO.  This
+is for any code you haven't written yet, or bugs you have yet to fix,
+but want to put tests in your testing script (always a good idea).
+
+
+=back
+
+=head2 Complex data structures
+
+Not everything is a simple eq check or regex.  There are times you
+need to see if two data structures are equivalent.  For these
+instances Test::More provides a handful of useful functions.
+
+B<NOTE> I'm not quite sure what will happen with filehandles.
+
+=over 4
+
+=item B<is_deeply>
+
+  is_deeply( $this, $that, $test_name );
+
+Similar to is(), except that if $this and $that are hash or array
+references, it does a deep comparison walking each data structure to
+see if they are equivalent.  If the two structures are different, it
+will display the place where they start differing.
+
+Test::Differences and Test::Deep provide more in-depth functionality
+along these lines.
+
+=back
+
+=cut
+
+our (@Data_Stack, %Refs_Seen);
+my $DNE = bless [], 'Does::Not::Exist';
+sub is_deeply {
+    unless( @_ == 2 or @_ == 3 ) {
+        my $msg = <<WARNING;
+is_deeply() takes two or three args, you gave %d.
+This usually means you passed an array or hash instead 
+of a reference to it
+WARNING
+        chop $msg;   # clip off newline so carp() will put in line/file
+
+        _carp sprintf $msg, scalar @_;
+
+	return $Test->ok(0);
+    }
+
+    my($this, $that, $name) = @_;
+
+    my $ok;
+    if( !ref $this and !ref $that ) {  		# neither is a reference
+        $ok = $Test->is_eq($this, $that, $name);
+    }
+    elsif( !ref $this xor !ref $that ) {  	# one's a reference, one isn't
+        $ok = $Test->ok(0, $name);
+	$Test->diag( _format_stack({ vals => [ $this, $that ] }) );
+    }
+    else {			       		# both references
+        local @Data_Stack = ();
+        if( _deep_check($this, $that) ) {
+            $ok = $Test->ok(1, $name);
+        }
+        else {
+            $ok = $Test->ok(0, $name);
+            $Test->diag(_format_stack(@Data_Stack));
+        }
+    }
+
+    return $ok;
+}
+
+sub _format_stack {
+    my(@Stack) = @_;
+
+    my $var = '$FOO';
+    my $did_arrow = 0;
+    foreach my $entry (@Stack) {
+        my $type = $entry->{type} || '';
+        my $idx  = $entry->{'idx'};
+        if( $type eq 'HASH' ) {
+            $var .= "->" unless $did_arrow++;
+            $var .= "{$idx}";
+        }
+        elsif( $type eq 'ARRAY' ) {
+            $var .= "->" unless $did_arrow++;
+            $var .= "[$idx]";
+        }
+        elsif( $type eq 'REF' ) {
+            $var = "\${$var}";
+        }
+    }
+
+    my @vals = @{$Stack[-1]{vals}}[0,1];
+    my @vars = ();
+    ($vars[0] = $var) =~ s/\$FOO/     \$got/;
+    ($vars[1] = $var) =~ s/\$FOO/\$expected/;
+
+    my $out = "Structures begin differing at:\n";
+    foreach my $idx (0..$#vals) {
+        my $val = $vals[$idx];
+        $vals[$idx] = !defined $val ? 'undef'          :
+                      $val eq $DNE  ? "Does not exist" :
+	              ref $val      ? "$val"           :
+                                      "'$val'";
+    }
+
+    $out .= "$vars[0] = $vals[0]\n";
+    $out .= "$vars[1] = $vals[1]\n";
+
+    $out =~ s/^/    /msg;
+    return $out;
+}
+
+
+sub _type {
+    my $thing = shift;
+
+    return '' if !ref $thing;
+
+    for my $type (qw(ARRAY HASH REF SCALAR GLOB Regexp)) {
+        return $type if UNIVERSAL::isa($thing, $type);
+    }
+
+    return '';
+}
+
+
+=head2 Discouraged comparison functions
+
+The use of the following functions is discouraged as they are not
+actually testing functions and produce no diagnostics to help figure
+out what went wrong.  They were written before is_deeply() existed
+because I couldn't figure out how to display a useful diff of two
+arbitrary data structures.
+
+These functions are usually used inside an ok().
+
+    ok( eq_array(\@this, \@that) );
+
+C<is_deeply()> can do that better and with diagnostics.  
+
+    is_deeply( \@this, \@that );
+
+They may be deprecated in future versions.
+
+=over 4
+
+=item B<eq_array>
+
+  my $is_eq = eq_array(\@this, \@that);
+
+Checks if two arrays are equivalent.  This is a deep check, so
+multi-level structures are handled correctly.
+
+=cut
+
+#'#
+sub eq_array {
+    local @Data_Stack;
+    _deep_check(@_);
+}
+
+sub _eq_array  {
+    my($a1, $a2) = @_;
+
+    if( grep !_type($_) eq 'ARRAY', $a1, $a2 ) {
+        warn "eq_array passed a non-array ref";
+        return 0;
+    }
+
+    return 1 if $a1 eq $a2;
+
+    my $ok = 1;
+    my $max = $#$a1 > $#$a2 ? $#$a1 : $#$a2;
+    for (0..$max) {
+        my $e1 = $_ > $#$a1 ? $DNE : $a1->[$_];
+        my $e2 = $_ > $#$a2 ? $DNE : $a2->[$_];
+
+        push @Data_Stack, { type => 'ARRAY', idx => $_, vals => [$e1, $e2] };
+        $ok = _deep_check($e1,$e2);
+        pop @Data_Stack if $ok;
+
+        last unless $ok;
+    }
+
+    return $ok;
+}
+
+sub _deep_check {
+    my($e1, $e2) = @_;
+    my $ok = 0;
+
+    # Effectively turn %Refs_Seen into a stack.  This avoids picking up
+    # the same referenced used twice (such as [\$a, \$a]) to be considered
+    # circular.
+    local %Refs_Seen = %Refs_Seen;
+
+    {
+        # Quiet uninitialized value warnings when comparing undefs.
+        local $^W = 0; 
+
+        $Test->_unoverload(\$e1, \$e2);
+
+        # Either they're both references or both not.
+        my $same_ref = !(!ref $e1 xor !ref $e2);
+	my $not_ref  = (!ref $e1 and !ref $e2);
+
+        if( defined $e1 xor defined $e2 ) {
+            $ok = 0;
+        }
+        elsif ( $e1 == $DNE xor $e2 == $DNE ) {
+            $ok = 0;
+        }
+        elsif ( $same_ref and ($e1 eq $e2) ) {
+            $ok = 1;
+        }
+	elsif ( $not_ref ) {
+	    push @Data_Stack, { type => '', vals => [$e1, $e2] };
+	    $ok = 0;
+	}
+        else {
+            if( $Refs_Seen{$e1} ) {
+                return $Refs_Seen{$e1} eq $e2;
+            }
+            else {
+                $Refs_Seen{$e1} = "$e2";
+            }
+
+            my $type = _type($e1);
+            $type = 'DIFFERENT' unless _type($e2) eq $type;
+
+            if( $type eq 'DIFFERENT' ) {
+                push @Data_Stack, { type => $type, vals => [$e1, $e2] };
+                $ok = 0;
+            }
+            elsif( $type eq 'ARRAY' ) {
+                $ok = _eq_array($e1, $e2);
+            }
+            elsif( $type eq 'HASH' ) {
+                $ok = _eq_hash($e1, $e2);
+            }
+            elsif( $type eq 'REF' ) {
+                push @Data_Stack, { type => $type, vals => [$e1, $e2] };
+                $ok = _deep_check($$e1, $$e2);
+                pop @Data_Stack if $ok;
+            }
+            elsif( $type eq 'SCALAR' ) {
+                push @Data_Stack, { type => 'REF', vals => [$e1, $e2] };
+                $ok = _deep_check($$e1, $$e2);
+                pop @Data_Stack if $ok;
+            }
+	    else {
+		_whoa(1, "No type in _deep_check");
+	    }
+        }
+    }
+
+    return $ok;
+}
+
+
+sub _whoa {
+    my($check, $desc) = @_;
+    if( $check ) {
+        die <<WHOA;
+WHOA!  $desc
+This should never happen!  Please contact the author immediately!
+WHOA
+    }
+}
+
+
+=item B<eq_hash>
+
+  my $is_eq = eq_hash(\%this, \%that);
+
+Determines if the two hashes contain the same keys and values.  This
+is a deep check.
+
+=cut
+
+sub eq_hash {
+    local @Data_Stack;
+    return _deep_check(@_);
+}
+
+sub _eq_hash {
+    my($a1, $a2) = @_;
+
+    if( grep !_type($_) eq 'HASH', $a1, $a2 ) {
+        warn "eq_hash passed a non-hash ref";
+        return 0;
+    }
+
+    return 1 if $a1 eq $a2;
+
+    my $ok = 1;
+    my $bigger = keys %$a1 > keys %$a2 ? $a1 : $a2;
+    foreach my $k (keys %$bigger) {
+        my $e1 = exists $a1->{$k} ? $a1->{$k} : $DNE;
+        my $e2 = exists $a2->{$k} ? $a2->{$k} : $DNE;
+
+        push @Data_Stack, { type => 'HASH', idx => $k, vals => [$e1, $e2] };
+        $ok = _deep_check($e1, $e2);
+        pop @Data_Stack if $ok;
+
+        last unless $ok;
+    }
+
+    return $ok;
+}
+
+=item B<eq_set>
+
+  my $is_eq = eq_set(\@this, \@that);
+
+Similar to eq_array(), except the order of the elements is B<not>
+important.  This is a deep check, but the irrelevancy of order only
+applies to the top level.
+
+    ok( eq_set(\@this, \@that) );
+
+Is better written:
+
+    is_deeply( [sort @this], [sort @that] );
+
+B<NOTE> By historical accident, this is not a true set comparision.
+While the order of elements does not matter, duplicate elements do.
+
+Test::Deep contains much better set comparison functions.
+
+=cut
+
+sub eq_set  {
+    my($a1, $a2) = @_;
+    return 0 unless @$a1 == @$a2;
+
+    # There's faster ways to do this, but this is easiest.
+    local $^W = 0;
+
+    # We must make sure that references are treated neutrally.  It really
+    # doesn't matter how we sort them, as long as both arrays are sorted
+    # with the same algorithm.
+    # Have to inline the sort routine due to a threading/sort bug.
+    # See [rt.cpan.org 6782]
+    return eq_array(
+           [sort { ref $a ? -1 : ref $b ? 1 : $a cmp $b } @$a1],
+           [sort { ref $a ? -1 : ref $b ? 1 : $a cmp $b } @$a2]
+    );
+}
+
+=back
+
+
+=head2 Extending and Embedding Test::More
+
+Sometimes the Test::More interface isn't quite enough.  Fortunately,
+Test::More is built on top of Test::Builder which provides a single,
+unified backend for any test library to use.  This means two test
+libraries which both use Test::Builder B<can be used together in the
+same program>.
+
+If you simply want to do a little tweaking of how the tests behave,
+you can access the underlying Test::Builder object like so:
+
+=over 4
+
+=item B<builder>
+
+    my $test_builder = Test::More->builder;
+
+Returns the Test::Builder object underlying Test::More for you to play
+with.
+
+=cut
+
+sub builder {
+    return Test::Builder->new;
+}
+
+=back
+
+
+=head1 EXIT CODES
+
+If all your tests passed, Test::Builder will exit with zero (which is
+normal).  If anything failed it will exit with how many failed.  If
+you run less (or more) tests than you planned, the missing (or extras)
+will be considered failures.  If no tests were ever run Test::Builder
+will throw a warning and exit with 255.  If the test died, even after
+having successfully completed all its tests, it will still be
+considered a failure and will exit with 255.
+
+So the exit codes are...
+
+    0                   all tests successful
+    255                 test died
+    any other number    how many failed (including missing or extras)
+
+If you fail more than 254 tests, it will be reported as 254.
+
+B<NOTE>  This behavior may go away in future versions.
+
+
+=head1 CAVEATS and NOTES
+
+=over 4
+
+=item Backwards compatibility
+
+Test::More works with Perls as old as 5.004_05.
+
+
+=item Overloaded objects
+
+String overloaded objects are compared B<as strings>.  This prevents
+Test::More from piercing an object's interface allowing better blackbox
+testing.  So if a function starts returning overloaded objects instead of
+bare strings your tests won't notice the difference.  This is good.
+
+However, it does mean that functions like is_deeply() cannot be used to
+test the internals of string overloaded objects.  In this case I would
+suggest Test::Deep which contains more flexible testing functions for
+complex data structures.
+
+
+=item Threads
+
+Test::More will only be aware of threads if "use threads" has been done
+I<before> Test::More is loaded.  This is ok:
+
+    use threads;
+    use Test::More;
+
+This may cause problems:
+
+    use Test::More
+    use threads;
+
+
+=item Test::Harness upgrade
+
+no_plan and todo depend on new Test::Harness features and fixes.  If
+you're going to distribute tests that use no_plan or todo your
+end-users will have to upgrade Test::Harness to the latest one on
+CPAN.  If you avoid no_plan and TODO tests, the stock Test::Harness
+will work fine.
+
+Installing Test::More should also upgrade Test::Harness.
+
+=back
+
+
+=head1 HISTORY
+
+This is a case of convergent evolution with Joshua Pritikin's Test
+module.  I was largely unaware of its existence when I'd first
+written my own ok() routines.  This module exists because I can't
+figure out how to easily wedge test names into Test's interface (along
+with a few other problems).
+
+The goal here is to have a testing utility that's simple to learn,
+quick to use and difficult to trip yourself up with while still
+providing more flexibility than the existing Test.pm.  As such, the
+names of the most common routines are kept tiny, special cases and
+magic side-effects are kept to a minimum.  WYSIWYG.
+
+
+=head1 SEE ALSO
+
+L<Test::Simple> if all this confuses you and you just want to write
+some tests.  You can upgrade to Test::More later (it's forward
+compatible).
+
+L<Test> is the old testing module.  Its main benefit is that it has
+been distributed with Perl since 5.004_05.
+
+L<Test::Harness> for details on how your test results are interpreted
+by Perl.
+
+L<Test::Differences> for more ways to test complex data structures.
+And it plays well with Test::More.
+
+L<Test::Class> is like XUnit but more perlish.
+
+L<Test::Deep> gives you more powerful complex data structure testing.
+
+L<Test::Unit> is XUnit style testing.
+
+L<Test::Inline> shows the idea of embedded testing.
+
+L<Bundle::Test> installs a whole bunch of useful test modules.
+
+
+=head1 AUTHORS
+
+Michael G Schwern E<lt>schwern@pobox.comE<gt> with much inspiration
+from Joshua Pritikin's Test module and lots of help from Barrie
+Slaymaker, Tony Bowden, blackstar.co.uk, chromatic, Fergal Daly and
+the perl-qa gang.
+
+
+=head1 BUGS
+
+See F<http://rt.cpan.org> to report and view bugs.
+
+
+=head1 COPYRIGHT
+
+Copyright 2001, 2002, 2004 by Michael G Schwern E<lt>schwern@pobox.comE<gt>.
+
+This program is free software; you can redistribute it and/or 
+modify it under the same terms as Perl itself.
+
+See F<http://www.perl.com/perl/misc/Artistic.html>
+
+=cut
+
+1;
diff -urN perl-5.10.0/ext/IO_Compress_Base/t.xxx/Test/Simple.pm perl-5.10.0/ext/IO_Compress_Base/t/Test/Simple.pm
--- perl-5.10.0/ext/IO_Compress_Base/t.xxx/Test/Simple.pm	1970-01-01 01:00:00.000000000 +0100
+++ perl-5.10.0/ext/IO_Compress_Base/t/Test/Simple.pm	2008-05-05 14:09:25.000000000 +0200
@@ -0,0 +1,236 @@
+package Test::Simple;
+
+use 5.004;
+
+use strict 'vars';
+our ($VERSION);
+$VERSION = '0.60';
+$VERSION = eval $VERSION;    # make the alpha version come out as a number
+
+
+use Test::Builder;
+my $Test = Test::Builder->new;
+
+sub import {
+    my $self = shift;
+    my $caller = caller;
+    *{$caller.'::ok'} = \&ok;
+
+    $Test->exported_to($caller);
+    $Test->plan(@_);
+}
+
+
+=head1 NAME
+
+Test::Simple - Basic utilities for writing tests.
+
+=head1 SYNOPSIS
+
+  use Test::Simple tests => 1;
+
+  ok( $foo eq $bar, 'foo is bar' );
+
+
+=head1 DESCRIPTION
+
+** If you are unfamiliar with testing B<read Test::Tutorial> first! **
+
+This is an extremely simple, extremely basic module for writing tests
+suitable for CPAN modules and other pursuits.  If you wish to do more
+complicated testing, use the Test::More module (a drop-in replacement
+for this one).
+
+The basic unit of Perl testing is the ok.  For each thing you want to
+test your program will print out an "ok" or "not ok" to indicate pass
+or fail.  You do this with the ok() function (see below).
+
+The only other constraint is you must pre-declare how many tests you
+plan to run.  This is in case something goes horribly wrong during the
+test and your test program aborts, or skips a test or whatever.  You
+do this like so:
+
+    use Test::Simple tests => 23;
+
+You must have a plan.
+
+
+=over 4
+
+=item B<ok>
+
+  ok( $foo eq $bar, $name );
+  ok( $foo eq $bar );
+
+ok() is given an expression (in this case C<$foo eq $bar>).  If it's
+true, the test passed.  If it's false, it didn't.  That's about it.
+
+ok() prints out either "ok" or "not ok" along with a test number (it
+keeps track of that for you).
+
+  # This produces "ok 1 - Hell not yet frozen over" (or not ok)
+  ok( get_temperature($hell) > 0, 'Hell not yet frozen over' );
+
+If you provide a $name, that will be printed along with the "ok/not
+ok" to make it easier to find your test when if fails (just search for
+the name).  It also makes it easier for the next guy to understand
+what your test is for.  It's highly recommended you use test names.
+
+All tests are run in scalar context.  So this:
+
+    ok( @stuff, 'I have some stuff' );
+
+will do what you mean (fail if stuff is empty)
+
+=cut
+
+sub ok ($;$) {
+    $Test->ok(@_);
+}
+
+
+=back
+
+Test::Simple will start by printing number of tests run in the form
+"1..M" (so "1..5" means you're going to run 5 tests).  This strange
+format lets Test::Harness know how many tests you plan on running in
+case something goes horribly wrong.
+
+If all your tests passed, Test::Simple will exit with zero (which is
+normal).  If anything failed it will exit with how many failed.  If
+you run less (or more) tests than you planned, the missing (or extras)
+will be considered failures.  If no tests were ever run Test::Simple
+will throw a warning and exit with 255.  If the test died, even after
+having successfully completed all its tests, it will still be
+considered a failure and will exit with 255.
+
+So the exit codes are...
+
+    0                   all tests successful
+    255                 test died
+    any other number    how many failed (including missing or extras)
+
+If you fail more than 254 tests, it will be reported as 254.
+
+This module is by no means trying to be a complete testing system.
+It's just to get you started.  Once you're off the ground its
+recommended you look at L<Test::More>.
+
+
+=head1 EXAMPLE
+
+Here's an example of a simple .t file for the fictional Film module.
+
+    use Test::Simple tests => 5;
+
+    use Film;  # What you're testing.
+
+    my $btaste = Film->new({ Title    => 'Bad Taste',
+                             Director => 'Peter Jackson',
+                             Rating   => 'R',
+                             NumExplodingSheep => 1
+                           });
+    ok( defined($btaste) && ref $btaste eq 'Film,     'new() works' );
+
+    ok( $btaste->Title      eq 'Bad Taste',     'Title() get'    );
+    ok( $btaste->Director   eq 'Peter Jackson', 'Director() get' );
+    ok( $btaste->Rating     eq 'R',             'Rating() get'   );
+    ok( $btaste->NumExplodingSheep == 1,        'NumExplodingSheep() get' );
+
+It will produce output like this:
+
+    1..5
+    ok 1 - new() works
+    ok 2 - Title() get
+    ok 3 - Director() get
+    not ok 4 - Rating() get
+    #    Failed test (t/film.t at line 14)
+    ok 5 - NumExplodingSheep() get
+    # Looks like you failed 1 tests of 5
+
+Indicating the Film::Rating() method is broken.
+
+
+=head1 CAVEATS
+
+Test::Simple will only report a maximum of 254 failures in its exit
+code.  If this is a problem, you probably have a huge test script.
+Split it into multiple files.  (Otherwise blame the Unix folks for
+using an unsigned short integer as the exit status).
+
+Because VMS's exit codes are much, much different than the rest of the
+universe, and perl does horrible mangling to them that gets in my way,
+it works like this on VMS.
+
+    0     SS$_NORMAL        all tests successful
+    4     SS$_ABORT         something went wrong
+
+Unfortunately, I can't differentiate any further.
+
+
+=head1 NOTES
+
+Test::Simple is B<explicitly> tested all the way back to perl 5.004.
+
+Test::Simple is thread-safe in perl 5.8.0 and up.
+
+=head1 HISTORY
+
+This module was conceived while talking with Tony Bowden in his
+kitchen one night about the problems I was having writing some really
+complicated feature into the new Testing module.  He observed that the
+main problem is not dealing with these edge cases but that people hate
+to write tests B<at all>.  What was needed was a dead simple module
+that took all the hard work out of testing and was really, really easy
+to learn.  Paul Johnson simultaneously had this idea (unfortunately,
+he wasn't in Tony's kitchen).  This is it.
+
+
+=head1 SEE ALSO
+
+=over 4
+
+=item L<Test::More>
+
+More testing functions!  Once you outgrow Test::Simple, look at
+Test::More.  Test::Simple is 100% forward compatible with Test::More
+(i.e. you can just use Test::More instead of Test::Simple in your
+programs and things will still work).
+
+=item L<Test>
+
+The original Perl testing module.
+
+=item L<Test::Unit>
+
+Elaborate unit testing.
+
+=item L<Test::Inline>, L<SelfTest>
+
+Embed tests in your code!
+
+=item L<Test::Harness>
+
+Interprets the output of your test program.
+
+=back
+
+
+=head1 AUTHORS
+
+Idea by Tony Bowden and Paul Johnson, code by Michael G Schwern
+E<lt>schwern@pobox.comE<gt>, wardrobe by Calvin Klein.
+
+
+=head1 COPYRIGHT
+
+Copyright 2001, 2002, 2004 by Michael G Schwern E<lt>schwern@pobox.comE<gt>.
+
+This program is free software; you can redistribute it and/or 
+modify it under the same terms as Perl itself.
+
+See F<http://www.perl.com/perl/misc/Artistic.html>
+
+=cut
+
+1;
