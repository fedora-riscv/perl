diff -up perl-5.8.8/lib/overload.t.U32018 perl-5.8.8/lib/overload.t
--- perl-5.8.8/lib/overload.t.U32018	2008-08-27 10:11:02.000000000 -0400
+++ perl-5.8.8/lib/overload.t	2008-08-27 10:13:21.000000000 -0400
@@ -31,7 +31,7 @@ use overload ( 
 
 qw(
 ""	stringify
-0+	numify)			# Order of arguments unsignificant
+0+	numify)			# Order of arguments insignificant
 );
 
 sub new {
@@ -47,7 +47,7 @@ sub numify { 0 + "${$_[0]}" }	# Not need
 package main;
 
 $| = 1;
-use Test::More tests => 508;
+use Test::More tests => 514;
 
 
 $a = new Oscalar "087";
@@ -744,10 +744,10 @@ else {
 		    }, 'deref';
   # Hash:
   my @cont = sort %$deref;
-  if ("\t" eq "\011") { # ascii
+  if ("\t" eq "\011") { # ASCII
       is("@cont", '23 5 fake foo');
   } 
-  else {                # ebcdic alpha-numeric sort order
+  else {                # EBCDIC alpha-numeric sort order
       is("@cont", 'fake foo 23 5');
   }
   my @keys = sort keys %$deref;
@@ -986,7 +986,7 @@ unless ($aaa) {
   main::is("$int_x", 1054);
 }
 
-# make sure that we don't inifinitely recurse
+# make sure that we don't infinitely recurse
 {
   my $c = 0;
   package Recurse;
@@ -1131,7 +1131,7 @@ like ($@, qr/zap/);
     like(overload::StrVal($no),       qr/^no_overload=ARRAY\(0x[0-9a-f]+\)$/);
 }
 
-# These are all check that overloaded values rather than reference addressess
+# These are all check that overloaded values rather than reference addresses
 # are what is getting tested.
 my ($two, $one, $un, $deux) = map {new Numify $_} 2, 1, 1, 2;
 my ($ein, $zwei) = (1, 2);
@@ -1205,7 +1205,7 @@ foreach my $op (qw(<=> == != < <= > >=))
     my $obj;
     $obj = bless {name => 'cool'}, 'Sklorsh';
     $obj->delete;
-    ok(eval {if ($obj) {1}; 1}, $@ || 'reblessed into nonexist namespace');
+    ok(eval {if ($obj) {1}; 1}, $@ || 'reblessed into nonexistent namespace');
 
     $obj = bless {name => 'cool'}, 'Sklorsh';
     $obj->delete_with_self;
@@ -1246,3 +1246,46 @@ foreach my $op (qw(<=> == != < <= > >=))
     undef $obj;
     is ($ref, undef);
 }
+
+{
+    # Subtle bug pre 5.10, as a side effect of the overloading flag being
+    # stored on the reference rather than the referent. Despite the fact that
+    # objects can only be accessed via references (even internally), the
+    # referent actually knows that it's blessed, not the references. So taking
+    # a new, unrelated, reference to it gives an object. However, the
+    # overloading-or-not flag was on the reference prior to 5.10, and taking
+    # a new reference didn't (use to) copy it.
+
+    package kayo;
+
+    use overload '""' => sub {${$_[0]}};
+
+    sub Pie {
+	return "$_[0], $_[1]";
+    }
+
+    package main;
+
+    my $class = 'kayo';
+    my $string = 'bam';
+    my $crunch_eth = bless \$string, $class;
+
+    is("$crunch_eth", $string);
+    is ($crunch_eth->Pie("Meat"), "$string, Meat");
+
+    my $wham_eth = \$string;
+
+    is("$wham_eth", $string,
+       'This reference did not have overloading in 5.8.8 and earlier');
+    is ($crunch_eth->Pie("Apple"), "$string, Apple");
+
+    my $class = ref $wham_eth;
+    $class =~ s/=.*//;
+
+    # Bless it back into its own class!
+    bless $wham_eth, $class;
+
+    is("$wham_eth", $string);
+    is ($crunch_eth->Pie("Blackbird"), "$string, Blackbird");
+}
+
diff -up perl-5.8.8/pp.c.U32018 perl-5.8.8/pp.c
--- perl-5.8.8/pp.c.U32018	2008-08-27 10:13:55.000000000 -0400
+++ perl-5.8.8/pp.c	2008-08-27 10:14:20.000000000 -0400
@@ -503,6 +503,13 @@ S_refto(pTHX_ SV *sv)
     sv_upgrade(rv, SVt_RV);
     SvRV_set(rv, sv);
     SvROK_on(rv);
+    /* As overloading is stored on the reference, not the referant, need to
+       propagate this flag to the new reference we create.  */
+    if (SvOBJECT(sv)) {
+	HV *const stash = SvSTASH(sv);
+	if (Gv_AMG(stash))
+	    SvAMAGIC_on(rv);
+    }
     return rv;
 }
 
